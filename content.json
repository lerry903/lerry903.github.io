{"meta":{"title":"LErry","subtitle":null,"description":"记录生活点滴","author":"LErry Li","url":"https://www.itchina.top"},"pages":[],"posts":[{"title":"在Docker容器中运行Spring Boot应用","slug":"在Docker容器中运行Spring Boot应用","date":"2018-04-19T16:34:21.469Z","updated":"2018-04-20T14:19:16.128Z","comments":true,"path":"2018/04/20/在Docker容器中运行Spring Boot应用/","link":"","permalink":"https://www.itchina.top/2018/04/20/在Docker容器中运行Spring Boot应用/","excerpt":"","text":"在Docker容器中运行Spring Boot应用Spring Boot简化了Spring应用的开发过程，遵循约定优先配置的原则提供了各类开箱即用（out-of-the-box）的框架配置。另一方面，SpringBoot还具备将代码直接构建为可执行jar包的能力，这个jar包是一个可以独立运行的部署单元。基于以上特性，现在普遍认为 Spring Boot 提供了一种快速构造 微服务(Micro-Service) 的能力。 Docker与Spring Boot Docker 是一种Linux容器的实现，Linux容器是基于进程的轻量级资源隔离技术，每一个容器对应操作系统中的一个进程，但是它又会有自己的网络空间、文件系统、PID等。Docker除了实现Linux容器，还使得容器具有“社会化”的功能，用户可以将容器镜像发布在 Docker Hub 与其他开发者共享、协作。安装Docker的教程请参考 官方文档 Spring Boot应用通常被构建为一个可单独执行的jar包，通过 java -jar ...运行，但是框架本身并没有提供以服务形式运行在后台的方法，通常需要借助Systemd, Supervisord等进程管理工具来实现。另一方面，虽然应用运行环境非常的简单，但是将他们容器化为Docker容器镜像并运行，对于自动化部署、运维都是非常有利的。 本文将以一个最简单的SpringBoot开发的Web应用为例，讲解如何将其容器化运行。本文的重点是构建Docker镜像、运行Docker容器，关于SpringBoot开发Web应用可以参考 Spring Boot应用开发 构建并Spring Boot应用在应用代码编写完成后，可以直接将其打包并运行： Maven: mvn package &amp;&amp; java -jar target/spring-boot-docker-0.1.0.jar Gradle: gradle build &amp;&amp; java -jar build/libs/gs-spring-boot-docker-0.1.0.jar 在浏览器地址栏种输入 [ [ http://localhost:8080/ ](http://localhost:8080/) ]( [ http://localhost:8080/ ](http://localhost:8080/) ) 可以访问应用 Dockerfile构建镜像Docker提供了 Dockerfile 格式的文件来构建应用镜像，现在开始创建一个Spring Boot应用的Dockerfile: FROM java:8 VOLUME /tmp ADD spring-boot-docker-0.1.0.jar app.jar RUN bash -c &apos;touch /app.jar&apos; ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] java:8 是指Docker Hub上官方提供的java镜像，版本号是8也就是jdk1.8，有了这个基础镜像后，Dockerfile可以通过 FROM 指令直接获取它的状态——也就是在容器中 java 是已经安装的，接下来通过自定义的命令来运行Spring Boot应用： VOLUME /tmp 创建/tmp目录并持久化到Docker数据文件夹，因为Spring Boot使用的内嵌Tomcat容器默认使用 /tmp 作为工作目录 ADD spring-boot-docker-0.1.0.jar app.jar 将应用jar包复制到 /app.jar ENTRYPOINT 表示容器运行后默认执行的命令 Dockerfile非常的简单，编辑完成后运行docker构建镜像命令： docker build -t tmy/spring-boot-app . 然后运行Docker容器： docker run -d -p 8080:8080 --name sample-app tmy/spring-boot-app 其中 -d 表示后台运行容器，这也就自然地解决的Spring Boot不支持后台运行应用程序的问题。 -p 8080:8080表示将容器内部的8080端口映射到宿主机器的8080端口，这样就可以通过宿主机器直接访问应用。 \\--name sample-app给容器取一个容易记住的名字方便日后管理。 使用Maven/Gradle创建Docker镜像为了方便Java开发者创建Docker镜像，Maven/Gradle都提供了响应的插件。 Maven&lt;properties&gt; &lt;docker.image.prefix&gt;springio&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.2.3&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;${project.build.directory}&lt;/directory&gt; &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 上述 pom.xml 包含了 docker-maven-plugin 的配置： imageName 指定了镜像的名字 dockerDirectory 指定Dockerfile的位置 resources 是指那些需要和Dockerfile放在一起，在构建镜像时使用的文件，一般应用jar包需要纳入 经过以上配置后，运行下列命令可以在本地Docker中创建一个镜像： $ mvn package docker:build GradleGradle同样也有支持Docker的插件： buildscript { ... dependencies { ... classpath(&apos;se.transmode.gradle:gradle-docker:1.2&apos;) } } group = &apos;springio&apos; ... apply plugin: &apos;docker&apos; task buildDocker(type: Docker, dependsOn: build) { push = true applicationName = jar.baseName dockerfile = file(&apos;src/main/docker/Dockerfile&apos;) doFirst { copy { from jar into stageDir } } } 上述配置和Maven基本类似，执行以下命令构建镜像： $ gradle build buildDocker 版权印为您的作品印上版权58927609","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring-boo","slug":"spring-boo","permalink":"https://www.itchina.top/tags/spring-boo/"},{"name":"Docker","slug":"Docker","permalink":"https://www.itchina.top/tags/Docker/"}]},{"title":"小白科普：分布式和集群","slug":"小白科普：分布式和集群","date":"2018-04-19T16:34:21.468Z","updated":"2018-04-19T16:29:55.541Z","comments":true,"path":"2018/04/20/小白科普：分布式和集群/","link":"","permalink":"https://www.itchina.top/2018/04/20/小白科普：分布式和集群/","excerpt":"","text":"分布式 小明的公司有3个系统： 系统A、系统B和系统C ，这三个系统所做的业务不同，被部署在3个独立的机器上运行， 他们之间互相调用（当然是跨域网络的），通力合作完成公司的业务流程。 将不同的业务分布在不同的地方， 这就构成了一个 分布式 的系统，现在问题来了， 系统A是整个分布式系统的“脸面”，用户直接访问，用户量访问大的时候要么是速度巨慢，要么直接挂掉， 怎么办？ 由于系统A只有一份， 所以会引起 单点失败 。 集群（Cluster） 小明的公司不差钱，就多买几台机器吧， 小明把系统A一下子部署了好几份（例如下图的3个服务器）， 每一份都是系统A的一个实例， 对外提供同样的服务，这样能睡个安稳觉了，不怕其中一个坏掉了，我还有另外2个呢。 这3个服务器上的系统就组成了一个 集群 。 可是对用户来说，一下子出现这么系统A ，每个系统的IP地址都不一样， 到底访问哪一个？ 如果所有人都访问服务器1.1 ，那服务器1.1 会被累死， 剩下的三个闲死，成了浪费钱的摆设。 3 负载均衡（Load Balancer） 小明要尽可能的让3个机器上的系统A 工作均衡一些， 比如有3万个请求，那就让3个服务器各处理1万个（当然，这是理想状况）， 这叫 负载均衡 。 很明显，这个 负载均衡 的工作最好独立出来， 放到独立的服务器上 （例如Ngnix）： 后来小明发现， 这个负载均衡的服务器虽然工作内容很简单，就是拿到请求，分发请求，但是它还是有可能挂掉啊， 单点失败 还是会出现。 没办法，只好把负载均衡也搞成一个集群， 不过和系统A的集群有两点不同： 1. 这个新的集群中虽然有两个机器，但我们可以用某种办法，让这个集群对外只提供一个IP地址， 也就是说 用户看到的好像只有一个机器 。 2. 同一时刻，我们只让一个负载均衡的机器工作， 另外一个原地待命 。 如果工作的那个挂掉了，待命的那个就顶上去。 4 弹性 如果这3个系统A的实例还是满足不了大量的请求，那就再加服务器！ 双11来了，用户量是平时的10倍， 小明向领导申请费用又买了几十台服务器，一下子把系统A部署了几十份。 可是双11过后，流量一下子降下来了，那几十个服务器用不上了，也变成了摆设！ 被领导批评以后，小明决定尝试一下云计算， 在云端可以轻松的创建、删除虚拟的服务器， 那样就可以轻松地随着用户的请求动态的增减服务器了。双11来了就创建虚拟服务器，等到双11过去了就把不用的关掉， 省得浪费钱。 于是小明的系统具备了一定的 弹性 。 5 失效转移 上面的系统看起来很美好，但是做了一个不切实际的假设： 所有的服务都是无状态的。 换句话说，假设用户的两次请求直接是没有关联的。 但是现实是，大部分服务都是有状态的， 例如购物车。 用户访问系统，在服务器1.1上创建了一个购物车，并向其中加入了几个商品， 然后 服务器1.1 挂掉了， 用户的后续访问就找不到服务器1.1了，这时候就要做失效转移 ，让另外几个服务器去接管、去处理用户的请求。 可是问题来了，在服务器1.2，1.3上有用户的购物车吗？ 如果没有， 用户就会抱怨，我刚创建的购物车哪里去了？ 还有更严重的，假设用户是在服务器1.1上登录的， 用户登录过的信息保存到了该服务器的session中， 现在这个服务器挂掉了，用户的session自然也不见了，当用户被失效转移到其他服务器上的时候，其他服务器发现用户没有登录， 就把用户踢到了登录界面， 让用户再次登录！ 状态， 状态，状态！ 用户的登录信息，购物车等都是状态信息， 处理不好状态的问题，集群的威力就大打折扣，无法完成真正的失效转移， 甚至无法使用。 怎么办？ 一种办法是把状态信息在集群的各个服务器之间复制，让集群的各个服务器达成一致， 谁来干这个事情？ 只能是像Websphere,Weblogic这样的应用服务器了。 还有一种办法， 就是把状态信息集中存储在一个地方， 让集群的各个服务器都能访问到： 小明听说Redis 不错， 那就用Redis来保存吧 ！","categories":[{"name":"集群","slug":"集群","permalink":"https://www.itchina.top/categories/集群/"}],"tags":[]},{"title":"项目相关的CVS操作","slug":"项目相关的CVS操作","date":"2018-04-19T16:34:21.467Z","updated":"2018-04-19T16:30:24.424Z","comments":true,"path":"2018/04/20/项目相关的CVS操作/","link":"","permalink":"https://www.itchina.top/2018/04/20/项目相关的CVS操作/","excerpt":"","text":"使用以下代码做成一个批处理文件，即可做到项目脱离CVS或切换CVS地址操作 1、项目脱离CVS @echo offecho Deleting CVS folders and files under: %1REM Open Folder specified by parameter.cd %1REM Recursive delete commandfor /f “tokens=“ %%i in (‘dir /b/a/s CVS‘) do @rmdir /q /s “%%i”echo Done! 2、更改项目cvs地址和切换用户 cd 项目根路径@echo offfor /f “delims=” %%i in (‘dir /s/b Root’) do (for /f “delims=” %%a in (‘type “%%~fi”‘) do (set “foo=%%a”call,set foo=%%foo::pserver:原CVS用户@原CVS地址:原CVS端口/原CVS路径=:pserver:替换后的CVS用户@替换后的CVS地址:替换后的端口/替换后的CVS路径%%call,echo/%%foo%%&gt;&gt;”%%~fi.“)move “%%~fi.“ “%%~fi”)exitw","categories":[{"name":"IDE","slug":"IDE","permalink":"https://www.itchina.top/categories/IDE/"}],"tags":[]},{"title":"图片转换PDF文件","slug":"图片转换PDF文件","date":"2018-04-19T16:34:21.449Z","updated":"2018-04-19T16:30:22.370Z","comments":true,"path":"2018/04/20/图片转换PDF文件/","link":"","permalink":"https://www.itchina.top/2018/04/20/图片转换PDF文件/","excerpt":"","text":"今天接到客户的需求，需要将一批TIF图片转换成PDF文件上传到海关和检验检疫局。废话不多说，直接上代码 import com.lowagie.text.Document; import com.lowagie.text.DocumentException; import com.lowagie.text.Image; import com.lowagie.text.Utilities; import com.lowagie.text.pdf.*; import com.lowagie.text.pdf.codec.TiffImage; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.net.URL; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.List; /** * Created by IntelliJ IDEA. * User: lerry.li * Date: 2016-09-18 * Time: 上午11:10 * To change this template use File | Settings | File Templates. */ public class ImageToPDFUtil { public static String convertJpgAndTif(List&lt;String&gt;oldPaths, String newPath){ // 创建一个文档对象 Document doc = new Document(); FileOutputStream fileOS = null; try { fileOS = new FileOutputStream(newPath); // 定义输出文件的位置 PdfWriter.getInstance(doc, fileOS); // 开启文档 doc.open(); for(String path : oldPaths){ addToDoc(doc, path); } } catch (FileNotFoundException e) { e.printStackTrace(); return e.getMessage(); } catch (DocumentException e) { e.printStackTrace(); return e.getMessage(); } catch (IOException e) { e.printStackTrace(); return e.getMessage(); } finally { if (doc != null) { doc.close(); } } return &quot;success&quot;; } public static String convertManyTiff(List&lt;String&gt;oldPaths, String newPath){ // 创建一个文档对象 Document doc = new Document(); try { // 定义输出文件的位置 PdfWriter.getInstance(doc, new FileOutputStream(newPath)); // 开启文档 doc.open(); Object localObject1 = null; Object localObject2 = null; Image localImage1 = null; for(String temp : oldPaths){ URL paramURL = Utilities.toURL(temp); try { if (paramURL.getProtocol().equals(&quot;file&quot;)) { localObject2 = paramURL.getFile(); localObject2 = Utilities .unEscapeURL((String) localObject2); localObject1 = new RandomAccessFileOrArray((String) localObject2); } else { localObject1 = new RandomAccessFileOrArray(paramURL); } int pageNums = TiffImage .getNumberOfPages((RandomAccessFileOrArray) localObject1); if (pageNums &gt; 0) { for (int i = 1; i &lt;= pageNums; i++) { localObject2 = TiffImage.getTiffImage( (RandomAccessFileOrArray) localObject1, i); Image jpg = (Image) localObject2; // 获得图片的高度 float heigth = jpg.getHeight(); float width = jpg.getWidth(); // 合理压缩，h&gt;w，按w压缩，否则按w压缩 int percent = getPercent(heigth, width); // 设置图片居中显示 jpg.setAlignment(Image.MIDDLE); // 按百分比显示图片的比例 if (width &gt; 1024 || heigth &gt; 786) { jpg.scalePercent(percent); } doc.add(jpg); } } if (localObject1 != null) ((RandomAccessFileOrArray) localObject1).close(); }catch (Exception ex){ ex.printStackTrace(); return ex.getMessage(); }finally { try{ if (localObject1 != null) ((RandomAccessFileOrArray) localObject1).close(); }catch (Exception ex){ ex.printStackTrace(); } } } } catch (FileNotFoundException e) { e.printStackTrace(); return e.getMessage(); } catch (DocumentException e) { e.printStackTrace(); return e.getMessage(); } catch (IOException e) { e.printStackTrace(); return e.getMessage(); } finally { if (doc != null) { try{ doc.close(); }catch (Exception ex){ ex.printStackTrace(); } } } return &quot;success&quot;; } public static boolean convert(String oldPath, String newPath) { // 创建一个文档对象 Document doc = new Document(); try { // 定义输出文件的位置 PdfWriter.getInstance(doc, new FileOutputStream(newPath)); // 开启文档 doc.open(); addToDoc(doc, oldPath); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (DocumentException e) { e.printStackTrace(); }catch (IOException e) { e.printStackTrace(); //To change body of catch statement use File | Settings | File Templates. } finally { if (doc != null) { doc.close(); } } return true; } //pdf文件合并 public static boolean mergePdfFiles(String[] files, String newfile) { boolean retValue = false; Document document = null; try { document = new Document(new PdfReader(files[0]).getPageSize(1)); PdfCopy copy = new PdfCopy(document, new FileOutputStream(newfile)); document.open(); for (int i = 0; i &lt; files.length; i++) { PdfReader reader = new PdfReader(files[i]); int n = reader.getNumberOfPages(); for (int j = 1; j &lt;= n; j++) { document.newPage(); PdfImportedPage page = copy.getImportedPage(reader, j); copy.addPage(page); } } retValue = true; } catch (Exception e) { e.printStackTrace(); } finally { document.close(); } return retValue; } private static void addToDoc(Document doc, String oldPath) throws IOException, DocumentException { // 创建一个文档对象 if (!oldPath.endsWith(&quot;.tif&quot;)) { Image jpg = Image.getInstance(oldPath); // 原来的图片的路径 // 获得图片的高度 float heigth = jpg.getHeight(); float width = jpg.getWidth(); // 合理压缩，h&gt;w，按w压缩，否则按w压缩 int percent = getPercent(heigth, width); // 设置图片居中显示 jpg.setAlignment(Image.MIDDLE); // 按百分比显示图片的比例 if (width &gt; 1024 || heigth &gt; 786) { jpg.scalePercent(percent); } doc.add(jpg); } else // tiff多页 { Object localObject1 = null; Object localObject2 = null; Image localImage1 = null; URL paramURL = Utilities.toURL(oldPath); try { if (paramURL.getProtocol().equals(&quot;file&quot;)) { localObject2 = paramURL.getFile(); localObject2 = Utilities .unEscapeURL((String) localObject2); localObject1 = new RandomAccessFileOrArray((String) localObject2); } else { localObject1 = new RandomAccessFileOrArray(paramURL); } int pageNums = TiffImage .getNumberOfPages((RandomAccessFileOrArray) localObject1); if (pageNums &gt; 0) { for (int i = 1; i &lt;= pageNums; i++) { localObject2 = TiffImage.getTiffImage( (RandomAccessFileOrArray) localObject1, i); Image jpg = (Image) localObject2; // 获得图片的高度 float heigth = jpg.getHeight(); float width = jpg.getWidth(); // 合理压缩，h&gt;w，按w压缩，否则按w压缩 int percent = getPercent(heigth, width); // 设置图片居中显示 jpg.setAlignment(Image.MIDDLE); // 按百分比显示图片的比例 if (width &gt; 1024 || heigth &gt; 786) { jpg.scalePercent(percent); } doc.add(jpg); } } if (localObject1 != null) ((RandomAccessFileOrArray) localObject1).close(); } finally { if (localObject1 != null) ((RandomAccessFileOrArray) localObject1).close(); } } } /** * 第一种解决方案 在不改变图片形状的同时，判断，如果h&gt;w，则按h压缩，否则在w&gt;h或w=h的情况下，按宽度压缩 * * @param h * @param w * @return */ public static int getPercent(float h, float w) { int p = 0; float p2 = 0.0f; if (h &gt; w) { p2 = 210 / h * 279; } else { p2 = 210 / w * 279; } p = Math.round(p2); return p; } /** * 第二种解决方案，统一按照宽度压缩 这样来的效果是，所有图片的宽度是相等的 * */ public static int getPercent2(float h, float w) { int p = 0; float p2 = 0.0f; p2 = 530 / w * 100; p = Math.round(p2); return p; } public static void main(String[] args) { List&lt;String&gt;list = new ArrayList&lt;String&gt;(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String dateStr = sdf.format(new Date()); String pdfPath = &quot;D:/jpg2pdf/&quot; + dateStr; File file = new File(pdfPath); if(!file.exists())file.mkdir(); pdfPath += &quot;/&quot; + &quot;document4.pdf&quot;; list.add(&quot;D:/jpg2pdf/359860201.TIF&quot;); list.add(&quot;D:/jpg2pdf/359860201_1.TIF&quot;); // convert(&quot;D:/jpg2pdf/359860201.TIF&quot;, &quot;D:/jpg2pdf/document4.pdf&quot;); convertManyTiff(list, pdfPath); } }","categories":[{"name":"J2EE","slug":"J2EE","permalink":"https://www.itchina.top/categories/J2EE/"}],"tags":[{"name":"ImageToPDF","slug":"ImageToPDF","permalink":"https://www.itchina.top/tags/ImageToPDF/"}]},{"title":"通过Ajax进行POST提交JSON类型的数据到SpringMVC Controller的方法","slug":"通过Ajax进行POST提交JSON类型的数据到SpringMVC Controller的方法","date":"2018-04-19T16:34:21.448Z","updated":"2018-04-19T16:30:03.772Z","comments":true,"path":"2018/04/20/通过Ajax进行POST提交JSON类型的数据到SpringMVC Controller的方法/","link":"","permalink":"https://www.itchina.top/2018/04/20/通过Ajax进行POST提交JSON类型的数据到SpringMVC Controller的方法/","excerpt":"","text":"现在在做的项目用到了SpringMVC框架，需要从前端angular接收请求的JSON数据，为了测试方便，所以直接先用AJAX进行测试，不过刚开始用平时用的ajax方法，提交请求会出现415或者400错误，经过研究，终于可以了，现在做个总结。 js代码： function postSimpleData() { $.ajax({ type: &quot;POST&quot;, url: &quot;Service/SimpleData&quot;, contentType: &quot;application/json&quot;, //必须有 dataType: &quot;json&quot;, //表示返回值类型，不必须 data: JSON.stringify({ &apos;foo&apos;: &apos;foovalue&apos;, &apos;bar&apos;: &apos;barvalue&apos; }), //相当于 //data: &quot;{&apos;str1&apos;:&apos;foovalue&apos;, &apos;str2&apos;:&apos;barvalue&apos;}&quot;, success: function (jsonResult) { alert(jsonResult); } }); } function login(){ $.ajax({ url: &quot;Service/login&quot;, type: &quot;POST&quot;, contentType: &quot;application/json&quot;, dataType: &quot;json&quot;, data: JSON.stringify({ MachineIP:&quot;127.0.0.1&quot;, AppTag:&quot;4&quot;, RequestInfo:{ StaffCode:&quot;&quot;, Password:&quot;&quot;, StaffCard:&quot;01411&quot; }, }), async: true, success: function(data) { var ss = JSON.stringify(data); $(&quot;#result&quot;).val(ss); console.log(ss); } }); } function postEmployees() { $.ajax({ type: &quot;POST&quot;, url: &quot;Service/Employees&quot;, contentType: &quot;application/json&quot;, dataType: &quot;json&quot;, data: JSON.stringify({ &quot;Employees&quot;: [ { &quot;firstName&quot;: &quot;Bill&quot;, &quot;lastName&quot;: &quot;Gates&quot; }, { &quot;firstName&quot;: &quot;George&quot;, &quot;lastName&quot;: &quot;Bush&quot; }, { &quot;firstName&quot;: &quot;Thomas&quot;, &quot;lastName&quot;: &quot;Carter&quot; } ] }), success: function (jsonResult) { alert(jsonResult); } }); } JAVA Controller代码： @RequestMapping(value = &quot;/SimpleData&quot;, method = RequestMethod.POST) @ResponseBody public ActionResult SimpleData(string foo, string bar) { return Json(&quot;SimpleData&quot;, JsonRequestBehavior.AllowGet); } @RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST) @ResponseBody public ResponseProtocolMap login(@RequestBody JSONObject requestJson, HttpServletRequest request) { ResponseProtocolMap responseProtocolMap = null; String machineIP = RequestJsonUtils.getMachineIP(requestJson); String appTag = RequestJsonUtils.getAppTag(requestJson); JSONObject requestInfo = RequestJsonUtils.getRequestInfo(requestJson); if (requestInfo == null) { responseProtocolMap = new ResponseProtocolMap(&quot;-1&quot;, &quot;参数错误&quot;); } else { String staffCode = RequestJsonUtils.getValueByKey(requestInfo, &quot;StaffCode&quot;); String password = RequestJsonUtils.getValueByKey(requestInfo, &quot;Password&quot;); String staffCard = RequestJsonUtils.getValueByKey(requestInfo, &quot;StaffCard&quot;); responseProtocolMap = sysLoginService.login(staffCode, password, staffCard, appTag, request); } return responseProtocolMap; } @RequestMapping(value = &quot;/Employees&quot;, method = RequestMethod.POST) @ResponseBody public ActionResult Employees(List&lt;Employee&gt; Employees) { return Json(&quot;Employees&quot;, JsonRequestBehavior.AllowGet); } public class Employee{ public string FirstName { get; set; } public string LastName { get; set; } } 值得注意的有2点： 1）Ajax 选项中 contentType: &quot;application/json&quot; 这一条必须写，表明request的数据类型是json。 而 dataType: &quot;json&quot; 这一条表示返回值的类型，不是必须的，且依据返回值类型而定。 2）选项中 data: JSON.stringify({ &apos;foo&apos;: &apos;foovalue&apos;, &apos;bar&apos;: &apos;barvalue&apos; }) 很多时候我们将数据写作： { &apos;foo&apos;: &apos;foovalue&apos;, &apos;bar&apos;: &apos;barvalue&apos; } 这样会导致错误，因为js会默认将这个json对象放到表单数据中，故而导致controller接收不到。 有两种办法处理：第一种方式是用JSON.stringify()函数，其中JSON被Ecmascript5定义为全局对象。 第二种方式是直接用双引号包裹起来，比如data: “{‘str1’:’foovalue’, ‘str2’:’barvalue’}”。","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://www.itchina.top/tags/ajax/"},{"name":"angular","slug":"angular","permalink":"https://www.itchina.top/tags/angular/"},{"name":"spring mvc","slug":"spring-mvc","permalink":"https://www.itchina.top/tags/spring-mvc/"}]},{"title":"使用 Spring Data JPA 简化 JPA 开发","slug":"使用 Spring Data JPA 简化 JPA 开发","date":"2018-04-19T16:34:21.448Z","updated":"2018-04-19T16:30:30.712Z","comments":true,"path":"2018/04/20/使用 Spring Data JPA 简化 JPA 开发/","link":"","permalink":"https://www.itchina.top/2018/04/20/使用 Spring Data JPA 简化 JPA 开发/","excerpt":"","text":"_ Spring Data JPA 开发指南 _ 本文由浅入深地讲述了使用 Spring Data JPA 需要关注的各个方面，为读者了解和使用该框架提供了指导，可以作为 Spring Data JPA的学习指南。 从一个简单的 JPA 示例开始本文主要讲述 Spring Data JPA，但是为了不至于给 JPA 和 Spring 的初学者造成较大的学习曲线，我们首先从 JPA 开始，简单介绍一个JPA 示例；接着重构该示例，并引入 Spring 框架，这两部分不会涉及过多的篇幅，如果希望能够深入学习 Spring 和JPA，可以根据本文最后提供的参考资料进一步学习。 自 JPA 伴随 Java EE 5 发布以来，受到了各大厂商及开源社区的追捧，各种商用的和开源的 JPA框架如雨后春笋般出现，为开发者提供了丰富的选择。它一改之前 EJB 2.x 中实体 Bean 笨重且难以使用的形象，充分吸收了在开源社区已经相对成熟的ORM 思想。另外，它并不依赖于 EJB 容器，可以作为一个独立的持久层技术而存在。目前比较成熟的 JPA 框架主要包括 Jboss 的 HibernateEntityManager、Oracle 捐献给 Eclipse 社区的 EclipseLink、Apache 的 OpenJPA 等。 本 文的示例代码基于 Hibernate EntityManager 开发，但是读者几乎不用修改任何代码，便可以非常容易地切换到其他 JPA框架，因为代码中使用到的都是 JPA 规范提供的接口 /类，并没有使用到框架本身的私有特性。示例主要涉及七个文件，但是很清晰：业务层包含一个接口和一个实现；持久层包含一个接口、一个实现、一个实体类；另 外加上一个JPA 配置文件和一个测试类。相关类 / 接口代码如下： 清单 1. 实体类 AccountInfo.java1 @Entity 2 @Table(name = &quot;t_accountinfo&quot;) 3 public class AccountInfo implements Serializable { 4 private Long accountId; 5 private Integer balance; 6 7 // 此处省略 getter 和 setter 方法。 8 } 清单 2. 业务层接口 UserService.java1 public interface UserService { 2 public AccountInfo createNewAccount(String user, String pwd, Integer init); 3 } 清单 3. 业务层的实现类 UserServiceImpl.java 1 public class UserServiceImpl implements UserService { 2 3 private UserDao userDao = new UserDaoImpl(); 4 5 public AccountInfo createNewAccount(String user, String pwd, Integer init){ 6 // 封装域对象 7 AccountInfo accountInfo = new AccountInfo(); 8 UserInfo userInfo = new UserInfo(); 9 userInfo.setUsername(username); 10 userInfo.setPassword(password); 11 accountInfo.setBalance(initBalance); 12 accountInfo.setUserInfo(userInfo); 13 // 调用持久层，完成数据的保存 14 return userDao.save(accountInfo); 15 } 16 } 清单 4. 持久层接口1 public interface UserDao { 2 public AccountInfo save(AccountInfo accountInfo); 3 } 清单 5. 持久层的实现类 1 public class UserDaoImpl implements UserDao { 2 public AccountInfo save(AccountInfo accountInfo) { 3 EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;SimplePU&quot;); 4 EntityManager em = emf.createEntityManager(); 5 em.getTransaction().begin(); 6 em.persist(accountInfo); 7 em.getTransaction().commit(); 8 emf.close(); 9 return accountInfo; 10 } 11 } 清单 6. JPA 标准配置文件 persistence.xml 1 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 2 &lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;2.0&quot;&gt; 3 &lt;persistence-unit name=&quot;SimplePU&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; 4 &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt; 5 &lt;class&gt;footmark.springdata.jpa.domain.UserInfo&lt;/class&gt; 6 &lt;class&gt;footmark.springdata.jpa.domain.AccountInfo&lt;/class&gt; 7 &lt;properties&gt; 8 &lt;property name=&quot;hibernate.connection.driver_class&quot; 9 value=&quot;com.mysql.jdbc.Driver&quot;/&gt; 10 &lt;property name=&quot;hibernate.connection.url&quot; 11 value=&quot;jdbc:mysql://10.40.74.197:3306/zhangjp&quot;/&gt; 12 &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&gt; 13 &lt;property name=&quot;hibernate.connection.password&quot; value=&quot;root&quot;/&gt; 14 &lt;property name=&quot;hibernate.dialect&quot; 15 value=&quot;org.hibernate.dialect.MySQL5Dialect&quot;/&gt; 16 &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; 17 &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; 18 &lt;property name=&quot;hibernate.use_sql_comments&quot; value=&quot;false&quot;/&gt; 19 &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt; 20 &lt;/properties&gt; 21 &lt;/persistence-unit&gt; 22 &lt;/persistence&gt; 清单 7. 本文使用如下的 main 方法进行开发者测试1 public class SimpleSpringJpaDemo { 2 public static void main(String[] args) { 3 new UserServiceImpl().createNewAccount(&quot;ZhangJianPing&quot;, &quot;123456&quot;, 1); 4 } 5 } 简述 Spring 框架对 JPA 的支持接下来我们引入 Spring，以展示 Spring 框架对 JPA 的支持。业务层接口 UserService 保持不变，UserServiceImpl中增加了三个注解，以让 Spring 完成依赖注入，因此不再需要使用 new 操作符创建 UserDaoImpl 对象了。同时我们还使用了 Spring的声明式事务： 清单 8. 配置为 Spring Bean 的业务层实现1 @Service(&quot;userService&quot;) 2 public class UserServiceImpl implements UserService { 3 @Autowired 4 private UserDao userDao; 5 6 @Transactional 7 public AccountInfo createNewAccount( 8 String name, String pwd, Integer init) { …… } 9 } 对于持久层，UserDao 接口也不需要修改，只需修改 UserDaoImpl 实现，修改后的代码如下： 清单 9. 配置为 Spring Bean 的持久层实现 1 @Repository(&quot;userDao&quot;) 2 public class UserDaoImpl implements UserDao { 3 4 @PersistenceContext 5 private EntityManager em; 6 7 @Transactional 8 public Long save(AccountInfo accountInfo) { 9 em.persist(accountInfo); 10 return accountInfo.getAccountId(); 11 } 12 } 清单 10. Spring 配置文件 1 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 2 &lt;beans...&gt; 3 &lt;context:component-scan base-package=&quot;footmark.springdata.jpa&quot;/&gt; 4 &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 5 &lt;bean id=&quot;transactionManager&quot; 6 class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt; 7 &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt; 8 &lt;/bean&gt; 9 &lt;bean id=&quot;entityManagerFactory&quot; class= 10 &quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt; 11 &lt;/bean&gt; 12 &lt;/beans&gt; 清单 11. 改造后的基于 Spring 的开发者测试代码1 public class SimpleSpringJpaDemo{ 2 public static void main(String[] args){ 3 ClassPathXmlApplicationContext ctx = 4 new ClassPathXmlApplicationContext(&quot;spring-demo-cfg.xml&quot;); 5 UserDao userDao = ctx.getBean(&quot;userDao&quot;, UserDao.class); 6 userDao.createNewAccount(&quot;ZhangJianPing&quot;, &quot;123456&quot;, 1); 7 } 8 } 通过对比重构前后的代码，可以发现 Spring 对 JPA 的简化已经非常出色了，我们可以大致总结一下 Spring 框架对 JPA提供的支持主要体现在如下几个方面： 首先，它使得 JPA 配置变得更加灵活。JPA 规范要求，配置文件必须命名为 persistence.xml，并存在于类路径下的 META-INF 目录中。该文件通常包含了初始化 JPA 引擎所需的全部信息。Spring 提供的 LocalContainerEntityManagerFactoryBean 提供了非常灵活的配置，persistence.xml 中的信息都可以在此以属性注入的方式提供。 其次，Spring 实现了部分在 EJB 容器环境下才具有的功能，比如对 @PersistenceContext、@PersistenceUnit 的容器注入支持。 第三，也是最具意义的，Spring 将 EntityManager 的创建与销毁、事务管理等代码抽取出来，并由其统一管理，开发者不需要关心这些，如前面的代码所示，业务方法中只剩下操作领域对象的代码，事务管理和 EntityManager 创建、销毁的代码都不再需要开发者关心了。 更进一步：Spring Data JPA 让一切近乎完美通过前面的分析可以看出，Spring 对 JPA 的支持已经非常强大，开发者只需关心核心业务逻辑的实现代码，无需过多关注 EntityManager的创建、事务处理等 JPA 相关的处理，这基本上也是作为一个开发框架而言所能做到的极限了。然而，Spring 开发小组并没有止步，他们再接再厉，于最近推出了Spring Data JPA 框架，主要针对的就是 Spring唯一没有简化到的业务逻辑代码，至此，开发者连仅剩的实现持久层业务逻辑的工作都省了，唯一要做的，就只是声明持久层的接口，其他都交给 Spring DataJPA 来帮你完成！ 至此，读者可能会存在一个疑问，框架怎么可能代替开发者实现业务逻辑呢？毕竟，每一个应用的持久层业务甚至领域对象都不尽相同，框架是怎么做到的呢？其实这背后的思想并不复杂，比如，当你看到 UserDao.findUserById()这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象。Spring Data JPA做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。 接下来我们针对前面的例子进行改造，让 Spring Data JPA 来帮助我们完成业务逻辑。在着手写代码之前，开发者需要先 下载 Spring Data JPA 的发布包（需要同时下载 Spring Data Commons 和Spring Data JPA 两个发布包，Commons 是 Spring Data 的公共基础包），并把相关的依赖 JAR 文件加入到CLASSPATH 中。 首先，让持久层接口 UserDao 继承 Repository接口。该接口使用了泛型，需要为其提供两个类型：第一个为该接口处理的域对象类型，第二个为该域对象的主键类型。修改后的 UserDao 如下： 清单 12. Spring Data JPA 风格的持久层接口public interface UserDao extends Repository&lt;AccountInfo, Long&gt; { public AccountInfo save(AccountInfo accountInfo); } 然后删除 UserDaoImpl 类，因为我们前面说过，框架会为我们完成业务逻辑。最后，我们需要在 Spring 配置文件中增加如下配置，以使 Spring识别出需要为其实现的持久层接口： 清单 13. 在 Spring 配置文件中启用扫描并自动创建代理的功能&lt;-- 需要在 &lt;beans&gt; 标签中增加对 jpa 命名空间的引用 --&gt; &lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot; entity-manager-factory-ref=&quot;entityManagerFactory&quot; transaction-manager-ref=&quot;transactionManager&quot;/&gt; 至此便大功告成了！执行一下测试代码，然后看一下数据库，新的数据已经如我们预期的添加到表中了。如果要再增加新的持久层业务，比如希望查询出给 ID 的AccountInfo 对象，该怎么办呢？很简单，在 UserDao 接口中增加一行代码即可： 清单 14. 修改后的持久层接口，增加一个方法声明1 public interface UserDao extends Repository&lt;AccountInfo, Long&gt; { 2 3 public AccountInfo save(AccountInfo accountInfo); 4 5 // 你需要做的，仅仅是新增如下一行方法声明 6 public AccountInfo findByAccountId(Long accountId); 7 } 下面总结一下使用 Spring Data JPA 进行持久层开发大致需要的三个步骤： 声明持久层的接口，该接口继承 Repository，Repository 是一个标记型接口，它不包含任何方法，当然如果有需要，Spring Data 也提供了若干 Repository 子接口，其中定义了一些常用的增删改查，以及分页相关的方法。 在接口中声明需要的业务方法。Spring Data 将根据给定的策略（具体策略稍后讲解）来为其生成实现代码。 在 Spring 配置文件中增加一行声明，让 Spring 为声明的接口创建代理对象。配置了 jpa:repositories 后，Spring 初始化容器时将会扫描 base-package 指定的包目录及其子目录，为继承 Repository 或其子接口的接口创建代理对象，并将代理对象注册为 Spring Bean，业务层便可以通过 Spring 自动封装的特性来直接使用该对象。 此 外，jpa:repository 还提供了一些属性和子标签，便于做更细粒度的控制。可以在 jpa:repository 内部使用context:include-filter、context:exclude-filter 来过滤掉一些不希望被扫描到的接口。具体的使用方法见 Spring 参考文档 。 应该继承哪个接口？前 面提到，持久层接口继承 Repository 并不是唯一选择。Repository 接口是 Spring Data的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法。与继承 Repository 等价的一种方式，就是在持久层接口上使用@RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性。如下两种方式是完全等价的： 清单 15. 两种等价的继承接口方式示例1 public interface UserDao extends Repository&lt;AccountInfo, Long&gt; { …… } 2 3 @RepositoryDefinition(domainClass = AccountInfo.class, idClass = Long.class) 4 public interface UserDao { …… } 如果持久层接口较多，且每一个接口都需要声明相似的增删改查方法，直接继承 Repository 就显得有些啰嗦，这时可以继承CrudRepository，它会自动为域对象创建增删改查方法，供业务层直接使用。开发者只是多写了 “Crud”四个字母，即刻便为域对象提供了开箱即用的十个增删改查方法。 但是，使用 CrudRepository也有副作用，它可能暴露了你不希望暴露给业务层的方法。比如某些接口你只希望提供增加的操作而不希望提供删除的方法。针对这种情况，开发者只能退回到Repository 接口，然后到 CrudRepository 中把希望保留的方法声明复制到自定义的接口中即可。 分页查询和排序是 持久层常用的功能，Spring Data 为此提供了 PagingAndSortingRepository 接口，它继承自CrudRepository 接口，在 CrudRepository 基础上新增了两个与分页有关的方法。但是，我们很少会将自定义的持久层接口直接继承自PagingAndSortingRepository，而是在继承 Repository 或 CrudRepository的基础上，在自己声明的方法参数列表最后增加一个 Pageable 或 Sort 类型的参数，用于指定分页或排序信息即可，这比直接使用PagingAndSortingRepository 提供了更大的灵活性。 JpaRepository 是继承自 PagingAndSortingRepository 的针对 JPA技术提供的接口，它在父接口的基础上，提供了其他一些方法，比如 flush()，saveAndFlush()，deleteInBatch()等。如果有这样的需求，则可以继承该接口。 上述四个接 口，开发者到底该如何选择？其实依据很简单，根据具体的业务需求，选择其中之一。笔者建议在通常情况下优先选择 Repository 接口。因为Repository 接口已经能满足日常需求，其他接口能做到的在 Repository 中也能做到，彼此之间并不存在功能强弱的问题。只是Repository 需要显示声明需要的方法，而其他则可能已经提供了相关的方法，不需要再显式声明，但如果对 Spring Data JPA不熟悉，别人在检视代码或者接手相关代码时会有疑惑，他们不明白为什么明明在持久层接口中声明了三个方法，而在业务层使用该接口时，却发现有七八个方法可用，从这个角度而言，应该优先考虑使用 Repository 接口。 前面提到，Spring Data JPA在后台为持久层接口创建代理对象时，会解析方法名字，并实现相应的功能。除了通过方法名字以外，它还可以通过如下两种方式指定查询语句： Spring Data JPA 可以访问 JPA 命名查询语句。开发者只需要在定义命名查询语句时，为其指定一个符合给定格式的名字，Spring Data JPA 便会在创建代理对象时，使用该命名查询语句来实现其功能。 开发者还可以直接在声明的方法上面使用 @Query 注解，并提供一个查询语句作为参数，Spring Data JPA 在创建代理对象时，便以提供的查询语句来实现其功能。 下面我们分别讲述三种创建查询的方式。 通过解析方法名创建查询通 过前面的例子，读者基本上对解析方法名创建查询的方式有了一个大致的了解，这也是 Spring Data JPA吸引开发者的一个很重要的因素。该功能其实并非 Spring Data JPA 首创，而是源自一个开源的 JPA 框架 Hades，该框架的作者 OliverGierke 本身又是 Spring Data JPA 项目的 Leader，所以把 Hades 的优势引入到 Spring Data JPA也就是顺理成章的了。 框架在进行方法名解析时，会先把方法名多余的前缀截取掉，比如find、findBy、read、readBy、get、getBy，然后对剩下部分进行解析。并且如果方法的最后一个参数是 Sort 或者 Pageable类型，也会提取相关的信息，以便按规则进行排序或者分页查询。 在创建查询时，我们通过在方法名中使用属性名称来表达，比如 findByUserAddressZip ()。框架在解析该方法时，首先剔除findBy，然后对剩下的属性进行解析，详细规则如下（此处假设该方法针对的域对象为 AccountInfo 类型）： 先判断 userAddressZip （根据 POJO 规范，首字母变为小写，下同）是否为 AccountInfo 的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步； 从右往左截取第一个大写字母开头的字符串（此处为 Zip），然后检查剩下的字符串是否为 AccountInfo 的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设 user 为 AccountInfo 的一个属性； 接着处理剩下部分（ AddressZip ），先判断 user 所对应的类型是否有 addressZip 属性，如果有，则表示该方法最终是根据 “AccountInfo.user.addressZip” 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 “AccountInfo.user.address.zip” 的值进行查询。 可能会存在一种特殊情况，比如 AccountInfo 包含一个 user 的属性，也有一个 userAddress属性，此时会存在混淆。读者可以明确在属性之间加上 “_” 以显式表达意图，比如 “findByUser_AddressZip()” 或者“findByUserAddress_Zip()”。 在查询时，通常需要同时根据多个属性进行查询，且查询的条件也格式各样（大于某个值、在某个范围等等），Spring Data JPA为此提供了一些表达条件查询的关键字，大致如下： And — 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)； Or — 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)； Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)； LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)； GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)； IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()； IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()； NotNull — 与 IsNotNull 等价； Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)； NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)； OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)； Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)； In — 等价于 SQL 中的 “in”，比如 findByUsernameIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数； NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数； 使用 @Query 创建查询@Query 注解的使用非常简单，只需在声明的方法上面标注该注解，同时提供一个 JP QL 查询语句即可，如下所示： 清单 16. 使用 @Query 提供自定义查询语句示例1 public interface UserDao extends Repository&lt;AccountInfo, Long&gt; { 2 3 @Query(&quot;select a from AccountInfo a where a.accountId = ?1&quot;) 4 public AccountInfo findByAccountId(Long accountId); 5 6 @Query(&quot;select a from AccountInfo a where a.balance &gt; ?1&quot;) 7 public Page&lt;AccountInfo&gt; findByBalanceGreaterThan( 8 Integer balance,Pageable pageable); 9 } 很多开发者在创建 JP QL 时喜欢使用命名参数来代替位置编号，@Query 也对此提供了支持。JP QL 语句中通过”:变量”的格式来指定参数，同时在方法的参数前面使用 @Param 将方法参数与 JP QL 中的命名参数对应，示例如下： 清单 17. @Query 支持命名参数示例 1 public interface UserDao extends Repository&lt;AccountInfo, Long&gt; { 2 3 public AccountInfo save(AccountInfo accountInfo); 4 5 @Query(&quot;from AccountInfo a where a.accountId = :id&quot;) 6 public AccountInfo findByAccountId(@Param(&quot;id&quot;)Long accountId); 7 8 @Query(&quot;from AccountInfo a where a.balance &gt; :balance&quot;) 9 public Page&lt;AccountInfo&gt; findByBalanceGreaterThan( 10 @Param(&quot;balance&quot;)Integer balance,Pageable pageable); 11 } 此外，开发者也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询。如下所示： 清单 18. 使用 @Modifying 将查询标识为修改查询1 @Modifying 2 @Query(&quot;update AccountInfo a set a.salary = ?1 where a.salary &lt; ?2&quot;) 3 public int increaseSalary(int after, int before); 通过调用 JPA 命名查询语句创建查询命名查询是 JPA 提供的一种将查询语句从方法体中独立出来，以供多个方法共用的功能。Spring Data JPA对命名查询也提供了很好的支持。用户只需要按照 JPA 规范在 orm.xml 文件或者在代码中使用 @NamedQuery（或@NamedNativeQuery）定义好查询语句，唯一要做的就是为该语句命名时，需要满足”DomainClass.methodName()”的命名规则。假设定义了如下接口： 清单 19. 使用 JPA 命名查询时，声明接口及方法时不需要什么特殊处理1 public interface UserDao extends Repository&lt;AccountInfo, Long&gt; { 2 3 ...... 4 5 public List&lt;AccountInfo&gt; findTop5(); 6 } 如果希望为 findTop5() 创建命名查询，并与之关联，我们只需要在适当的位置定义命名查询语句，并将其命名为“AccountInfo.findTop5”，框架在创建代理类的过程中，解析到该方法时，优先查找名为 “AccountInfo.findTop5”的命名查询定义，如果没有找到，则尝试解析方法名，根据方法名字创建查询。 创建查询的顺序Spring Data JPA 在为接口创建代理对象时，如果发现同时存在多种上述情况可用，它该优先采用哪种策略呢？为此，jpa:repositories提供了 query-lookup-strategy 属性，用以指定查找的顺序。它有如下三个取值： create — 通过解析方法名字来创建查询。即使有符合的命名查询，或者方法通过 @Query 指定的查询语句，都将会被忽略。 create-if-not-found — 如果方法通过 @Query 指定了查询语句，则使用该语句实现查询；如果没有，则查找是否定义了符合条件的命名查询，如果找到，则使用该命名查询；如果两者都没有找到，则通过解析方 法名字来创建查询。这是 query-lookup-strategy 属性的默认值。 use-declared-query — 如果方法通过 @Query 指定了查询语句，则使用该语句实现查询；如果没有，则查找是否定义了符合条件的命名查询，如果找到，则使用该命名查询；如果两者都没有找到，则抛出异常。 Spring Data JPA 对事务的支持默 认情况下，Spring Data JPA 实现的方法都是使用事务的。针对查询类型的方法，其等价于@Transactional(readOnly=true)；增删改类型的方法，等价于@Transactional。可以看出，除了将查询的方法设为只读事务外，其他事务属性均采用默认值。 如果用户觉得有必要，可以在接口方 法上使用 @Transactional 显式指定事务属性，该值覆盖 Spring Data JPA提供的默认值。同时，开发者也可以在业务层方法上使用 @Transactional指定事务属性，这主要针对一个业务层方法多次调用持久层方法的情况。持久层的事务会根据设置的事务传播行为来决定是挂起业务层事务还是加入业务层的事务。 具体@Transactional 的使用，请参考 Spring 的参考文档 。 为接口中的部分方法提供自定义实现有些时候，开发者可能需要在某些方法中做一些特殊的处理，此时自动生成的代理对象不能完全满足要求。为了享受 Spring Data JPA带给我们的便利，同时又能够为部分方法提供自定义实现，我们可以采用如下的方法： 将需要开发者手动实现的方法从持久层接口（假设为 AccountDao ）中抽取出来，独立成一个新的接口（假设为 AccountDaoPlus ），并让 AccountDao 继承 AccountDaoPlus； 为 AccountDaoPlus 提供自定义实现（假设为 AccountDaoPlusImpl ）； 将 AccountDaoPlusImpl 配置为 Spring Bean； 在 jpa:repositories 中按清单 19 的方式进行配置。 清单 20. 指定自定义实现类&lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot;&gt; &lt;jpa:repository id=&quot;accountDao&quot; repository-impl-ref=&quot; accountDaoPlus &quot; /&gt; &lt;/jpa:repositories&gt; &lt;bean id=&quot;accountDaoPlus&quot; class=&quot;.......&quot;/&gt; 此外，&lt;jpa:repositories &gt; 提供了一个 repository-impl-postfix 属性，用以指定实现类的后缀。假设做了如下配置： 清单 21. 设置自动查找时默认的自定义实现类命名规则1 &lt;jpa:repositories base-package=&quot;footmark.springdata.jpa.dao&quot; 2 repository-impl-postfix=&quot;Impl&quot;/&gt; 则在框架扫描到 AccountDao 接口时，它将尝试在相同的包目录下查找AccountDaoImpl.java，如果找到，便将其中的实现方法作为最终生成的代理类中相应方法的实现。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[]},{"title":"面试感悟----一名3年工作经验的程序员应该具备的技能","slug":"面试感悟----一名3年工作经验的程序员应该具备的技能","date":"2018-04-19T16:34:21.447Z","updated":"2018-04-19T16:29:56.532Z","comments":true,"path":"2018/04/20/面试感悟----一名3年工作经验的程序员应该具备的技能/","link":"","permalink":"https://www.itchina.top/2018/04/20/面试感悟----一名3年工作经验的程序员应该具备的技能/","excerpt":"","text":"由于lz最近也准备换一个工作了，所以在网上看到了这一片文章，觉得挺好就转出来分享给大家。 原文地址http://www.cnblogs.com/xrq730/p/5260294.html，转载请注明出处，谢谢！ 前言 因为和同事有约定再加上LZ自己也喜欢做完一件事之后进行总结，因此有了这篇文章。这篇文章大部分内容都是面向整个程序员群体的，当然因为LZ本身是做Java开发的，因此有一部分内容也是专门面向咱们Java程序员的。 简单先说一下，LZ坐标杭州，13届本科毕业，算上年前在阿里巴巴B2B事业部的面试，一共有面试了有6家公司（因为LZ不想请假，因此只是每个晚上去其他公司面试，所以面试的公司比较少），其中成功的有4家，另外两家失败的原因在于： 1、阿里巴巴B2B事业部的面试，两轮技术面试都过了，最后一轮面试是对方的主管，由于听说技术面试过了基本上90%都面试成功了，所以LZ在和主管的交谈中也是毫无顾忌，说得天花乱坠，很多自己介于知道和不知道的东西都直接脱口而出了，结果多次被对方一反问就问得哑口无言。事后想来，模棱两可的答案是面试中最忌讳的，这次的失败也让LZ认真地对待后面的每一次面试 2、另外一家失败的是一家小公司，也就20来个人吧，整个团队是支付宝出来创业的，非常厉害。面试完LZ多方了解了一下，对方认为我基本功什么的都不错，但是实际项目经验还是欠缺一些，因为对方是创业型公司，需要人上手就能干活，因此我在这个时候还不是特别适合他们团队 至于其他成功的四家公司，给LZ的面试评价都挺高的貌似，但LZ也不想记流水账，因此就不一一列举每家公司的面试过程了，下面LZ主要谈谈作为一名工作三年左右的Java程序员应该具备的一些技能以及个人的一些其他感悟。 关于程序员的几个阶段 每个程序员、或者说每个工作者都应该有自己的职业规划，如果看到这里的朋友没有自己的职业规划，希望你可以思考一下自己的将来。 LZ常常思考自己的未来，也从自己的思考中总结出了一些东西，作为第一部分来谈谈。LZ认为一名程序员应该有几个阶段（以下时间都算上实习期）： 第一阶段—-三年 我认为三年对于程序员来说是第一个门槛，这个阶段将会淘汰掉一批不适合写代码的人。这一阶段，我们走出校园，迈入社会，成为一名程序员，正式从书本上的内容迈向真正的企业级开发。我们知道如何团队协作、如何使用项目管理工具、项目版本如何控制、我们写的代码如何测试如何在线上运行等等，积累了一定的开发经验，也对代码有了一定深入的认识，是一个比较纯粹的Coder的阶段 第二阶段—-五年 五年又是区分程序员的第二个门槛。有些人在三年里，除了完成工作，在空余时间基本不会研究别的东西，这些人永远就是个Coder，年纪大一些势必被更年轻的人给顶替；有些人在三年里，除了写代码之外，还热衷于研究各种技术实现细节、看了N多好书、写一些博客、在Github上分享技术，这些人在五年后必然具备在技术上独当一面的能力并且清楚自己未来的发展方向，从一个Coder逐步走向系统分析师或是架构师，成为项目组中不可或缺的人物 第三阶段—-十年 十年又是另一个门槛了，转行或是继续做一名程序员就在这个节点上。如果在前几年就抱定不转行的思路并且为之努力的话，那么在十年的这个节点上，有些人必然成长为一名对行业有着深入认识、对技术有着深入认识、能从零开始对一个产品进行分析的程序员，这样的人在公司基本担任的都是CTO、技术专家、首席架构师等最关键的职位，这对于自己绝对是一件荣耀的事，当然老板在经济上也绝不会亏待你 第一部分总结一下，我认为，随着你工作年限的增长、对生活对生命认识的深入，应当不断思考三个问题： 我到底适不适合当一名程序员？ 我到底应不应该一辈子以程序员为职业？ 我对编程到底持有的是一种什么样的态度，是够用就好呢还是不断研究？ 最终，明确自己的职业规划，对自己的规划负责并为之努力。 关于项目经验 LZ在网上经常看到一些别的朋友有提出项目经验的问题，依照LZ面试的感觉来说，面试主要看几点： 项目经验+基本技术+个人潜力 （也就是值不值得培养）。 关于项目经验，我认为并发编程网的创始人方腾飞老师讲的一段话非常好： 介绍产品时面试官会考察应聘者的沟通能力和思考能力，我们大部分情况都是做产品的一个功能或一个模块，但是即使是这样，自己有没有把整个系统架构或产品搞清楚，并能介绍清楚，为什么做这个系统？这个系统的价值是什么？这个系统有哪些功能？优缺点有哪些？如果让你重新设计这个系统你会如何设计？ 我觉得这就已经足以概括了。也许你仅仅工作一年，也许你做的是项目中微不足道的模块，当然这些一定是你的劣势且无法改变，但是如何弥补这个劣势，从方老师的话中我总结几点： 明确你的项目到底是做什么的，有哪些功能 明确你的项目的整体架构，在面试的时候能够清楚地画给面试官看并且清楚地指出从哪里调用到哪里、使用什么方式调用 明确你的模块在整个项目中所处的位置及作用 明确你的模块用到了哪些技术，更好一些的可以再了解一下整个项目用到了哪些技术 在你无法改变自己的工作年限、自己的不那么有说服力的项目经验的情况下（这一定是扣分项），可以通过这种方式来一定程度上地弥补并且增进面试官对你的好感度。 补充一点，在面试中聊你的项目的时候，有一个问题90%是绕不过的： 谈一下你在项目中解决过的比较复杂的问题 。这需要在工作中不断去发现和探索，不需要多，在你自己目前的项目中只要你找到一两个能说的问题就行。一个小技巧是，即使问题不是你解决的而是别人解决的，但是你把这个问题弄懂、搞透了，在面试的时候你一样可以把这个问题当作是你自己解决的来说—-毕竟，谁来管这个问题当时到底是不是你解决的呢？ 关于专业技能 写完项目接着写写一名3年工作经验的Java程序员应该具备的技能，这可能是Java程序员们比较关心的内容。我这里要说明一下，以下列举的内容不是都要会的东西—-但是如果你掌握得越多，最终能得到的评价、拿到的薪水势必也越高。 1、基本语法 这包括static、final、transient等关键字的作用，foreach循环的原理等等。今天面试我问你static关键字有哪些作用，如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，因为能看出你非常热衷研究技术。 最深入的一次，LZ记得面试官直接问到了我volatile关键字的底层实现原理（顺便插一句，面试和被面试本身就是相对的，面试官能问这个问题同时也让面试者感觉到面试官也是一个喜爱研究技术的人，增加了面试者对公司的好感，LZ最终选择的就是问了这个问题的公司），不要觉得这太吹毛求疵了—-越简单的问题越能看出一个人的水平，别人对你技术的考量绝大多数都是以 深度 优先、广度次之 为标准的，切记。 2、集合 非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。 集合要掌握的是ArrayList、LinkedList、Hashtable、HashMap、ConcurrentHashMap、HashSet的实现原理，能流利作答，当然能掌握CopyOnWrite容器和Queue是再好不过的了。另外多说一句，ConcurrentHashMap的问题在面试中问得特别多，大概是因为这个类可以衍生出非常多的问题，关于ConcurrentHashMap，我给网友朋友们提供三点回答或者是研究方向： （1）ConcurrentHashMap的锁分段技术 （2）ConcurrentHashMap的读是否要加锁，为什么 （3）ConcurrentHashMap的迭代器是强一致性的迭代器还是弱一致性的迭代器 3、设计模式 本来以为蛮重要的一块内容，结果只在阿里巴巴B2B事业部面试的时候被问了一次，当时问的是装饰器模式。 当然咱们不能这么功利，为了面试而学习，设计模式在工作中还是非常重要、非常有用的，23种设计模式中重点研究常用的十来种就可以了，面试中关于设计模式的问答主要是三个方向： （1）你的项目中用到了哪些设计模式，如何使用 （2）知道常用设计模式的优缺点 （3）能画出常用设计模式的UML图 4、多线程 这也是必问的一块了。因为三年工作经验，所以基本上不会再问你怎么实现多线程了，会问得深入一些比如说Thread和Runnable的区别和联系、多次start一个线程会怎么样、线程有哪些状态。当然这只是最基本的，出乎意料地，几次面试几乎都被同时问到了一个问题，问法不尽相同，总结起来是这么一个意思： 假如有Thread1、Thread2、Thread3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？ 聪明的网友们对这个问题是否有答案呢？不难，java.util.concurrent下就有现成的类可以使用。 另外，线程池也是比较常问的一块，常用的线程池有几种？这几种线程池之间有什么区别和联系？线程池的实现原理是怎么样的？实际一些的，会给你一些具体的场景，让你回答这种场景该使用什么样的线程池比较合适。 最后，虽然这次面试问得不多，但是多线程同步、锁这块也是重点。synchronized和ReentrantLock的区别、synchronized锁普通方法和锁静态方法、死锁的原理及排查方法等等，关于多线程，我在之前有些过文章总结过多线程的40个问题，可以参看 40个Java多线程问题总结 。 5、IO 再次补充IO的内容，之前忘了写了。 IO分为File IO和Socket IO，File IO基本上是不会问的，问也问不出什么来，平时会用就好了，另外记得File IO都是阻塞IO。 SocketIO是比较重要的一块，要搞懂的是阻塞/非阻塞的区别、同步/异步的区别，借此理解阻塞IO、非阻塞IO、多路复用IO、异步IO这四种IO模型，Socket IO如何和这四种模型相关联。这是基本一些的，深入一些的话，就会问NIO的原理、NIO属于哪种IO模型、NIO的三大组成等等，这有些难，当时我也是研究了很久才搞懂NIO。提一句， NIO并不是严格意义上的非阻塞IO而应该属于多路复用IO ，面试回答的时候要注意这个细节，讲到NIO会阻塞在Selector的select方法上会增加面试官对你的好感。 如果用过Netty，可能会问一些Netty的东西，毕竟这个框架基本属于当前最好的NIO框架了（Mina其实也不错，不过总体来说还是比不上Netty的），大多数互联网公司也都在用Netty。 6、JDK源码 要想拿高工资，JDK源码不可不读。上面的内容可能还和具体场景联系起来，JDK源码就是实打实地看你平时是不是爱钻研了。LZ面试过程中被问了不少JDK源码的问题，其中最刁钻的一个问了LZ，String的hashCode()方法是怎么实现的，幸好LZ平时String源代码看得多，答了个大概。JDK源码其实没什么好总结的，纯粹看个人，总结一下比较重要的源码： （1）List、Map、Set实现类的源代码 （2）ReentrantLock、AQS的源代码 （3）AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的 （4）线程池的实现原理 （5）Object类中的方法以及每个方法的作用 这些其实要求蛮高的，LZ去年一整年基本把JDK中重要类的源代码研究了个遍，真的花费时间、花费精力，当然回头看，是值得的—-不仅仅是为了应付面试。 7、框架 老生常谈，面试必问的东西。一般来说会问你一下你们项目中使用的框架，然后给你一些场景问你用框架怎么做，比如我想要在Spring初始化bean的时候做一些事情该怎么做、想要在bean销毁的时候做一些事情该怎么做、MyBatis中$和#的区别等等，这些都比较实际了，平时积累得好、有多学习框架的使用细节自然都不成问题。 如果上面你的问题答得好，面试官往往会深入地问一些框架的实现原理。问得最多的就是Spring AOP的实现原理，当然这个很简单啦，两句话就搞定的的事儿，即使你不会准备一下就好了。LZ遇到的最变态的是让LZ画一下Spring的Bean工厂实现的UML图，当然面对这样一个有深度的问题，LZ是绝对答不出来的/(ㄒoㄒ)/~~ 8、数据库 数据库十有八九也都会问到。一些基本的像union和union all的区别、left join、几种索引及其区别就不谈了，比较重要的就是数据库性能的优化，如果对于数据库的性能优化一窍不通，那么有时间，还是建议你在面试前花一两天专门把SQL基础和SQL优化的内容准备一下。 不过数据库倒是不用担心，一家公司往往有很多部门，如果你对数据库不熟悉而基本技术又非常好，九成都是会要你的，估计会先把你放到对数据库使用不是要求非常高的部门锻炼一下。 9、数据结构和算法分析 数据结构和算法分析，对于一名程序员来说，会比不会好而且在工作中绝对能派上用场。数组、链表是基础，栈和队列深入一些但也不难，树挺重要的，比较重要的树AVL树、红黑树，可以不了解它们的具体实现，但是要知道什么是二叉查找树、什么是平衡树，AVL树和红黑树的区别。记得某次面试，某个面试官和我聊到了数据库的索引，他问我： 你知道索引使用的是哪种数据结构实现吗？ LZ答到用的Hash表吧，答错。他又问，你知道为什么要使用树吗？LZ答到因为Hash表可能会出现比较多的冲突，在千万甚至是上亿级别的数据面前，会大大增加查找的时间复杂度。而树比较稳定，基本保证最多二三十次就能找到想要的数据，对方说不完全对，最后我们还是交流了一下这个问题，我也明白了为什么要使用树，这里不说，网友朋友们觉得索引为什么要使用树来实现呢？ 至于算法分析，不会、不想研究就算了，记得某次面试对方问我，Collections.sort方法使用的是哪种排序方法，额，吐血三升。当然为了显示LZ的博学，对算法分析也有一定的研究(⊙﹏⊙)b，LZ还是硬着头皮说了一句可能是冒泡排序吧。当然答案肯定不是，有兴趣的网友朋友们可以去看一下Collections.sort方法的源代码，用的是一种叫做TimSort的排序法，也就是增强型的归并排序法。 10、Java虚拟机 出乎LZ的意料，Java虚拟机应该是很重要的一块内容，结果在这几家公司中被问到的概率几乎为0。要知道，LZ去年可是花了大量的时间去研究Java虚拟机的，光周志明老师的《 深入理解Java虚拟机：JVM高级特性与最佳实践 》，LZ就读了不下五遍。 言归正传，虽然Java虚拟机没问到，但我觉得还是有必要研究的，LZ就简单地列一个提纲吧，谈谈Java虚拟机中比较重要的内容： Java虚拟机的内存布局 GC算法及几种垃圾收集器 类加载机制，也就是双亲委派模型 Java内存模型 happens-before规则 volatile关键字使用规则 也许面试无用，但在走向大牛的路上，不可不会。 11、Web方面的一些问题 Java主要面向Web端，因此Web的一些问题也是必问的。LZ碰到过问得最多的两个问题是： 谈谈分布式Session的几种实现方式 常用的四种能答出来自然是让面试官非常满意的，另外一个常问的问题是： 讲一下Session和Cookie的区别和联系以及Session的实现原理 这两个问题之外，web.xml里面的内容是重点，Filter、Servlet、Listener，不说对它们的实现原理一清二楚吧，至少能对它们的使用知根知底。另外，一些细节的方面比如get/post的区别、forward/重定向的区别、HTTPS的实现原理也都可能会被考察到。 噢，想起来了，一致性Hash算法貌似也被问到了几次，这个LZ以前专门深入研究过并且写了两篇博文，因此问到这个问题LZ自然是答得毫不费力。文章是 MemCache详细解读 和对 一致性Hash算法，Java代码实现的深入研究 ，特别说明，LZ真的不是在为自已以前写的文章打广告啊啊啊啊啊啊。 最后，如果有兴趣有时间，建议学习、研究一下SOA和RPC，面向服务体系，大型分布式架构必备，救命良方、包治百病、屡试不爽。 关于HR面试 如果你过五关斩六将，成功地通过了所有的技术面，那么恭喜你，你离升职加薪、出任CEO、迎娶白富美、走向人生巅峰又进了一步。但是还没有到谈薪资待遇的时候，最后还有一个考验：HR面试。基本所有的大公司都有这一轮的面试，不要小看HR面试，很多公司的HR对于面试者都有一票否决权的—-即使前面的面试对你的评价再高。 所以，这轮的面试也必须重视起来，HR面试主要问的是几点： 简历中写的过去工作经历的离职原因 当前公司薪资待遇 期望能到怎样的一家公司 个人未来的发展方向 我专门提一下第2点。可能有人比较排斥也不想说这个，我个人倒是持开放状态，问了就说了，当然一些的夸大还是必要的，当前公司薪资待遇多报个一千块钱完全没问题（毕竟是一家互联网公司总多多少少有些补贴啊什么的嘛）。因为这和你在新公司能拿到的薪水关系不大，新公司能拿到的薪水的决定因素是整个公司的薪资情况以及根据你的面试情况在公司的定位，都是有固定的薪资范围的。HR问这个主要也就是心里有个数并且看你是否诚信—-有些公司入职时会要求你提供最近一家单位的银行流水号。 HR面试就说到这里了，总结起来其实就是四个字： 滴水不漏 。整个面试过程态度积极向上，不要有任何悲观消极的态度（尤其在谈到以前公司情况的时候，即使有再多的不满），就不会有问题。 关于面试心态 这个嘛，LZ其实在公司也面试过几个人，一半以上的面试者回答问题的时候都属于那种双腿发抖、声音颤抖的类型。在LZ看来这大可不必并且这还是扣分项，回答问题的时候最最基本的两个要求： 不紧不慢，平心静气 条理清晰 表达能力绝对是面试的时候重要的考察项目。咱们做的是程序员这一行，讲究的是团队协作，不是写作、画画，一支笔、一个人就行了，一个表达能力不行的程序员，要来又有什么用呢？ 除此之外，就是保持良好的心态。古语说得好，只要功夫深，铁杵磨成针，面试的成功与否，在于平时的积累，临时抱抱佛脚，看两道面试题是没有用的，只要平时足够努力，成功是水到渠成的事情，平时不怎么研究技术的，那也就是个听天由命的事情，只要充分地展示平时自己的所学就可以了。 因此在我看来，不要把面试当作面试，当做一次技术交流，把 面试的心态从我要找到一份工作转变为我要通过面试去发现不足、提升自己 ，这样就会平和多了，即使失败也不会有太多失望的感觉。 另外，如果平时自己热衷于研究技术的朋友，真的要有自信，不要觉得别人面试你别人就比你厉害。面试官未必比你优秀，他问的问题往往都是他平时研究得比较多的问题，你一样有很多自己的研究面试官未必知道。 关于Java 网上常看到一种说法：Java比较简单。某种程度上这会打击Java程序员的信心—-原来咱们平时用的是这种小儿科的玩意儿啊，在我看来这种想法大可不必，这一部分我来讲讲对于这个话题的看法。 这种说法有些片面，得分开两部分来看，我用四个自总结一下就是： 易学难精 。 1、易学部分 Java易学我认为有两部分的原因： 很多培训公司包括大四的学生找工作都会学习Java，绝大多数是因为易学。Java从C/C++发展而来，感谢前人的智慧，它消除了C/C++中最复杂和让人困惑的语法、它消除了平台的差异性、它不需要用户手动释放内存空间、它避免了Java程序员和本地语言的交互，让程序员只需要专注于语法层面和应用层面 Java作为一门面向对象的语言，在企业级开发中体现出了它无与伦比的特性，整个开发流程比较固定化、模块化，需求分析起来也相对容易。我举个自己以前的例子吧，我在大一学习C语言的时候，用C语言写了一个图书管理系统写了2000行+的代码，大四学了C++之后，用面向对象的语言C++取代面向过程的语言C语言重新写了一个功能相似的图书管理系统，只写了1100行的样子，这就是面向对象的优势 2、难精部分 接着咱们聊聊难精的部分。 Java语言的设计者帮助Java程序员做了这么多事情，这有利也有弊。有利的部分前面已经说过了，让Java易学，不过有弊的部分同样明显。假如在应用运行过程中遇到了语法层面和应用层面之外的错误，应当如何处理？比如线上环境出现内存溢出怎么办？GC时间过长怎么办？IO长时间没反应怎么办？方法抛出莫名其妙的异常怎么办？ 凡此种种，绝不是一名只会写几个if…else…的Java程序员就可以解决的，这需要大量的经历、大量的实践、大量对Java底层实现细节的研究，而这往往是最难、最考验Java程序员的部分，一些人根本就不想往深去研究，另外一些人研究了一点点就研究不下去了。 Java为什么难精？就是这个原因。除非你水平特别高，否则五年工作经验以下的Java程序员在简历上写”精通Java”绝对是一件非常愚蠢的事情。 结语 文章写到这里，感觉有点像鸡汤文了，那就以最后的鸡汤作为结尾吧。 在以前博客园的一篇文章中，讲到了奔三程序员的困惑，大致说的是三十岁之后程序员要转行之类的云云，LZ在博文中留下了如下的评论： 就以这段话自勉、共勉吧。越努力、越幸运， 如果你不是官二代、富二代、红二代， 那么请记住： 勤奋才是改变你命运的唯一捷径 。 ** ================================================================================== 我不能保证写的每个地方都是对的，但是至少能保证不复制、不黏贴，保证每一句话、每一行代码都经过了认真的推敲、仔细的斟酌。每一篇文章的背后，希望都能看到自己对于技术、对于生活的态度。 我相信乔布斯说的，只有那些疯狂到认为自己可以改变世界的人才能真正地改变世界。面对压力，我可以挑灯夜战、不眠不休；面对困难，我愿意迎难而上、永不退缩。 ** 其实我想说的是，我只是一个程序员，这就是我现在纯粹人生的全部。 ==================================================================================","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://www.itchina.top/tags/java/"},{"name":"工作","slug":"工作","permalink":"https://www.itchina.top/tags/工作/"},{"name":"经验","slug":"经验","permalink":"https://www.itchina.top/tags/经验/"},{"name":"面试","slug":"面试","permalink":"https://www.itchina.top/tags/面试/"},{"name":"程序员","slug":"程序员","permalink":"https://www.itchina.top/tags/程序员/"}]},{"title":"分布式日志收集之Logstash 笔记（一）","slug":"分布式日志收集之Logstash 笔记（一）","date":"2018-04-19T16:34:21.446Z","updated":"2018-04-19T16:30:16.388Z","comments":true,"path":"2018/04/20/分布式日志收集之Logstash 笔记（一）/","link":"","permalink":"https://www.itchina.top/2018/04/20/分布式日志收集之Logstash 笔记（一）/","excerpt":"","text":"（一）logstash是什么？ logstash是一种分布式日志收集框架，开发语言是JRuby，当然是为了与Java平台对接，不过与Ruby语法兼容良好，非常简洁强大，经常与ElasticSearch，Kibana配置，组成著名的ELK技术栈，非常适合用来做日志数据的分析。 当然它可以单独出现，作为日志收集软件，你可以收集日志到多种存储系统或临时中转系统，如MySQL，redis，kakfa，HDFS,lucene，solr等并不一定是ElasticSearch。 官网下载地址：https://www.elastic.co/downloads/logstash官网文档地址：https://www.elastic.co/guide/en/logstash/current/index.html （二）logstash的的安装 logstash的目前的最新版本是2.0.0，建议安装在Linux平台，虽然它也支持Windows平台，但可能会有问题下载：wget https://download.elastic.co/logstash/logstash/logstash-2.0.0.tar.gz 解压：tar -zxvf logstash-2.0.0.tar.gz 进入根目录，执行bin/logstash -h 可查看帮助文档参数介绍如下： 使用命令模板:/bin/logstash 命令参数 选项 选项:-f ， 指定加载一个后缀为.conf文件的logstash配置模块-e , 命令行指定参数 ， 通常用来调试-w, 指定logstash的工作线程数-l, 指定logstash的默认日志写入到一个文件中，如果不指定，默认是标准输出--quiet 静默模式，仅仅只有error级别信息输出--verbose info级别的log输出--debug debug 级别的log输出.-V, –version 查看logstash的版本-p, –pluginpath PATH 加载自定义的logstash插件-t, –configtest 检查logstash配置是否有效-h, –help 打印帮助 （三）logstash的数据处理模型 （1）input =》 output（2）input =》 filter =》 output 其中input常用的输入源有：file，syslog，redis，log4j，apache log或nginxlog，或者其他一些自定义的log格式，业务log，搜索log，订单log等等 filter常用的选项有：grok：支持正则提取任何非结构化数据或结构化数据，其中logstash内置120多种正则，比如常见的时间，ip，用户名，等等也支持自定义正则解析mutate：修改字段名，删除，更新等操作，转换字段类型等drop： 删除某些时间，如debugclone：拷贝一份事件副本，用来添加或删除字段geoip : 通过ip获取地理位置信息，在做kibana区域统计图非常炫ruby： 支持原生的ruby代码，操作事件，实现强大的其他功能 output常用的输出有：elasticsearch 比较常用file：写入文件redis：写入队列hdfs：写入HDFS，需插件支持zabbix： zabbix监控mongodb：写入mongodb库 除此之外还有个编码插件codecs也比较常用常用来处理json数据或者多行数据源 （四）logstash一些简单例子 （1）使用命令行命令调试： [search@h3 logstash-2.0.0]$ bin/logstash -e &quot;input{stdin{}} output{stdout{}}&quot; Default settings used: Filter workers: 1 Logstash startup completed hello 2015-11-04T15:16:02.747Z h3 hello test 2015-11-04T15:16:08.108Z h3 test （2）命令行参数仅适合简单的配置，如果配置比较多，我们一般会写入一个以.conf结尾的配置文件里，然后使用-f命令加载，将（1）中的配置，写入hello.conf 然后使用bin/logstash -f hello.conf 执行加载，即可达到同样效果 （3）常用的数据模块 &lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;input{ ..... } filter{ ...... } output{ ....... } （4）监听文件,支持通配符，写入文件 input{ file =&gt; [&quot;/var/log/file&quot;,&quot;/var/solr/log/*&quot;] } output{ file =&gt; &quot;/sys/collect/log&quot; } （5）logstash插件支持数据类型 数组： path=&gt; [&quot;a&quot;,&quot;b&quot;] 布尔：ssl_enable =&gt; true 字节： my_bytes =&gt;&quot;1113&quot;#1113 bytes my_bytes =&gt;&quot;10MiB&quot;#10485760 bytes my_bytes =&gt;&quot;100kib&quot;#102400 bytes my_bytes =&gt;&quot;180 mb&quot;#180000000 bytes 编码： codec =&gt; &quot;json&quot; 哈希表： match =&gt; { &quot;k1&quot; =&gt; &quot;v1&quot; &quot;k2&quot; =&gt; &quot;v2&quot; &quot;k3&quot; =&gt; &quot;v3&quot; } 数值： port=&gt; 33 密码： pwd=&gt; &quot;password&quot; 路径： path=&gt; &quot;/tmp/logstash&quot; 字符串： name =&gt; &quot;hello wordld&quot; 注释： input{ # 号开头，与shell脚本注释一样 }","categories":[],"tags":[{"name":"分布式日志","slug":"分布式日志","permalink":"https://www.itchina.top/tags/分布式日志/"},{"name":"Logstash","slug":"Logstash","permalink":"https://www.itchina.top/tags/Logstash/"}]},{"title":"从Redis分区的优缺点来看适合的应用场景","slug":"从Redis分区的优缺点来看适合的应用场景","date":"2018-04-19T16:34:21.445Z","updated":"2018-04-19T16:30:29.242Z","comments":true,"path":"2018/04/20/从Redis分区的优缺点来看适合的应用场景/","link":"","permalink":"https://www.itchina.top/2018/04/20/从Redis分区的优缺点来看适合的应用场景/","excerpt":"","text":"正文 Redis Partitioning即Redis分区，简单的说就是将数据分布到不同的redis实例中，因此对于每个redis实例所存储的内容仅仅是所有内容的一个子集。分区（Partitioning）不仅仅是Redis中的概念，几乎是所有数据存储系统都会涉及到的概念，这篇文章将会在理解分区基本概念的基础之上进一步了解Redis对分区的支持。 一、我们为什么要分区 我们为什么要分区？分区的动机是什么？通常来说，Redis分区的好处大致有如下两个方面： 性能的提升，单机Redis的网络I/O能力和计算资源是有限的，将请求分散到多台机器，充分利用多台机器的计算能力可网络带宽，有助于提高Redis总体的服务能力。 存储的横向扩展，即使Redis的服务能力能够满足应用需求，但是随着存储数据的增加，单台机器受限于机器本身的存储容量，将数据分散到多台机器上存储使得Redis服务可以横向扩展。 总的来说，分区使得我们本来受限于单台计算机硬件资源的问题不再是问题，存储不够？计算资源不够？带宽不够？我们都可以通过增加机器来解决这些问题。 二、Redis分区基础 实际应用中有很多分区的具体策略，举个例子，假设我们已经有了一组四个Redis实例分别为R0、R1、R2、R3，另外我们有一批代表用户的键，如：user:1，user:2，……等等，其中“user:”后面的数字代表的是用户的ID，我们要做的事情是把这些键分散存储在这四个不同的Redis实例上。怎么做呢？最简单的一种方式是范围分区(range partitioning)，下面我们来看看基于范围分区怎么做。 范围分区 所谓范围分区，就是将一个范围内的key都映射到同一个Redis实例中，加入数据集还是上面提到的用户数据，具体做法如下： 我们可以将用户ID从0到10000的用户数据映射到R0实例，而将用户ID从10001到20000的对象映射到R1实例，依次类推。 这种方法虽然简单，但是在实际应用中是很有效的，不过还是有问题： 我们需要一张表，这张表用来存储用户ID范围到Redis实例的映射关系，比如用户ID0-10000的是映射到R0实例……。 我们不仅需要对这张表进行维护，而且对于每种对象类型我们都需要一个这样的表，比如我们当前存储的是用户信息，如果存储的是订单信息，我们就需要再建一张映射关系表。 如果我们想要存储的数据的key并不能按照范围划分怎么办，比如我们的key是一组uuid，这个时候就不好用范围分区了。 因此，在实际应用中，范围分区并不是很好的选择，不用担心，我们还有更好的方法，接下来认识下哈希分区。 哈希分区 哈希分区跟范围分区相比一个明显的优点是哈希分区适合任何形式的key，而不像范围分区一样需要key的形式为object_name:，而且分区方法也很简单，一个公式就可以表达： id=hash(key)%N 其中id代表Redis实例的编号，公式描述的是首先根据key和一个hash函数（如crc32函数）计算出一个数值型的值。接着上面的例子，我们的第一个要处理的key是user:1，hash（user:1）的结果是93024922。 然后哈希结果进行取模，取模的目的是计算出一个介于0到3之间的值，因此这个值才可以被映射到我们的一台Redis实例上面。比如93024922%4结果是2，我们就会知道foobar将要被存储在R2上面。 当然除了上面提到的两种分区方法，还有很多其他的方法。比如一种从哈希分区演进而来的consistenthashing分区，相信信息可以参考我的另一篇文章《memcached分布式实现原理》，其已经被redis client和proxies实现了。 三、不同的分区实现 分区可以在redis软件栈的不同部分被实现，我们来看看下面几种： 客户端实现 客户端实现即key在redis客户端就决定了要被存储在那台Redis实例中，见下图：客户端实现分区示意图 代理实现 代理实现即客户端将请求发往代理服务器，代理服务器实现了Redis协议，因此代理服务器可以代理客户端和Redis服务器通信。代理服务器通过配置的分区schema来将客户端的请求转发到正确的Redis实例中，同时将反馈消息返回给客户端。代理实现Redis分区示意图如下： 代理实现Redis分区示意图 Redis和Memcached代理Twemoroxy都实现了代理分区。 查询路由 查询路由是Redis Cluster实现的一种Redis分区方式： 查询路由Redis分区示意图 查询路由的过程中，我们可以将查询请求随机的发送到任意一个Redis实例，这个Redis实例负责将请求转发至正确的Redis实例中。Redis集群实现了一个通过和客户端协作的hybrid来做查询路由。 四、Redis分区的缺点 尽管Redis分区到现在为止，so far sogood，但是Redis分区有一些致命的缺点，这导致一些Redis功能在分区的环境下并不能很好地工作，我们来看看： 多键操作是不被支持的，比如我们将要批量操作的键被映射到了不同的Redis实例中。 多键的Redis事务是不被支持的。 分区的最小粒度是键，因此我们不能将关联到一个键的很大的数据集映射到不同的实例。 当应用分区的时候，数据的处理是非常复杂的，比如我们需要处理多个rdb/aof文件，将分布在不同实例的文件聚集到一起备份。 添加和删除机器是很复杂的，例如Redis集群支持几乎运行时透明的因为增加或减少机器而需要做的rebalancing,然而像客户端和代理分区这种方式是不支持这种功能的。 既然有问题，那么就需要解决方案，这个时候Pre-sharding来了，后面我们会介绍Pre-Sharding。 五、持久存储用还是缓存 尽管数据分区对于Redis来说无论是数据持久化存储还是缓存，在概念上都是一样的，然而对于数据持久化存储还是有一个很大的限制。当我们使用Redis来作为持久化存储的时候，每一个key必须一直被映射到同一个Redis实例。而当Redis被当做缓存使用的时候，对于这个key，如果一个实例不能用了，这个key还可以被映射到其他的实例中。 Consistent hashing实现通常使得当一个key被映射到的实例不能用的时候将这个key映射到其他实例成为可能。类似，如果增加了一台机器，一部分的key将会被映射到这台新的机器上，我们需要了解的两点如下： 如果Redis被用来当做缓存，且要求容易增加或删除机器，使用consistent hashing是非常简单的。 如果Redis被用来当做（持久）存储，一个固定的key到实例的映射是需要的，因此我们不能够再灵活的添加或删除机器。否则，我们需要在增加或删除机器的时候系统能够rebalace，当前Redis Cluster已经支持。 六、Pre-Sharding 通过上面的介绍，我们知道Redis分区应用起来是有问题的，除非我们只是使用Redis当做缓存，否则对于增加机器或删除机器是非常麻烦的。 然而，通常我们Redis容量变动在实际应用中是非常常见的，比如今天我需要10台Redis机器，明天可能就需要50台机器了。 鉴于Redis是很轻量级的服务（每个实例仅仅占用1M），对于上面的问题一种简单的解决办法是： 我们可以开启多个Redis实例，尽管是一台物理机器，我们在刚开始的时候也可以开启多个实例。我们可以从中选择一些实例，比如32或64个实例来作为我们的工作集群。当一台物理机器存储不够的时候，我们可以将一般的实例移动到我们的第二台物理机上，依次类对，我们可以保证集群中Redis的实例数不变，又可以达到扩充机器的目的。 怎么移动Redis实例呢？当需要将Redis实例移动到独立的机器上的时候，我们可以通过下面步骤实现： 在新的物理机上启动一个新的Redis实例。 将新的物理机作为要移动的那台的slave机器。 停止客户端。 更新将要被移动的那台Redis实例的IP地址。 对于slave机器发送SLAVEOF ON ONE命令。 使用新的IP启动Redis客户端。 关闭不再使用的那个Redis实例。 七、总结 这篇文章在理解Redis分区概念的基础之上又介绍了Redis分区常见的几种实现方式及原理，最后根据实现中遇到的问题引入了Pre-Sharding解决方案。 参考文献 《Redis官方文档》","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.itchina.top/categories/Redis/"}],"tags":[]},{"title":"从MVC到前后端分离（REST-个人也认为是目前比较流行和比较好的方式）","slug":"从MVC到前后端分离（REST-个人也认为是目前比较流行和比较好的方式）","date":"2018-04-19T16:34:21.445Z","updated":"2018-04-19T16:30:03.445Z","comments":true,"path":"2018/04/20/从MVC到前后端分离（REST-个人也认为是目前比较流行和比较好的方式）/","link":"","permalink":"https://www.itchina.top/2018/04/20/从MVC到前后端分离（REST-个人也认为是目前比较流行和比较好的方式）/","excerpt":"","text":"摘要： MVC模式早在上个世纪70年代就诞生了，直到今天它依然存在，可见生命力相当之强。MVC模式最早用于Smalltalk语言中，最后在其它许多开发语言中都得到了很好的应用，例如，Java中的Struts、Spring MVC等框架。 1. 理解MVC MVC是一种经典的设计模式，全名为Model-View-Controller，即模型-视图-控制器。 其中，模型是用于封装数据的载体，例如，在 Java 中一般通过一个简单的POJO（Plain Ordinary Java Object）来表示，其本质是一个普通的Java Bean，包含一系列的成员变量及其getter/setter方法。对于视图而言，它更加偏重于展现，也就是说，视图决定了界面到底长什么样子，在Java中可通过JSP来充当视图，或者通过纯HTML的方式进行展现，而后者才是目前的主流。模型和视图需要通过控制器来进行粘合，例如，用户发送一个HTTP请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。 综上所述，MVC的交互过程如图1所示。 2. MVC模式的优点与不足 MVC模式早在上个世纪70年代就诞生了，直到今天它依然存在，可见生命力相当之强。MVC模式最早用于Smalltalk语言中，最后在其它许多开发语言中都得到了很好的应用，例如，Java中的Struts、SpringMVC等框架。正是因为这些MVC框架的出现，才让MVC模式真正落地，让开发更加高效，让代码耦合度尽量减小，让应用程序各部分的职责更加清晰。 既然MVC模式这么好，难道它就没有不足的地方吗？我认为MVC至少有以下三点不足： 每次请求必须经过“控制器-&gt;模型-&gt;视图”这个流程，用户才能看到最终的展现的界面，这个过程似乎有些复杂。 实际上视图是依赖于模型的，换句话说，如果没有模型，视图也无法呈现出最终的效果。 渲染视图的过程是在服务端来完成的，最终呈现给浏览器的是带有模型的视图页面，性能无法得到很好的优化。 为了使数据展现过程更加直接，并且提供更好的用户体验，我们有必要对MVC模式进行改进。不妨这样来尝试，首先从浏览器发送AJAX请求，然后服务端接受该请求并返回JSON数据返回给浏览器，最后在浏览器中进行界面渲染。 改进后的MVC模式如图2所示。 也就是说，我们输入的是AJAX请求，输出的是JSON数据，市面上有这样的技术来实现这个功能吗？答案是REST。 REST全称是Representational State Transfer（表述性状态转移），它是RoyFielding博士在2000年写的一篇关于软件 架构 风格的论文，此文一出，威震四方！国内外许多知名互联网公司纷纷开始采用这种轻量级的Web服务，大家习惯将其称为RESTful WebServices，或简称REST服务。] 如果将浏览器这一端视为前端，而服务器那一端视为后端的话，可以将以上改进后的MVC模式简化为以下前后端分离模式，如图3所示。 可见，有了REST服务，前端关注界面展现，后端关注业务逻辑，分工明确，职责清晰。那么，如何使用REST服务将应用程序进行前后端分离呢？我们接下来继续探讨，首先我们需要认识REST。 3. 认识REST REST本质上是使用URL来访问资源种方式。众所周知，URL就是我们平常使用的请求地址了，其中包括两部分：请求方式与请求路径，比较常见的请求方式是GET与POST，但在REST中又提出了几种其它类型的请求方式，汇总起来有六种：GET、POST、PUT、DELETE、HEAD、OPTIONS。尤其是前四种，正好与CRUD（Create-Retrieve-Update-Delete，增删改查）四种操作相对应，例如，GET（查）、POST（增）、PUT（改）、DELETE（删），这正是REST与CRUD的异曲同工之妙！需要强调的是，REST是“面向资源”的，这里提到的资源，实际上就是我们常说的领域对象，在系统设计过程中，我们经常通过领域对象来进行数据建模。 REST是一个“无状态”的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。也就是说，服务端将内部资源发布REST服务，客户端通过URL来访问这些资源，这不就是SOA所提倡的“面向服务”的思想吗？所以，REST也被人们看做是一种“轻量级”的SOA实现技术，因此在企业级应用与互联网应用中都得到了广泛应用。 下面我们举几个例子对REST请求进行简单描述： 可见，请求路径相同，但请求方式不同，所代表的业务操作也不同，例如，/advertiser/1这个请求，带有GET、PUT、DELETE三种不同的请求方式，对应三种不同的业务操作。 虽然REST看起来还是很简单的，实际上我们往往需要提供一个REST框架，让其实现前后端分离架构，让开发人员将精力集中在业务上，而并非那些具体的技术细节。下面我们将使用Java技术来实现这个REST框架，整体框架会基于Spring进行开发。 4. 实现REST框架 4.1 统一响应结构使用REST框架实现前后端分离架构，我们需要首先确定返回的JSON响应结构是统一的，也就是说，每个REST请求将返回相同结构的JSON响应结构。不妨定义一个相对通用的JSON响应结构，其中包含两部分：元数据与返回值，其中，元数据表示操作是否成功与返回值消息等，返回值对应服务端方法所返回的数据。该JSON响应结构如下： { &quot;meta&quot;: { &quot;success&quot;: true, &quot;message&quot;: &quot;ok&quot; }, &quot;data&quot;: ... } 为了在框架中映射以上JSON响应结构，我们需要编写一个Response类与其对应： [java] view plain copy public class Response { private static final String OK = “ok” ; private static final String ERROR = “error” ; private Meta meta; private Object data; public Response success() { this .meta = new Meta( true , OK); return this ; } public Response success(Object data) { this .meta = new Meta( true , OK); this .data = data; return this ; } public Response failure() { this .meta = new Meta( false , ERROR); return this ; } public Response failure(String message) { this .meta = new Meta( false , message); return this ; } public Meta getMeta() { return meta; } public Object getData() { return data; } public class Meta { private boolean success; private String message; public Meta( boolean success) { this .success = success; } public Meta( boolean success, String message) { this .success = success; this .message = message; } public boolean isSuccess() { return success; } public String getMessage() { return message; } } } 以上Response类包括两类通用返回值消息：ok与error，还包括两个常用的操作方法：success( )与failure()，通过一个内部类来展现元数据结构，我们在下文中多次会使用该Response类。 实现该REST框架需要考虑许多问题，首当其冲的就是对象序列化问题。 4.2 实现对象序列化想要解释什么是对象序列化？不妨通过一些例子进行说明。比如，通过浏览器发送了一个普通的HTTP请求，该请求携带了一个JSON格式的参数，在服务端需要将该JSON参数转换为普通的Java对象，这个转换过程称为序列化。再比如，在服务端获取了数据，此时该数据是一个普通的Java对象，然后需要将这个Java对象转换为JSON字符串，并将其返回到浏览器中进行渲染，这个转换过程称为反序列化。不管是序列化还是反序列化，我们一般都称为序列化。 实际上，SpringMVC已经为我们提供了这类序列化特性，只需在Controller的方法参数中使用@RequestBody注解定义需要反序列化的参数即可，如以下代码片段： [java] view plain copy @Controller public class AdvertiserController { @RequestMapping (value = “/advertiser” , method = RequestMethod.POST) public Response createAdvertiser( @RequestBody AdvertiserParam advertiserParam) { … } } 若需要对Controller的方法返回值进行序列化，则需要在该返回值上使用@ResponseBody注解来定义，如以下代码片段： [java] view plain copy @Controller public class AdvertiserController { @RequestMapping (value = “/advertiser/{id}” , method = RequestMethod.GET) public @ResponseBody Response getAdvertiser( @PathVariable ( “id” ) String advertiserId) { … } } 当然，@ResponseBody注解也可以定义在类上，这样所有的方法都继承了该特性。由于经常会使用到@ResponseBody注解，所以Spring提供了一个名为@RestController的注解来取代以上的@Controller注解，这样我们就可以省略返回值前面的@ResponseBody注解了，但参数前面的@RequestBody注解是无法省略的。实际上，看看Spring中对应@RestController注解的源码便可知晓： [java] view plain copy @Target ({ElementType.TYPE}) @Retention (RetentionPolicy.RUNTIME) @Documented @Controller @ResponseBody public @interface RestController { String value() default “” ; } 可见，@RestController注解已经被@Controller与@ResponseBody注解定义过了，Spring框架会识别这类注解。需要注意的是，该特性在Spring 4.0中才引入。 因此，我们可将以上代码进行如下改写： [java] view plain copy @RestController public class AdvertiserController { @RequestMapping (value = “/advertiser” , method = RequestMethod.POST) public Response createAdvertiser( @RequestBody AdvertiserParam advertiserParam) { … } @RequestMapping (value = “/advertiser/{id}” , method = RequestMethod.GET) public Response getAdvertiser( @PathVariable ( “id” ) String advertiserId) { … } } 除了使用注解来定义序列化行为以外，我们还需要使用Jackson来提供JSON的序列化操作，在Spring配置文件中只需添加以下配置即可： [xml] view plain copy &lt; mvc:annotation-driven &gt; &lt; mvc:message-converters &gt; &lt; bean class = “org.springframework.http.converter.json.MappingJackson2HttpMessageConverter” /&gt; &lt;/ mvc:message-converters &gt; &lt;/ mvc:annotation-driven &gt; 若需要对Jackson的序列化行为进行定制，比如，排除值为空属性、进行缩进输出、将驼峰转为下划线、进行日期格式化等，这又如何实现呢？ 首先，我们需要扩展Jackson提供的ObjectMapper类，代码如下： [java] view plain copy public class CustomObjectMapper extends ObjectMapper { private boolean camelCaseToLowerCaseWithUnderscores = false ; private String dateFormatPattern; public void setCamelCaseToLowerCaseWithUnderscores( boolean camelCaseToLowerCaseWithUnderscores) { this .camelCaseToLowerCaseWithUnderscores = camelCaseToLowerCaseWithUnderscores; } public void setDateFormatPattern(String dateFormatPattern) { this .dateFormatPattern = dateFormatPattern; } public void init() { // 排除值为空属性 setSerializationInclusion(JsonInclude.Include.NON_NULL); // 进行缩进输出 configure(SerializationFeature.INDENT_OUTPUT, true ); // 将驼峰转为下划线 if (camelCaseToLowerCaseWithUnderscores) { setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES); } // 进行日期格式化 if (StringUtil.isNotEmpty(dateFormatPattern)) { DateFormat dateFormat = new SimpleDateFormat(dateFormatPattern); setDateFormat(dateFormat); } } } 然后，将CustomObjectMapper注入到MappingJackson2HttpMessageConverter中，Spring配置如下： [xml] view plain copy &lt; bean id = “objectMapper” class = “com.xxx.api.json.CustomObjectMapper” init-method = “init” &gt; &lt; property name = “camelCaseToLowerCaseWithUnderscores” value = “true” /&gt; &lt; property name = “dateFormatPattern” value = “yyyy-MM-dd HH:mm:ss” /&gt; &lt;/ bean &gt; &lt; mvc:annotation-driven &gt; &lt; mvc:message-converters &gt; &lt; bean class = “org.springframework.http.converter.json.MappingJackson2HttpMessageConverter” &gt; &lt; property name = “objectMapper” ref = “objectMapper” /&gt; &lt;/ bean &gt; &lt;/ mvc:message-converters &gt; &lt;/ mvc:annotation-driven &gt; 通过以上过程，我们已经完成了一个基于Spring MVC的REST框架，只不过该框架还非常单薄，还缺乏很多关键性特性，尤其是异常处理。 4.3 处理异常行为在Spring MVC中，我们可以使用AOP技术，编写一个全局的异常处理切面类，用它来统一处理所有的异常行为，在Spring 3.2中才开始提供。使用法很简单，只需定义一个类，并通过@ControllerAdvice注解将其标注即可，同时需要使用@ResponseBody注解表示返回值可序列化为JSON字符串。代码如下： [java] view plain copy @ControllerAdvice @ResponseBody public class ExceptionAdvice { /** 400 - Bad Request */ @ResponseStatus (HttpStatus.BAD_REQUEST) @ExceptionHandler (HttpMessageNotReadableException. class ) public Response handleHttpMessageNotReadableException(HttpMessageNotReadableException e) { logger.error( ”参数解析失败” , e); return new Response().failure( “could_not_read_json” ); } /** 405 - Method Not Allowed */ @ResponseStatus (HttpStatus.METHOD_NOT_ALLOWED) @ExceptionHandler (HttpRequestMethodNotSupportedException. class ) public Response handleHttpRequestMethodNotSupportedException(HttpRequestMethodNotSupportedException e) { logger.error( ”不支持当前请求方法” , e); return new Response().failure( “request_method_not_supported” ); } /** 415 - Unsupported Media Type */ @ResponseStatus (HttpStatus.UNSUPPORTED_MEDIA_TYPE) @ExceptionHandler (HttpMediaTypeNotSupportedException. class ) public Response handleHttpMediaTypeNotSupportedException(Exception e) { logger.error( ”不支持当前媒体类型” , e); return new Response().failure( “content_type_not_supported” ); } /** 500 - Internal Server Error */ @ResponseStatus (HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler (Exception. class ) public Response handleException(Exception e) { logger.error( ”服务运行异常” , e); return new Response().failure(e.getMessage()); } } 可见，在ExceptionAdvice类中包含一系列的异常处理方法，每个方法都通过@ResponseStatus注解定义了响应状态码，此外还通过@ExceptionHandler注解指定了具体需要拦截的异常类。以上过程只是包含了一部分的异常情况，若需处理其它异常，可添加方法具体的方法。需要注意的是，在运行时从上往下依次调用每个异常处理方法，匹配当前异常类型是否与@ExceptionHandler注解所定义的异常相匹配，若匹配，则执行该方法，同时忽略后续所有的异常处理方法，最终会返回经JSON序列化后的Response对象。 4.4 支持参数验证我们回到上文所提到的示例，这里处理一个普通的POST请求，代码如下： [java] view plain copy @RestController public class AdvertiserController { @RequestMapping (value = “/advertiser” , method = RequestMethod.POST) public Response createAdvertiser( @RequestBody AdvertiserParam advertiserParam) { … } } 其中，AdvertiserParam参数包含若干属性，通过以下类结构可见，它是一个传统的POJO： [java] view plain copy public class AdvertiserParam { private String advertiserName; private String description; // 省略 getter/setter 方法 } 如果业务上需要确保AdvertiserParam对象的advertiserName属性必填，如何实现呢？ 若将这类参数验证的代码写死在Controller中，势必会与正常的业务逻辑搅在一起，导致责任不够单一，违背于“单一责任原则”。建议将其参数验证行为从Controller中剥离出来，放到另外的类中，这里仅提供一个@Valid注解来定义AdvertiserParam参数，并在AdvertiserParam类中通过@NotEmpty注解来定义advertiserName属性，就像下面这样： [java] view plain copy @RestController public class AdvertiserController { @RequestMapping (value = “/advertiser” , method = RequestMethod.POST) public Response createAdvertiser( @RequestBody @Valid AdvertiserParam advertiserParam) { … } } public class AdvertiserParam { @NotEmpty private String advertiserName; private String description; // 省略 getter/setter 方法 } 这里的@Valid注解实际上是Validation Bean规范提供的注解，该规范已由HibernateValidator框架实现，因此需要添加以下Maven依赖到pom.xml文件中： [xml] view plain copy &lt; dependency &gt; &lt; groupId &gt; org.hibernate &lt;/ groupId &gt; &lt; artifactId &gt; hibernate-validator &lt;/ artifactId &gt; &lt; version &gt; ${hibernate-validator.version} &lt;/ version &gt; &lt;/ dependency &gt; 需要注意的是，Hibernate Validator与Hibernate没有任何依赖关系，唯一有联系的只是都属于JBoss公司的开源项目而已。 要实现@NotEmpty注解的功能，我们需要做以下几件事情。 首先，定义一个@NotEmpty注解类，代码如下： [java] view plain copy @Documented @Target ({ElementType.FIELD, ElementType.PARAMETER}) @Retention (RetentionPolicy.RUNTIME) @Constraint (validatedBy = NotEmptyValidator. class ) public @interface NotEmpty { String message() default “not_empty” ; Class&lt;?&gt;[] groups() default {}; Class&lt;? extends Payload&gt;[] payload() default {}; } 以上注解类必须包含message、groups、payload三个属性，因为这是规范所要求的，此外，需要通过@Constraint注解指定一个验证器类，这里对应的是NotEmptyValidator，其代码如下： [java] view plain copy public class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; { @Override public void initialize(NotEmpty constraintAnnotation) { } @Override public boolean isValid(String value, ConstraintValidatorContext context) { return StringUtil.isNotEmpty(value); } } 以上验证器类实现了ConstraintValidator接口，并在该接口的isValid( )方法中完成了具体的参数验证逻辑。需要注意的是，实现接口时需要指定泛型，第一个参数表示验证注解类型（NotEmpty），第二个参数表示需要验证的参数类型（String）。 然后，我们需要在Spring配置文件中开启该特性，需添加如下配置： [xml] view plain copy &lt; bean class = “org.springframework.validation.beanvalidation.MethodValidationPostProcessor” /&gt; 最后，需要在全局异常处理类中添加参数验证处理方法，代码如下： [java] view plain copy @ControllerAdvice @ResponseBody public class ExceptionAdvice { /** 400 - Bad Request */ @ResponseStatus (HttpStatus.BAD_REQUEST) @ExceptionHandler (ValidationException. class ) public Response handleValidationException(ValidationException e) { logger.error( ”参数验证失败” , e); return new Response().failure( “validation_exception” ); } } 至此，REST框架已集成了Bean Validation特性，我们可以使用各种注解来完成所需的参数验证行为了。 看似该框架可以在本地成功跑起来，整个架构包含两个应用，前端应用提供纯静态的HTML页面，后端应用发布RESTAPI，前端需要通过AJAX调用后端发布的RESTAPI，然而AJAX是不支持跨域访问的，也就是说，前后端两个应用必须在同一个域名下才能访问。这是非常严重的技术障碍，一定需要找到解决方案。 4.5 解决跨域问题比如，前端应用为静态站点且部署在http://web.xxx.com域下，后端应用发布REST API并部署在http://api.xxx.com域下，如何使前端应用通过AJAX跨域访问后端应用呢？这需要使用到CORS技术来实现，这也是目前最好的解决方案了。 [CORS全称为Cross Origin ResourceSharing（跨域资源共享），服务端只需添加相关响应头信息，即可实现客户端发出AJAX跨域请求。] CORS技术非常简单，易于实现，目前绝大多数浏览器均已支持该技术（IE8浏览器也支持了），服务端可通过任何编程语言来实现，只要能将CORS响应头写入response对象中即可。 下面我们继续扩展REST框架，通过CORS技术实现AJAX跨域访问。 首先，我们需要编写一个Filter，用于过滤所有的HTTP请求，并将CORS响应头写入response对象中，代码如下： [java] view plain copy public class CorsFilter implements Filter { private String allowOrigin; private String allowMethods; private String allowCredentials; private String allowHeaders; private String exposeHeaders; @Override public void init(FilterConfig filterConfig) throws ServletException { allowOrigin = filterConfig.getInitParameter( ”allowOrigin” ); allowMethods = filterConfig.getInitParameter( ”allowMethods” ); allowCredentials = filterConfig.getInitParameter( ”allowCredentials” ); allowHeaders = filterConfig.getInitParameter( ”allowHeaders” ); exposeHeaders = filterConfig.getInitParameter( ”exposeHeaders” ); } @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; if (StringUtil.isNotEmpty(allowOrigin)) { List allowOriginList = Arrays.asList(allowOrigin.split( ”,” )); if (CollectionUtil.isNotEmpty(allowOriginList)) { String currentOrigin = request.getHeader( ”Origin” ); if (allowOriginList.contains(currentOrigin)) { response.setHeader( ”Access-Control-Allow-Origin” , currentOrigin); } } } if (StringUtil.isNotEmpty(allowMethods)) { response.setHeader( ”Access-Control-Allow-Methods” , allowMethods); } if (StringUtil.isNotEmpty(allowCredentials)) { response.setHeader( ”Access-Control-Allow-Credentials” , allowCredentials); } if (StringUtil.isNotEmpty(allowHeaders)) { response.setHeader( ”Access-Control-Allow-Headers” , allowHeaders); } if (StringUtil.isNotEmpty(exposeHeaders)) { response.setHeader( ”Access-Control-Expose-Headers” , exposeHeaders); } chain.doFilter(req, res); } @Override public void destroy() { } } 以上CorsFilter将从web.xml中读取相关Filter初始化参数，并将在处理HTTP请求时将这些参数写入对应的CORS响应头中，下面大致描述一下这些CORS响应头的意义： Access-Control-Allow-Origin：允许访问的客户端域名，例如：http://web.xxx.com，若为*，则表示从任意域都能访问，即不做任何限制。 Access-Control-Allow-Methods：允许访问的方法名，多个方法名用逗号分割，例如：GET,POST,PUT,DELETE,OPTIONS。 Access-Control-Allow-Credentials：是否允许请求带有验证信息，若要获取客户端域下的cookie时，需要将其设置为true。 Access-Control-Allow-Headers：允许服务端访问的客户端请求头，多个请求头用逗号分割，例如：Content-Type。 Access-Control-Expose-Headers：允许客户端访问的服务端响应头，多个响应头用逗号分割。 需要注意的是，CORS规范中定义Access-Control-Allow-Origin只允许两种取值，要么为*，要么为具体的域名，也就是说，不支持同时配置多个域名。为了解决跨多个域的问题，需要在代码中做一些处理，这里将Filter初始化参数作为一个域名的集合（用逗号分隔），只需从当前请求中获取Origin请求头，就知道是从哪个域中发出的请求，若该请求在以上允许的域名集合中，则将其放入Access-Control-Allow-Origin响应头，这样跨多个域的问题就轻松解决了。 以下是web.xml中配置CorsFilter的方法： [xml] view plain copy &lt; filter &gt; &lt; filter-name &gt; corsFilter &lt;/ filter-name &gt; &lt; filter-class &gt; com.xxx.api.cors.CorsFilter &lt;/ filter-class &gt; &lt; init-param &gt; &lt; param-name &gt; allowOrigin &lt;/ param-name &gt; &lt; param-value &gt; http://web.xxx.com &lt;/ param-value &gt; &lt;/ init-param &gt; &lt; init-param &gt; &lt; param-name &gt; allowMethods &lt;/ param-name &gt; &lt; param-value &gt; GET,POST,PUT,DELETE,OPTIONS &lt;/ param-value &gt; &lt;/ init-param &gt; &lt; init-param &gt; &lt; param-name &gt; allowCredentials &lt;/ param-name &gt; &lt; param-value &gt; true &lt;/ param-value &gt; &lt;/ init-param &gt; &lt; init-param &gt; &lt; param-name &gt; allowHeaders &lt;/ param-name &gt; &lt; param-value &gt; Content-Type &lt;/ param-value &gt; &lt;/ init-param &gt; &lt;/ filter &gt; &lt; filter-mapping &gt; &lt; filter-name &gt; corsFilter &lt;/ filter-name &gt; &lt; url-pattern &gt; /* &lt;/ url-pattern &gt; &lt;/ filter-mapping &gt; 完成以上过程即可实现AJAX跨域功能了，但似乎还存在另外一个问题，由于REST是无状态的，后端应用发布的RESTAPI可在用户未登录的情况下被任意调用，这显然是不安全的，如何解决这个问题呢？我们需要为REST请求提供安全机制。 4.6 提供安全机制解决REST安全调用问题，可以做得很复杂，也可以做得特简单，可按照以下过程提供REST安全机制： 当用户登录成功后，在服务端生成一个token，并将其放入内存中（可放入JVM或Redis中），同时将该token返回到客户端。 在客户端中将返回的token写入cookie中，并且每次请求时都将token随请求头一起发送到服务端。 提供一个AOP切面，用于拦截所有的Controller方法，在切面中判断token的有效性。 当登出时，只需清理掉cookie中的token即可，服务端token可设置过期时间，使其自行移除。 首先，我们需要定义一个用于管理token的接口，包括创建token与检查token有效性的功能。代码如下： [java] view plain copy public interface TokenManager { String createToken(String username); boolean checkToken(String token); } 然后，我们可提供一个简单的TokenManager实现类，将token存储到JVM内存中。代码如下： [java] view plain copy public class DefaultTokenManager implements TokenManager { private static Map&lt;String, String&gt; tokenMap = new ConcurrentHashMap&lt;&gt;(); @Override public String createToken(String username) { String token = CodecUtil.createUUID(); tokenMap.put(token, username); return token; } @Override public boolean checkToken(String token) { return !StringUtil.isEmpty(token) &amp;&amp; tokenMap.containsKey(token); } } 需要注意的是，如果需要做到分布式集群，建议基于Redis提供一个实现类，将token存储到Redis中，并利用Redis与生俱来的特性，做到token的分布式一致性。 然后，我们可以基于SpringAOP写一个切面类，用于拦截Controller类的方法，并从请求头中获取token，最后对token有效性进行判断。代码如下： [java] view plain copy public class SecurityAspect { private static final String DEFAULT_TOKEN_NAME = “X-Token” ; private TokenManager tokenManager; private String tokenName; public void setTokenManager(TokenManager tokenManager) { this .tokenManager = tokenManager; } public void setTokenName(String tokenName) { if (StringUtil.isEmpty(tokenName)) { tokenName = DEFAULT_TOKEN_NAME; } this .tokenName = tokenName; } public Object execute(ProceedingJoinPoint pjp) throws Throwable { // 从切点上获取目标方法 MethodSignature methodSignature = (MethodSignature) pjp.getSignature(); Method method = methodSignature.getMethod(); // 若目标方法忽略了安全性检查，则直接调用目标方法 if (method.isAnnotationPresent(IgnoreSecurity. class )) { return pjp.proceed(); } // 从 request header 中获取当前 token String token = WebContext.getRequest().getHeader(tokenName); // 检查 token 有效性 if (!tokenManager.checkToken(token)) { String message = String.format( ”token [%s] is invalid” , token); throw new TokenException(message); } // 调用目标方法 return pjp.proceed(); } } 若要使SecurityAspect生效，则需要添加如下Spring 配置： [xml] view plain copy &lt; bean id = “securityAspect” class = “com.xxx.api.security.SecurityAspect” &gt; &lt; property name = “tokenManager” ref = “tokenManager” /&gt; &lt; property name = “tokenName” value = “X-Token” /&gt; &lt;/ bean &gt; &lt; aop:config &gt; &lt; aop:aspect ref = “securityAspect” &gt; &lt; aop:around method = “execute” pointcut = “@annotation(org.springframework.web.bind.annotation.RequestMapping)” /&gt; &lt;/ aop:aspect &gt; &lt;/ aop:config &gt; 最后，别忘了在web.xml中添加允许的X-Token响应头，配置如下： [xml] view plain copy &lt; init-param &gt; &lt; param-name &gt; allowHeaders &lt;/ param-name &gt; &lt; param-value &gt; Content-Type,X-Token &lt;/ param-value &gt; &lt;/ init-param &gt; 总结 本文从经典的MVC模式开始，对MVC模式是什么以及该模式存在的不足进行了简述。然后引出了如何对MVC模式的改良，让其转变为前后端分离架构，以及解释了为何要进行前后端分离。最后通过REST服务将前后端进行解耦，并提供了一款基于Java的REST框架的主要实现过程，尤其是需要注意的核心技术问题及其解决方案。希望本文对正在探索前后端分离的读者们有所帮助，期待与大家共同探讨。","categories":[{"name":"J2EE","slug":"J2EE","permalink":"https://www.itchina.top/categories/J2EE/"}],"tags":[{"name":"mvc","slug":"mvc","permalink":"https://www.itchina.top/tags/mvc/"}]},{"title":"程序猿技能表","slug":"程序猿技能表","date":"2018-04-19T16:34:21.444Z","updated":"2018-04-19T16:29:58.341Z","comments":true,"path":"2018/04/20/程序猿技能表/","link":"","permalink":"https://www.itchina.top/2018/04/20/程序猿技能表/","excerpt":"","text":"程序猿技能表：分别是Java、C/C++、Android、iOS、PHP、前端、Python、.NET/C#","categories":[],"tags":[]},{"title":"sqlserver汉字转拼音","slug":"sqlserver汉字转拼音","date":"2018-04-19T16:34:21.443Z","updated":"2018-04-19T16:29:54.428Z","comments":true,"path":"2018/04/20/sqlserver汉字转拼音/","link":"","permalink":"https://www.itchina.top/2018/04/20/sqlserver汉字转拼音/","excerpt":"","text":"/* ————————————————————- 函数 : fn_GetPinyin 描述 : 汉字转拼音 ( 无数据表版 ) 使用 : dbo.fn_GetPinyin(‘ 中华人民共和国 ‘) = zhonghuarenmingongheguo 作者 : 流香羽 ( 改编： Tony) 博客 : http://hi.baidu.com/ 流香羽 -———————————————————— */ -- 创建函数 IF OBJECT_ID ( ‘[fn_GetPinyin]’ ) IS NOT NULL DROP FUNCTION [fn_GetPinyin] GO create function [dbo] . [fn_GetPinyin] ( @words nvarchar ( 2000 )) returns varchar ( 8000 ) as begin declare @word nchar ( 1 ) declare @pinyin varchar ( 8000 ) declare @i int declare @words_len int declare @unicode int set @i = 1 set @words = ltrim ( rtrim ( @words )) set @words_len = len ( @words ) while ( @i &lt;= @words_len ) -- 循环取字符 begin set @word = substring ( @words , @i , 1 ) set @unicode = unicode ( @word ) set @pinyin = ISNULL ( @pinyin + SPACE ( 1 ), ‘’ )+ ( case when unicode ( @word ) between 19968 and 19968 + 20901then ( select top 1 py from ( select ‘a’ as py , N ‘ 厑 ‘ as word union all select ‘ai’ , N ‘ 靉 ‘ union all select ‘an’ , N ‘ 黯 ‘ union all select ‘ang’ , N ‘ 醠 ‘ union all select ‘ao’ , N ‘ 驁 ‘ union all select ‘ba’ , N ‘ 欛 ‘ union all select ‘bai’ , N ‘ 瓸 ‘ -- 韛兡瓸 union all select ‘ban’ , N ‘ 瓣 ‘ union all select ‘bang’ , N ‘ 鎊 ‘ union all select ‘bao’ , N ‘ 鑤 ‘ union all select ‘bei’ , N ‘ 鐾 ‘ union all select ‘ben’ , N ‘ 輽 ‘ union all select ‘beng’ , N ‘ 鏰 ‘ union all select ‘bi’ , N ‘ 鼊 ‘ union all select ‘bian’ , N ‘ 變 ‘ union all select ‘biao’ , N ‘ 鰾 ‘ union all select ‘bie’ , N ‘ 彆 ‘ union all select ‘bin’ , N ‘ 鬢 ‘ union all select ‘bing’ , N ‘ 靐 ‘ union all select ‘bo’ , N ‘ 蔔 ‘ union all select ‘bu’ , N ‘ 簿 ‘ union all select ‘ca’ , N ‘ 囃 ‘ union all select ‘cai’ , N ‘ 乲 ‘ -- 縩乲 union all select ‘can’ , N ‘ 爘 ‘ union all select ‘cang’ , N ‘ 賶 ‘ union all select ‘cao’ , N ‘ 鼜 ‘ union all select ‘ce’ , N ‘ 簎 ‘ union all select ‘cen’ , N ‘ 笒 ‘ union all select ‘ceng’ , N ‘ 乽 ‘ -- 硛硳岾猠乽 union all select ‘cha’ , N ‘ 詫 ‘ union all select ‘chai’ , N ‘ 囆 ‘ union all select ‘chan’ , N ‘ 顫 ‘ union all select ‘chang’ , N ‘ 韔 ‘ union all select ‘chao’ , N ‘ 觘 ‘ union all select ‘che’ , N ‘ 爡 ‘ union all select ‘chen’ , N ‘ 讖 ‘ union all select ‘cheng’ , N ‘ 秤 ‘ union all select ‘chi’ , N ‘ 鷘 ‘ union all select ‘chong’ , N ‘ 銃 ‘ union all select ‘chou’ , N ‘ 殠 ‘ union all select ‘chu’ , N ‘ 矗 ‘ union all select ‘chuai’ , N ‘ 踹 ‘ union all select ‘chuan’ , N ‘ 鶨 ‘ union all select ‘chuang’ , N ‘ 愴 ‘ union all select ‘chui’ , N ‘ 顀 ‘ union all select ‘chun’ , N ‘ 蠢 ‘ union all select ‘chuo’ , N ‘ 縒 ‘ union all select ‘ci’ , N ‘ 嗭 ‘ -- 賜嗭 union all select ‘cong’ , N ‘ 謥 ‘ union all select ‘cou’ , N ‘ 輳 ‘ union all select ‘cu’ , N ‘ 顣 ‘ union all select ‘cuan’ , N ‘ 爨 ‘ union all select ‘cui’ , N ‘ 臎 ‘ union all select ‘cun’ , N ‘ 籿 ‘ union all select ‘cuo’ , N ‘ 錯 ‘ union all select ‘da’ , N ‘ 橽 ‘ union all select ‘dai’ , N ‘ 靆 ‘ union all select ‘dan’ , N ‘ 饏 ‘ union all select ‘dang’ , N ‘ 闣 ‘ union all select ‘dao’ , N ‘ 纛 ‘ union all select ‘de’ , N ‘ 的 ‘ union all select ‘den’ , N ‘ 扽 ‘ union all select ‘deng’ , N ‘ 鐙 ‘ union all select ‘di’ , N ‘ 螮 ‘ union all select ‘dia’ , N ‘ 嗲 ‘ union all select ‘dian’ , N ‘ 驔 ‘ union all select ‘diao’ , N ‘ 鑃 ‘ union all select ‘die’ , N ‘ 嚸 ‘ -- 眰嚸 union all select ‘ding’ , N ‘ 顁 ‘ union all select ‘diu’ , N ‘ 銩 ‘ union all select ‘dong’ , N ‘ 霘 ‘ union all select ‘dou’ , N ‘ 鬭 ‘ union all select ‘du’ , N ‘ 蠹 ‘ union all select ‘duan’ , N ‘ 叾 ‘ -- 籪叾 union all select ‘dui’ , N ‘ 譵 ‘ union all select ‘dun’ , N ‘ 踲 ‘ union all select ‘duo’ , N ‘ 鵽 ‘ union all select ‘e’ , N ‘ 鱷 ‘ union all select ‘en’ , N ‘ 摁 ‘ union all select ‘eng’ , N ‘ 鞥 ‘ union all select ‘er’ , N ‘ 樲 ‘ union all select ‘fa’ , N ‘ 髮 ‘ union all select ‘fan’ , N ‘ 瀪 ‘ union all select ‘fang’ , N ‘ 放 ‘ union all select ‘fei’ , N ‘ 靅 ‘ union all select ‘fen’ , N ‘ 鱝 ‘ union all select ‘feng’ , N ‘ 覅 ‘ union all select ‘fo’ , N ‘ 梻 ‘ union all select ‘fou’ , N ‘ 鴀 ‘ union all select ‘fu’ , N ‘ 猤 ‘ -- 鰒猤 union all select ‘ga’ , N ‘ 魀 ‘ union all select ‘gai’ , N ‘ 瓂 ‘ union all select ‘gan’ , N ‘ 灨 ‘ union all select ‘gang’ , N ‘ 戇 ‘ union all select ‘gao’ , N ‘ 鋯 ‘ union all select ‘ge’ , N ‘ 獦 ‘ union all select ‘gei’ , N ‘ 給 ‘ union all select ‘gen’ , N ‘ 搄 ‘ union all select ‘geng’ , N ‘ 堩 ‘ -- 亙堩啹喼嗰 union all select ‘gong’ , N ‘ 兣 ‘ -- 熕贑兝兣 union all select ‘gou’ , N ‘ 購 ‘ union all select ‘gu’ , N ‘ 顧 ‘ union all select ‘gua’ , N ‘ 詿 ‘ union all select ‘guai’ , N ‘ 恠 ‘ union all select ‘guan’ , N ‘ 鱹 ‘ union all select ‘guang’ , N ‘ 撗 ‘ union all select ‘gui’ , N ‘ 鱥 ‘ union all select ‘gun’ , N ‘ 謴 ‘ union all select ‘guo’ , N ‘ 腂 ‘ union all select ‘ha’ , N ‘ 哈 ‘ union all select ‘hai’ , N ‘ 饚 ‘ union all select ‘han’ , N ‘ 鶾 ‘ union all select ‘hang’ , N ‘ 沆 ‘ union all select ‘hao’ , N ‘ 兞 ‘ union all select ‘he’ , N ‘ 靏 ‘ union all select ‘hei’ , N ‘ 嬒 ‘ union all select ‘hen’ , N ‘ 恨 ‘ union all select ‘heng’ , N ‘ 堼 ‘ -- 堼囍 union all select ‘hong’ , N ‘ 鬨 ‘ union all select ‘hou’ , N ‘ 鱟 ‘ union all select ‘hu’ , N ‘ 鸌 ‘ union all select ‘hua’ , N ‘ 蘳 ‘ union all select ‘huai’ , N ‘ 蘾 ‘ union all select ‘huan’ , N ‘ 鰀 ‘ union all select ‘huang’ , N ‘ 鎤 ‘ union all select ‘hui’ , N ‘ 顪 ‘ union all select ‘hun’ , N ‘ 諢 ‘ union all select ‘huo’ , N ‘ 夻 ‘ union all select ‘ji’ , N ‘ 驥 ‘ union all select ‘jia’ , N ‘ 嗧 ‘ union all select ‘jian’ , N ‘ 鑳 ‘ union all select ‘jiang’ , N ‘ 謽 ‘ union all select ‘jiao’ , N ‘ 釂 ‘ union all select ‘jie’ , N ‘ 繲 ‘ union all select ‘jin’ , N ‘ 齽 ‘ union all select ‘jing’ , N ‘ 竸 ‘ union all select ‘jiong’ , N ‘ 蘔 ‘ union all select ‘jiu’ , N ‘ 欍 ‘ union all select ‘ju’ , N ‘ 爠 ‘ union all select ‘juan’ , N ‘ 羂 ‘ union all select ‘jue’ , N ‘ 钁 ‘ union all select ‘jun’ , N ‘ 攈 ‘ union all select ‘ka’ , N ‘ 鉲 ‘ union all select ‘kai’ , N ‘ 乫 ‘ -- 鎎乫 union all select ‘kan’ , N ‘ 矙 ‘ union all select ‘kang’ , N ‘ 閌 ‘ union all select ‘kao’ , N ‘ 鯌 ‘ union all select ‘ke’ , N ‘ 騍 ‘ union all select ‘ken’ , N ‘ 褃 ‘ union all select ‘keng’ , N ‘ 鏗 ‘ -- 巪乬唟厼怾 union all select ‘kong’ , N ‘ 廤 ‘ union all select ‘kou’ , N ‘ 鷇 ‘ union all select ‘ku’ , N ‘ 嚳 ‘ union all select ‘kua’ , N ‘ 骻 ‘ union all select ‘kuai’ , N ‘ 鱠 ‘ union all select ‘kuan’ , N ‘ 窾 ‘ union all select ‘kuang’ , N ‘ 鑛 ‘ union all select ‘kui’ , N ‘ 鑎 ‘ union all select ‘kun’ , N ‘ 睏 ‘ union all select ‘kuo’ , N ‘ 穒 ‘ union all select ‘la’ , N ‘ 鞡 ‘ union all select ‘lai’ , N ‘ 籟 ‘ union all select ‘lan’ , N ‘ 糷 ‘ union all select ‘lang’ , N ‘ 唥 ‘ union all select ‘lao’ , N ‘ 軂 ‘ union all select ‘le’ , N ‘ 餎 ‘ union all select ‘lei’ , N ‘ 脷 ‘ -- 嘞脷 union all select ‘leng’ , N ‘ 睖 ‘ union all select ‘li’ , N ‘ 瓈 ‘ union all select ‘lia’ , N ‘ 倆 ‘ union all select ‘lian’ , N ‘ 纞 ‘ union all select ‘liang’ , N ‘ 鍄 ‘ union all select ‘liao’ , N ‘ 瞭 ‘ union all select ‘lie’ , N ‘ 鱲 ‘ union all select ‘lin’ , N ‘ 轥 ‘ -- 轥拎 union all select ‘ling’ , N ‘ 炩 ‘ union all select ‘liu’ , N ‘ 咯 ‘ -- 瓼甅囖咯 union all select ‘long’ , N ‘ 贚 ‘ union all select ‘lou’ , N ‘ 鏤 ‘ union all select ‘lu’ , N ‘ 氇 ‘ union all select ‘lv’ , N ‘ 鑢 ‘ union all select ‘luan’ , N ‘ 亂 ‘ union all select ‘lue’ , N ‘ 擽 ‘ union all select ‘lun’ , N ‘ 論 ‘ union all select ‘luo’ , N ‘ 鱳 ‘ union all select ‘ma’ , N ‘ 嘛 ‘ union all select ‘mai’ , N ‘ 霢 ‘ union all select ‘man’ , N ‘ 蘰 ‘ union all select ‘mang’ , N ‘ 蠎 ‘ union all select ‘mao’ , N ‘ 唜 ‘ union all select ‘me’ , N ‘ 癦 ‘ -- 癦呅 union all select ‘mei’ , N ‘ 嚜 ‘ union all select ‘men’ , N ‘ 們 ‘ union all select ‘meng’ , N ‘ 霥 ‘ -- 霿踎 union all select ‘mi’ , N ‘ 羃 ‘ union all select ‘mian’ , N ‘ 麵 ‘ union all select ‘miao’ , N ‘ 廟 ‘ union all select ‘mie’ , N ‘ 鱴 ‘ -- 鱴瓱 union all select ‘min’ , N ‘ 鰵 ‘ union all select ‘ming’ , N ‘ 詺 ‘ union all select ‘miu’ , N ‘ 謬 ‘ union all select ‘mo’ , N ‘ 耱 ‘ -- 耱乮 union all select ‘mou’ , N ‘ 麰 ‘ -- 麰蟱 union all select ‘mu’ , N ‘ 旀 ‘ union all select ‘na’ , N ‘ 魶 ‘ union all select ‘nai’ , N ‘ 錼 ‘ union all select ‘nan’ , N ‘ 婻 ‘ union all select ‘nang’ , N ‘ 齉 ‘ union all select ‘nao’ , N ‘ 臑 ‘ union all select ‘ne’ , N ‘ 呢 ‘ union all select ‘nei’ , N ‘ 焾 ‘ -- 嫩焾 union all select ‘nen’ , N ‘ 嫩 ‘ union all select ‘neng’ , N ‘ 能 ‘ -- 莻嗯鈪銰啱 union all select ‘ni’ , N ‘ 嬺 ‘ union all select ‘nian’ , N ‘ 艌 ‘ union all select ‘niang’ , N ‘ 釀 ‘ union all select ‘niao’ , N ‘ 脲 ‘ union all select ‘nie’ , N ‘ 钀 ‘ union all select ‘nin’ , N ‘ 拰 ‘ union all select ‘ning’ , N ‘ 濘 ‘ union all select ‘niu’ , N ‘ 靵 ‘ union all select ‘nong’ , N ‘ 齈 ‘ union all select ‘nou’ , N ‘ 譳 ‘ union all select ‘nu’ , N ‘ 搙 ‘ union all select ‘nv’ , N ‘ 衄 ‘ union all select ‘nue’ , N ‘ 瘧 ‘ union all select ‘nuan’ , N ‘ 燶 ‘ -- 硸黁燶郍 union all select ‘nuo’ , N ‘ 桛 ‘ union all select ‘o’ , N ‘ 鞰 ‘ -- 毮夞乯鞰 union all select ‘ou’ , N ‘ 漚 ‘ union all select ‘pa’ , N ‘ 袙 ‘ union all select ‘pai’ , N ‘ 磗 ‘ -- 鎃磗 union all select ‘pan’ , N ‘ 鑻 ‘ union all select ‘pang’ , N ‘ 胖 ‘ union all select ‘pao’ , N ‘ 礮 ‘ union all select ‘pei’ , N ‘ 轡 ‘ union all select ‘pen’ , N ‘ 喯 ‘ union all select ‘peng’ , N ‘ 喸 ‘ -- 浌巼闏乶喸 union all select ‘pi’ , N ‘ 鸊 ‘ union all select ‘pian’ , N ‘ 騙 ‘ union all select ‘piao’ , N ‘ 慓 ‘ union all select ‘pie’ , N ‘ 嫳 ‘ union all select ‘pin’ , N ‘ 聘 ‘ union all select ‘ping’ , N ‘ 蘋 ‘ union all select ‘po’ , N ‘ 魄 ‘ union all select ‘pou’ , N ‘ 哛 ‘ -- 兺哛 union all select ‘pu’ , N ‘ 曝 ‘ union all select ‘qi’ , N ‘ 蟿 ‘ union all select ‘qia’ , N ‘ 髂 ‘ union all select ‘qian’ , N ‘ 縴 ‘ union all select ‘qiang’ , N ‘ 瓩 ‘ -- 羻兛瓩 union all select ‘qiao’ , N ‘ 躈 ‘ union all select ‘qie’ , N ‘ 籡 ‘ union all select ‘qin’ , N ‘ 藽 ‘ union all select ‘qing’ , N ‘ 櫦 ‘ union all select ‘qiong’ , N ‘ 瓗 ‘ union all select ‘qiu’ , N ‘ 糗 ‘ union all select ‘qu’ , N ‘ 覻 ‘ union all select ‘quan’ , N ‘ 勸 ‘ union all select ‘que’ , N ‘ 礭 ‘ union all select ‘qun’ , N ‘ 囕 ‘ union all select ‘ran’ , N ‘ 橪 ‘ union all select ‘rang’ , N ‘ 讓 ‘ union all select ‘rao’ , N ‘ 繞 ‘ union all select ‘re’ , N ‘ 熱 ‘ union all select ‘ren’ , N ‘ 餁 ‘ union all select ‘reng’ , N ‘ 陾 ‘ union all select ‘ri’ , N ‘ 馹 ‘ union all select ‘rong’ , N ‘ 穃 ‘ union all select ‘rou’ , N ‘ 嶿 ‘ union all select ‘ru’ , N ‘ 擩 ‘ union all select ‘ruan’ , N ‘ 礝 ‘ union all select ‘rui’ , N ‘ 壡 ‘ union all select ‘run’ , N ‘ 橍 ‘ -- 橍挼 union all select ‘ruo’ , N ‘ 鶸 ‘ union all select ‘sa’ , N ‘ 栍 ‘ -- 櫒栍 union all select ‘sai’ , N ‘ 虄 ‘ -- 簺虄 union all select ‘san’ , N ‘ 閐 ‘ union all select ‘sang’ , N ‘ 喪 ‘ union all select ‘sao’ , N ‘ 髞 ‘ union all select ‘se’ , N ‘ 飋 ‘ -- 裇聓 union all select ‘sen’ , N ‘ 篸 ‘ union all select ‘seng’ , N ‘ 縇 ‘ -- 閪縇 union all select ‘sha’ , N ‘ 霎 ‘ union all select ‘shai’ , N ‘ 曬 ‘ union all select ‘shan’ , N ‘ 鱔 ‘ union all select ‘shang’ , N ‘ 緔 ‘ union all select ‘shao’ , N ‘ 潲 ‘ union all select ‘she’ , N ‘ 欇 ‘ union all select ‘shen’ , N ‘ 瘮 ‘ union all select ‘sheng’ , N ‘ 賸 ‘ union all select ‘shi’ , N ‘ 瓧 ‘ -- 鰘齛兙瓧 union all select ‘shou’ , N ‘ 鏉 ‘ union all select ‘shu’ , N ‘ 虪 ‘ union all select ‘shua’ , N ‘ 誜 ‘ union all select ‘shuai’ , N ‘ 卛 ‘ union all select ‘shuan’ , N ‘ 腨 ‘ union all select ‘shuang’ , N ‘ 灀 ‘ union all select ‘shui’ , N ‘ 睡 ‘ union all select ‘shun’ , N ‘ 鬊 ‘ union all select ‘shuo’ , N ‘ 鑠 ‘ union all select ‘si’ , N ‘ 乺 ‘ -- 瀃螦乺 union all select ‘song’ , N ‘ 鎹 ‘ union all select ‘sou’ , N ‘ 瘶 ‘ union all select ‘su’ , N ‘ 鷫 ‘ union all select ‘suan’ , N ‘ 算 ‘ union all select ‘sui’ , N ‘ 鐩 ‘ union all select ‘sun’ , N ‘ 潠 ‘ union all select ‘suo’ , N ‘ 蜶 ‘ union all select ‘ta’ , N ‘ 襨 ‘ -- 躢襨 union all select ‘tai’ , N ‘ 燤 ‘ union all select ‘tan’ , N ‘ 賧 ‘ union all select ‘tang’ , N ‘ 燙 ‘ union all select ‘tao’ , N ‘ 畓 ‘ -- 討畓 union all select ‘te’ , N ‘ 蟘 ‘ union all select ‘teng’ , N ‘ 朰 ‘ -- 霯唞朰 union all select ‘ti’ , N ‘ 趯 ‘ union all select ‘tian’ , N ‘ 舚 ‘ union all select ‘tiao’ , N ‘ 糶 ‘ union all select ‘tie’ , N ‘ 餮 ‘ union all select ‘ting’ , N ‘ 乭 ‘ -- 濎乭 union all select ‘tong’ , N ‘ 憅 ‘ union all select ‘tou’ , N ‘ 透 ‘ union all select ‘tu’ , N ‘ 鵵 ‘ union all select ‘tuan’ , N ‘ 褖 ‘ union all select ‘tui’ , N ‘ 駾 ‘ union all select ‘tun’ , N ‘ 坉 ‘ union all select ‘tuo’ , N ‘ 籜 ‘ union all select ‘wa’ , N ‘ 韤 ‘ union all select ‘wai’ , N ‘ 顡 ‘ union all select ‘wan’ , N ‘ 贎 ‘ union all select ‘wang’ , N ‘ 朢 ‘ union all select ‘wei’ , N ‘ 躛 ‘ union all select ‘wen’ , N ‘ 璺 ‘ union all select ‘weng’ , N ‘ 齆 ‘ union all select ‘wo’ , N ‘ 齷 ‘ union all select ‘wu’ , N ‘ 鶩 ‘ union all select ‘xi’ , N ‘ 衋 ‘ union all select ‘xia’ , N ‘ 鏬 ‘ union all select ‘xian’ , N ‘ 鼸 ‘ union all select ‘xiang’ , N ‘ 鱌 ‘ union all select ‘xiao’ , N ‘ 斆 ‘ union all select ‘xie’ , N ‘ 躞 ‘ union all select ‘xin’ , N ‘ 釁 ‘ union all select ‘xing’ , N ‘ 臖 ‘ union all select ‘xiong’ , N ‘ 敻 ‘ union all select ‘xiu’ , N ‘ 齅 ‘ union all select ‘xu’ , N ‘ 蓿 ‘ union all select ‘xuan’ , N ‘ 贙 ‘ union all select ‘xue’ , N ‘ 瀥 ‘ union all select ‘xun’ , N ‘ 鑂 ‘ union all select ‘ya’ , N ‘ 齾 ‘ union all select ‘yan’ , N ‘ 灩 ‘ union all select ‘yang’ , N ‘ 樣 ‘ union all select ‘yao’ , N ‘ 鑰 ‘ union all select ‘ye’ , N ‘ 岃 ‘ -- 鸈膶岃 union all select ‘yi’ , N ‘ 齸 ‘ union all select ‘yin’ , N ‘ 檼 ‘ union all select ‘ying’ , N ‘ 譍 ‘ union all select ‘yo’ , N ‘ 喲 ‘ union all select ‘yong’ , N ‘ 醟 ‘ union all select ‘you’ , N ‘ 鼬 ‘ union all select ‘yu’ , N ‘ 爩 ‘ union all select ‘yuan’ , N ‘ 願 ‘ union all select ‘yue’ , N ‘ 鸙 ‘ union all select ‘yun’ , N ‘ 韻 ‘ union all select ‘za’ , N ‘ 雥 ‘ union all select ‘zai’ , N ‘ 縡 ‘ union all select ‘zan’ , N ‘ 饡 ‘ union all select ‘zang’ , N ‘ 臟 ‘ union all select ‘zao’ , N ‘ 竈 ‘ union all select ‘ze’ , N ‘ 稄 ‘ union all select ‘zei’ , N ‘ 鱡 ‘ union all select ‘zen’ , N ‘ 囎 ‘ union all select ‘zeng’ , N ‘ 贈 ‘ union all select ‘zha’ , N ‘ 醡 ‘ union all select ‘zhai’ , N ‘ 瘵 ‘ union all select ‘zhan’ , N ‘ 驏 ‘ union all select ‘zhang’ , N ‘ 瞕 ‘ union all select ‘zhao’ , N ‘ 羄 ‘ union all select ‘zhe’ , N ‘ 鷓 ‘ union all select ‘zhen’ , N ‘ 黮 ‘ union all select ‘zheng’ , N ‘ 證 ‘ union all select ‘zhi’ , N ‘ 豒 ‘ union all select ‘zhong’ , N ‘ 諥 ‘ union all select ‘zhou’ , N ‘ 驟 ‘ union all select ‘zhu’ , N ‘ 鑄 ‘ union all select ‘zhua’ , N ‘ 爪 ‘ union all select ‘zhuai’ , N ‘ 跩 ‘ union all select ‘zhuan’ , N ‘ 籑 ‘ union all select ‘zhuang’ , N ‘ 戅 ‘ union all select ‘zhui’ , N ‘ 鑆 ‘ union all select ‘zhun’ , N ‘ 稕 ‘ union all select ‘zhuo’ , N ‘ 籱 ‘ union all select ‘zi’ , N ‘ 漬 ‘ -- 漬唨 union all select ‘zong’ , N ‘ 縱 ‘ union all select ‘zou’ , N ‘ 媰 ‘ union all select ‘zu’ , N ‘ 謯 ‘ union all select ‘zuan’ , N ‘ 攥 ‘ union all select ‘zui’ , N ‘ 欈 ‘ union all select ‘zun’ , N ‘ 銌 ‘ union all select ‘zuo’ , N ‘ 咗 ‘ ) t where word &gt;= @word collate Chinese_PRC_CS_AS_KS_WS order by word collate Chinese_PRC_CS_AS_KS_WS ASC ) else @word end ) set @i = @i + 1 end return @pinyin END GO -- 测试示例 SELECT dbo . fn_GetPinyin ( ‘ 欢迎访问叶子的博客 ‘ ) -- 运行结果 /* huan ying fang wen ye zi de bo ke */","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itchina.top/categories/数据库/"}],"tags":[{"name":"sql server","slug":"sql-server","permalink":"https://www.itchina.top/tags/sql-server/"},{"name":"汉字转拼音","slug":"汉字转拼音","permalink":"https://www.itchina.top/tags/汉字转拼音/"}]},{"title":"Spring boot 使用Druid数据源","slug":"Spring boot 使用Druid数据源","date":"2018-04-19T16:34:21.442Z","updated":"2018-04-19T16:29:54.771Z","comments":true,"path":"2018/04/20/Spring boot 使用Druid数据源/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring boot 使用Druid数据源/","excerpt":"","text":"Druid 为监控而生的数据库连接池 由于工作需要，最近一个项目是Spring Boot架构的需要使用Druid作为数据源，所以整理了这样一篇文章 废话不多说，现在开始表演。 Druid Spring Boot Starter 用于在Spring Boot项目中轻松集成Druid数据库连接池和监控。 如何使用 在 Spring Boot 项目中加入 druid-spring-boot-starter 依赖 maven: com.alibaba druid-spring-boot-starter 1.1.6 Gradle:compile ‘com.alibaba:druid-spring-boot-starter:1.1.6’ 添加配置 spring.datasource.url=spring.datasource.username=spring.datasource.password=#其他配置（可选，不是必须的) 配置属性Druid Spring Boot Starter 配置属性的名称完全遵照 Druid，你可以通过 Spring Boot配置文件来配置Druid数据库连接池和监控，如果没有配置则使用默认值。 JDBC 配置 spring.datasource.druid.url= # 或spring.datasource.url= spring.datasource.druid.username= # 或spring.datasource.username= spring.datasource.druid.password= # 或spring.datasource.password= spring.datasource.druid.driver-class-name= #或 spring.datasource.driver-class-name= 连接池配置 spring.datasource.druid.initial-size= spring.datasource.druid.max-active= spring.datasource.druid.min-idle= spring.datasource.druid.max-wait= spring.datasource.druid.pool-prepared-statements= spring.datasource.druid.max-pool-prepared-statement-per-connection-size= spring.datasource.druid.max-open-prepared-statements= #和上面的等价 spring.datasource.druid.validation-query= spring.datasource.druid.validation-query-timeout= spring.datasource.druid.test-on-borrow= spring.datasource.druid.test-on-return= spring.datasource.druid.test-while-idle= spring.datasource.druid.time-between-eviction-runs-millis= spring.datasource.druid.min-evictable-idle-time-millis= spring.datasource.druid.max-evictable-idle-time-millis= spring.datasource.druid.filters= #配置多个英文逗号分隔 监控配置 # WebStatFilter配置，说明请参考Druid Wiki，配置_配置WebStatFilter spring.datasource.druid.web-stat-filter.enabled= #是否启用StatFilter默认值true spring.datasource.druid.web-stat-filter.url-pattern= spring.datasource.druid.web-stat-filter.exclusions= spring.datasource.druid.web-stat-filter.session-stat-enable= spring.datasource.druid.web-stat-filter.session-stat-max-count= spring.datasource.druid.web-stat-filter.principal-session-name= spring.datasource.druid.web-stat-filter.principal-cookie-name= spring.datasource.druid.web-stat-filter.profile-enable= # StatViewServlet配置，说明请参考Druid Wiki，配置_StatViewServlet配置 spring.datasource.druid.stat-view-servlet.enabled= #是否启用StatViewServlet默认值true spring.datasource.druid.stat-view-servlet.url-pattern= spring.datasource.druid.stat-view-servlet.reset-enable= spring.datasource.druid.stat-view-servlet.login-username= spring.datasource.druid.stat-view-servlet.login-password= spring.datasource.druid.stat-view-servlet.allow= spring.datasource.druid.stat-view-servlet.deny= # Spring监控配置，说明请参考Druid Github Wiki，配置_Druid和Spring关联监控配置 spring.datasource.druid.aop-patterns= # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 # 如果spring.datasource.druid.aop-patterns要代理的类没有定义interface请设置spring.aop.proxy-target-class=true Druid Spring Boot Starter 不仅限于对以上配置属性提供支持， [ DruidDataSource ](https://gith ub.com/alibaba/druid/blob/master/src/main/java/com/alibaba/druid/pool/DruidDat aSource.java) 内提供 setter方法的可配置属性都将被支持。你可以参考WIKI文档或通过IDE输入提示来进行配置。配置文件的格式你可以选择 .properties 或 .yml ，效果是一样的，在配置较多的情况下推荐使用 .yml 。 如何配置多数据源 添加配置 spring.datasource.url=spring.datasource.username=spring.datasource.password= Druid 数据源配置，继承spring.datasource.* 配置，相同则覆盖…spring.datasource.druid.initial-size=5spring.datasource.druid.max-active=5… Druid 数据源 1 配置，继承spring.datasource.druid.* 配置，相同则覆盖…spring.datasource.druid.one.max-active=10spring.datasource.druid.one.max-wait=10000… Druid 数据源 2 配置，继承spring.datasource.druid.* 配置，相同则覆盖…spring.datasource.druid.two.max-active=20spring.datasource.druid.two.max-wait=20000… 创建数据源 @Primary@Bean@ConfigurationProperties(“spring.datasource.druid.one”)public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build();}@Bean@ConfigurationProperties(“spring.datasource.druid.two”)public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build();} 如何配置 Filter你可以通过 spring.datasource.druid.filters=stat,wall,log4j ... 的方式来启用相应的内置Filter，不过这些Filter都是默认配置。如果默认配置不能满足你的需求，你可以放弃这种方式，通过配置文件来配置Filter，下面是例子。 # 配置StatFilter spring.datasource.druid.filter.stat.db-type=h2 spring.datasource.druid.filter.stat.log-slow-sql=true spring.datasource.druid.filter.stat.slow-sql-millis=2000 # 配置WallFilter spring.datasource.druid.filter.wall.enabled=true spring.datasource.druid.filter.wall.db-type=h2 spring.datasource.druid.filter.wall.config.delete-allow=false spring.datasource.druid.filter.wall.config.drop-table-allow=false 目前为以下 Filter 提供了配置支持，请参考文档或者根据IDE提示（ spring.datasource.druid.filter.*）进行配置。 * StatFilter * WallFilter * ConfigFilter * EncodingConvertFilter * Slf4jLogFilter * Log4jFilter * Log4j2Filter * CommonsLogFilter 要想使自定义 Filter 配置生效需要将对应 Filter 的 enabled 设置为 true ，Druid Spring BootStarter 默认会启用 StatFilter，你也可以将其 enabled 设置为 false 来禁用它。 参考文档： Druid Wiki Spring Boot Reference","categories":[{"name":"J2EE","slug":"J2EE","permalink":"https://www.itchina.top/categories/J2EE/"},{"name":"Spring","slug":"J2EE/Spring","permalink":"https://www.itchina.top/categories/J2EE/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://www.itchina.top/tags/Spring-Boot/"},{"name":"Druid","slug":"Druid","permalink":"https://www.itchina.top/tags/Druid/"}]},{"title":"Spring Boot 事务的使用","slug":"Spring Boot 事务的使用","date":"2018-04-19T16:34:21.442Z","updated":"2018-04-19T16:30:06.054Z","comments":true,"path":"2018/04/20/Spring Boot 事务的使用/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 事务的使用/","excerpt":"","text":"Spring Boot 使用事务非常简单，首先使用注解 @EnableTransactionManagement 开启事务支持后，然后在访问 数据库 的Service方法上添加注解 @Transactional 便可。 关于事务管理器，不管是JPA还是JDBC等都实现自接口 PlatformTransactionManager 如果你添加的是 spring-boot-starter-jdbc 依赖，框架会默认注入 DataSourceTransactionManager 实例。如果你添加的是 spring-boot-starter-data-jpa 依赖，框架会默认注入 JpaTransactionManager 实例。 你可以在启动类中添加如下方法，Debug测试，就能知道自动注入的是 PlatformTransactionManager 接口的哪个实现类。 @EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 &lt;tx:annotation-driven /&gt; @SpringBootApplication public class ProfiledemoApplication { @Bean public Object testBean(PlatformTransactionManager platformTransactionManager){ System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + platformTransactionManager.getClass().getName()); return new Object(); } public static void main(String[] args) { SpringApplication.run(ProfiledemoApplication.class, args); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 这些SpringBoot为我们自动做了，这些对我们并不透明，如果你项目做的比较大，添加的持久化依赖比较多，我们还是会选择人为的指定使用哪个事务管理器。代码如下： @EnableTransactionManagement @SpringBootApplication public class ProfiledemoApplication { // 其中 dataSource 框架会自动为我们注入 @Bean public PlatformTransactionManager txManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } @Bean public Object testBean(PlatformTransactionManager platformTransactionManager) { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + platformTransactionManager.getClass().getName()); return new Object(); } public static void main(String[] args) { SpringApplication.run(ProfiledemoApplication.class, args); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 在Spring容器中，我们手工注解@Bean 将被优先加载，框架不会重新实例化其他的 PlatformTransactionManager 实现类。 然后在Service中，被 @Transactional 注解的方法，将支持事务。如果注解在类上，则整个类的所有方法都默认支持事务。 对于同一个工程中存在多个事务管理器要怎么处理，请看下面的实例，具体说明请看代码中的注释。 @EnableTransactionManagement // 开启注解事务管理，等同于xml配置文件中的 &lt;tx:annotation-driven /&gt; @SpringBootApplication public class ProfiledemoApplication implements TransactionManagementConfigurer { @Resource(name=&quot;txManager2&quot;) private PlatformTransactionManager txManager2; // 创建事务管理器1 @Bean(name = &quot;txManager1&quot;) public PlatformTransactionManager txManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } // 创建事务管理器2 @Bean(name = &quot;txManager2&quot;) public PlatformTransactionManager txManager2(EntityManagerFactory factory) { return new JpaTransactionManager(factory); } // 实现接口 TransactionManagementConfigurer 方法，其返回值代表在拥有多个事务管理器的情况下默认使用的事务管理器 @Override public PlatformTransactionManager annotationDrivenTransactionManager() { return txManager2; } public static void main(String[] args) { SpringApplication.run(ProfiledemoApplication.class, args); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Component public class DevSendMessage implements SendMessage { // 使用value具体指定使用哪个事务管理器 @Transactional(value=&quot;txManager1&quot;) @Override public void send() { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Dev Send()&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); send2(); } // 在存在多个事务管理器的情况下，如果使用value具体指定 // 则默认使用方法 annotationDrivenTransactionManager() 返回的事务管理器 @Transactional public void send2() { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Dev Send2()&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 注：如果Spring容器中存在多个 PlatformTransactionManager 实例，并且没有实现接口TransactionManagementConfigurer 指定默认值，在我们在方法上使用注解 @Transactional的时候，就必须要用value指定，如果不指定，则会抛出异常。 对于系统需要提供默认事务管理的情况下，实现接口 TransactionManagementConfigurer 指定。 对有的系统，为了避免不必要的问题，在业务中必须要明确指定 @Transactional 的 value 值的情况下。不建议实现接口TransactionManagementConfigurer，这样控制台会明确抛出异常，开发人员就不会忘记主动指定。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot 入门","slug":"Spring Boot 入门","date":"2018-04-19T16:34:21.441Z","updated":"2018-04-19T16:30:15.478Z","comments":true,"path":"2018/04/20/Spring Boot 入门/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 入门/","excerpt":"","text":"一、简介 Spring 官方网站本身使用Spring 框架开发，随着功能以及业务逻辑的日益复杂，应用伴随着大量的XML配置文件以及复杂的Bean依赖关系。随着Spring 3.0的发布，Spring IO团队主键开始摆脱XML配置文件，并且在开发过程中大量使用“约定优先配置”（convention overconfiguration）的思想来摆脱Spring框架中各种复杂的配置，衍生了 Java Config。 Spring Boot正是在这样的一个背景下被抽象出来的开发框架，它本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置（例如Jackson, JDBC, Mongo, Redis, Mail等等），SpringBoot应用中这些第三方库几乎可以零配置的开箱即用（out-of-the-box），大部分的SpringBoot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。 该项目旨在帮助开发者更容易地创建基于Spring的应用程序和服务，使得现有的和新的Spring开发者能够最快速地获得所需要的Spring功能。 Spring Boot不生成代码，且完全不需要XML配置。其主要目标如下：- 为所有的Spring开发工作提供一个更快、更广泛的入门经验。- 开箱即用，你也可以通过修改默认值来快速满足你的项目的需求。- 提供了一系列大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。 博主准备写一组 Spring-Boot 入门的帖子，仅为了抛砖引玉，让需要的同学可以尽快了解如何使用Spring-Boot，内容参考官网和网上的资料（ http://projects.spring.io/spring-boot/ ）。 开发工具：Spring Tool Suite v_3.7.2（简称STS）官网地址： http://spring.io/tools/sts 二、入门实例 - HelloWorld File &gt; New &gt; Spring Starter Project Next &gt; Finish 项目创建完成： 可以看出，项目源码就一个Java类，在pom.xml中有spring-boot-starter-web的依赖。 SpringBootSampleApplication.java package org.springboot.sample; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class SpringBootSampleApplication { public static void main(String[] args) { SpringApplication.run(SpringBootSampleApplication.class, args); } } 1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6 7 8 9 10 11 12 pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.springboot.sample&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-sample&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-sample&lt;/name&gt; &lt;description&gt;Spring Boot Sample Web Application&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 这样就完成了项目的创建，下面我们创建一个 HelloController.java 定义3个方法 package org.springboot.sample.controller; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(&quot;/hello&quot;) public class HelloController { @RequestMapping public String hello() { return &quot;Hello Spring-Boot&quot;; } @RequestMapping(&quot;/info&quot;) public Map&lt;String, String&gt; getInfo(@RequestParam String name) { Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, name); return map; } @RequestMapping(&quot;/list&quot;) public List&lt;Map&lt;String, String&gt;&gt; getList() { List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;(); Map&lt;String, String&gt; map = null; for (int i = 1; i &lt;= 5; i++) { map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, &quot;Shanhy-&quot; + i); list.add(map); } return list; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 然后现在可以直接运行 SpringBootSampleApplication 的main方法，和执行普通java程序一样。然后可以看到spring-boot 内置server容器（默认为Tomcat），这一切spring-boot 都帮我们做好了。 控制台输出内容 Started SpringBootSampleApplication in 7.358 seconds (JVM running for9.154) 表示服务已经启动。 在浏览器输入我们3个请求便可看到结果。 http://localhost:8080/hello 输出：Hello Spring-Boot http://localhost:8080/hello/info?name=shanhy 输出：{“name”:”shanhy”} http://localhost:8080/hello/list 输出：[{“name”:”Shanhy-1”},{“name”:”Shanhy-2”},{“name”:”Shanhy-3”},{“name”:”Shanhy-4”},{“name”:”Shanhy-5”}] 通过我们的Hello实例，相信大家一目了然，可谓spring-boot创建一个项目如此简单，完全可以在几分钟内将服务启动。spring-boot抛弃繁琐的配置，让开发人员更专注与业务逻辑的实现。后面几篇文章将会对spring-boot的多个方面通过实例的方式呈现给大家。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot 启动加载数据 CommandLineRunner","slug":"Spring Boot 启动加载数据 CommandLineRunner","date":"2018-04-19T16:34:21.440Z","updated":"2018-04-19T16:30:11.913Z","comments":true,"path":"2018/04/20/Spring Boot 启动加载数据 CommandLineRunner/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 启动加载数据 CommandLineRunner/","excerpt":"","text":"实际应用中，我们会有在项目服务启动的时候就去加载一些数据或做一些事情这样的需求。为了解决这样的问题，Spring Boot 为我们提供了一个方法，通过实现接口 CommandLineRunner 来实现。 很简单，只需要一个类就可以，无需其他配置。创建实现接口 CommandLineRunner 的类 package org.springboot.sample.runner; import org.springframework.boot.CommandLineRunner; import org.springframework.stereotype.Component; /** * 服务启动执行 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月9日 */ @Component public class MyStartupRunner1 implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Spring Boot应用程序在启动后，会遍历CommandLineRunner接口的实例并运行它们的run方法。也可以利用@Order注解（或者实现Order接口）来规定所有CommandLineRunner实例的运行顺序。 如下我们使用@Order 注解来定义执行顺序。 package org.springboot.sample.runner; import org.springframework.boot.CommandLineRunner; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; /** * 服务启动执行 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月9日 */ @Component @Order(value=2) public class MyStartupRunner1 implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作 11111111 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package org.springboot.sample.runner; import org.springframework.boot.CommandLineRunner; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; /** * 服务启动执行 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月9日 */ @Component @Order(value=1) public class MyStartupRunner2 implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作 22222222 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 启动程序后，控制台输出结果为： &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作 22222222 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作 11111111 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 1 2 1 2 根据控制台结果可判断，@Order 注解的执行优先级是按value值从小到大顺序。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot 日志记录 SLF4J","slug":"Spring Boot 日志记录 SLF4J","date":"2018-04-19T16:34:21.440Z","updated":"2018-04-19T16:30:11.549Z","comments":true,"path":"2018/04/20/Spring Boot 日志记录 SLF4J/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 日志记录 SLF4J/","excerpt":"","text":"在开发中打印内容，使用 System.out.println() 和 Log4j 应当是人人皆知的方法了。其实在开发中我们不建议使用 System.out 因为大量的使用 System.out 会增加资源的消耗。而Log4j 更为灵活在性能上也相比 System.out 要高，我们可以配置输出级别，可以指定多个日志文件分别记录不同的日志。使用 System.out 是在当前线程执行的，写入文件也是写入完毕后才继续执行下面的程序。而使用Log工具不但可以控制日志是否输出，怎么输出，它的处理机制也是通知写日志，继续执行后面的代码不必等日志写完。如非必要，建议大家不要使用控制台输出，因为控制台输出没有优先级会显得输出太乱。 个人推荐使用 SLF4J（Simple Logging Facade For Java ）的logback来输出日志，其比log4j 要好，因为他效率更高。 Spring Boot 提供了一套日志系统，logback是最优先的选择。配置了logback.xml可以利用Spring Boot提供的默认日志配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/base.xml&quot;/&gt; &lt;logger name=&quot;org.springframework.web&quot; level=&quot;DEBUG&quot;/&gt; &lt;/configuration&gt; 1 2 3 4 5 1 2 3 4 5 这样就定义了一个 捕获 org.springframework.web 的日志，日志级别是 DEBUG，上面引用的base.xml 文件内容为： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- Base logback configuration provided for compatibility with Spring Boot 1.1 --&gt; &lt;included&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt; &lt;property name=&quot;LOG_FILE&quot; value=&quot;${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}/}spring.log}&quot;/&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/console-appender.xml&quot; /&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/file-appender.xml&quot; /&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/root&gt; &lt;/included&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Spring Boot的日志系统预先定义了一些系统变量： P I D ， 当 前 进 程 I D {PID}，当前进程ID {LOG_FILE}，SpringBoot配置文件（application.properties|.yml）中logging.file的值${LOG_PATH}, Spring Boot配置文件中logging.path的值同时默认情况下包含另个appender——一个是控制台，一个是文件，分别定义在console-appender.xml和file-appender.xml中。同时对于应用的日志级别也可以通过application.properties进行定义： logging.level.org.springframework.web=DEBUG logging.level.org.springboot.sample=TRACE 1 2 1 2 这样相当于我们在logback.xml 中配置的对应的日志级别。名称以logging.level开头，后面跟要输入日志的包名。 _ 如果在 logback.xml 和 application.properties 中定义了相同的配置（如都配置了org.springframework.web）但是输出级别不同，则实际上 application.properties 的优先级高于logback.xml _ 我们既然使用了maven来管理项目，我们就可以根据不同环境来定义不同的日志输出，在 logback-spring.xml 中使用 springProfile节点来定义，方法如下：注意文件名称不是logback.xml，想使用spring扩展profile支持，要以logback-spring.xml命名 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/base.xml&quot; /&gt; &lt;logger name=&quot;org.springframework.web&quot; level=&quot;INFO&quot;/&gt; &lt;logger name=&quot;org.springboot.sample&quot; level=&quot;TRACE&quot; /&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;logger name=&quot;org.springboot.sample&quot; level=&quot;DEBUG&quot; /&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;staging&quot;&gt; &lt;logger name=&quot;org.springboot.sample&quot; level=&quot;INFO&quot; /&gt; &lt;/springProfile&gt; &lt;/configuration&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 如上我们默认为 org.springboot.sample 定义了TRACE级别的输出，下面又定义两个 springProfile ，分别是 dev 和staging，输出级别分别是 DEBUG 和 INFO我们可以启动服务的时候指定 profile （如不指定使用默认），如指定staging 的方式为： java -jar myapp.jar --spring.profiles.active=staging 1 1 下面介绍两种常用的Appender ConsoleAppenderLogback使用appender来定义日志输出，在开发过程中最常用的是将日志输出到控制台： &lt;appender name=&quot;consoleAppender&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;Pattern&gt;.%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg %n&lt;/Pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;TRACE&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 表示对日志进行编码 %d{HH:mm:ss.SSS}——日志输出时间 %thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用 %-5level——日志级别，并且使用5个字符靠左对齐 %logger{36}——日志输出者的名字 %msg——日志消息 %n——平台的换行符 在这种格式下一条日志的输出结果如下： 10:12:51.012 [threadName] DEBUG o.c.d.r.util.LoggingResponseFilter 1 1 RollingFileAppender另一种常见的日志输出到文件，随着应用的运行时间越来越长，日志也会增长的越来越多，将他们输出到同一个文件并非一个好办法。RollingFileAppender用于切分文件日志： &lt;appender name=&quot;dailyRollingFileAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;File&gt;/data/log/app.log&lt;/File&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- daily rollover --&gt; &lt;FileNamePattern&gt;rest-demo.%d{yyyy-MM-dd}.log&lt;/FileNamePattern&gt; &lt;!-- keep 30 days&apos; worth of history --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;Pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{35} - %msg %n&lt;/Pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; 1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6 7 8 9 10 11 12 其中重要的是rollingPolicy的定义，上例中rest-demo.%d{yyyy-MM-dd}.log定义了日志的切分方式——把每一天的日志归档到一个文件中，30表示只保留最近30天的日志，以防止日志填满整个磁盘空间。同理，可以使用%d{yyyy-MM-dd_HH-mm}来定义精确到分的日志切分方式。 SentrySentry是一个统一的日志跟踪平台，在传统的日志管理中，都是在服务器上通过tail, vim等工具查看日志，并且不同的日志位置也个不相同，而Sentry则是将这些日志（主要是错误日志）通过统一的接口收集起来，并且提供跟踪、管理的功能，使得应用程序的错误、Bug能够即时被解决。 Sentry提供了Java库——RavenJava，Java应用程序能够在捕获异常后将其发送到Sentry服务器中，另一方面它包含了各类日志框架的支持，以Logbakc为例： &lt;dependency&gt; &lt;groupId&gt;net.kencochrane.raven&lt;/groupId&gt; &lt;artifactId&gt;raven-logback&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt; &lt;/dependency&gt; 1 2 3 4 5 1 2 3 4 5 在logback.xml中定义appender： &lt;configuration&gt; &lt;appender name=&quot;Sentry&quot; class=&quot;net.kencochrane.raven.logback.SentryAppender&quot;&gt; &lt;dsn&gt;https://publicKey:secretKey@host:port/1?options&lt;/dsn&gt; &lt;tags&gt;tag1:value1,tag2:value2&lt;/tags&gt; &lt;!-- Optional, allows to select the ravenFactory --&gt; &lt;!--&lt;ravenFactory&gt;net.kencochrane.raven.DefaultRavenFactory&lt;/ravenFactory&gt;--&gt; &lt;/appender&gt; &lt;root level=&quot;warn&quot;&gt; &lt;appender-ref ref=&quot;Sentry&quot;/&gt; &lt;/root&gt; &lt;/configuration&gt; 1 2 3 4 5 6 7 8 9 10 11 1 2 3 4 5 6 7 8 9 10 11 我们推荐在这个中加入用于过滤 ERROR 级别的日志。 总结在Spring Boot 中记录日志只需两步：1、在 src/main/resources 下面创建logback.xml 文件，并按上面讲述的进行配置。或者使用最简单的方法在 application 配置文件中配置。2、在Java代码中创建实例，并在需要输出日志的地方使用。 // 在Java类中创建 logger 实例 private static final Logger logger = LoggerFactory.getLogger(SpringBootSampleApplication.class); // 在方法中使用日志输出，如 public void logTest() { logger.debug(&quot;日志输出测试 Debug&quot;); logger.trace(&quot;日志输出测试 Trace&quot;); logger.info(&quot;日志输出测试 Info&quot;); } 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot 拦截器","slug":"Spring Boot 拦截器","date":"2018-04-19T16:34:21.439Z","updated":"2018-04-19T16:30:12.925Z","comments":true,"path":"2018/04/20/Spring Boot 拦截器/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 拦截器/","excerpt":"","text":"上一篇对过滤器的定义做了说明，也比较简单。过滤器属于Servlet范畴的API，与Spring 没什么关系。Web开发中，我们除了使用 Filter 来过滤请web求外，还可以使用Spring提供的HandlerInterceptor（拦截器）。 HandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request内容，但是可以通过抛出异常（或者返回false）来暂停request的执行。 实现 UserRoleAuthorizationInterceptor 的拦截器有：ConversionServiceExposingInterceptorCorsInterceptorLocaleChangeInterceptorPathExposingHandlerInterceptorResourceUrlProviderExposingInterceptorThemeChangeInterceptorUriTemplateVariablesHandlerInterceptorUserRoleAuthorizationInterceptor 其中 LocaleChangeInterceptor 和 ThemeChangeInterceptor 比较常用。 配置拦截器也很简单，Spring 为什么提供了基础类WebMvcConfigurerAdapter ，我们只需要重写 addInterceptors方法添加注册拦截器。 实现自定义拦截器只需要3步：1、创建我们自己的拦截器类并实现 HandlerInterceptor 接口。2、创建一个 Java 类继承WebMvcConfigurerAdapter，并重写addInterceptors 方法。2、实例化我们自定义的拦截器，然后将对像手动添加到拦截器链中（在addInterceptors方法中添加）。PS：本文重点在如何在Spring-Boot中使用拦截器，关于拦截器的原理请大家查阅资料了解。 代码示例： MyInterceptor1.java package org.springboot.sample.interceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; /** * 自定义拦截器1 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月7日 */ public class MyInterceptor1 implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;&gt;&gt;&gt;MyInterceptor1&gt;&gt;&gt;&gt;&gt;&gt;&gt;在请求处理之前进行调用（Controller方法调用之前）&quot;); return true;// 只有返回true才会继续向下执行，返回false取消当前请求 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;&gt;&gt;&gt;MyInterceptor1&gt;&gt;&gt;&gt;&gt;&gt;&gt;请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）&quot;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;&gt;&gt;&gt;MyInterceptor1&gt;&gt;&gt;&gt;&gt;&gt;&gt;在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作）&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 MyInterceptor2.java package org.springboot.sample.interceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; /** * 自定义拦截器2 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月7日 */ public class MyInterceptor2 implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;&gt;&gt;&gt;MyInterceptor2&gt;&gt;&gt;&gt;&gt;&gt;&gt;在请求处理之前进行调用（Controller方法调用之前）&quot;); return true;// 只有返回true才会继续向下执行，返回false取消当前请求 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;&gt;&gt;&gt;MyInterceptor2&gt;&gt;&gt;&gt;&gt;&gt;&gt;请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）&quot;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;&gt;&gt;&gt;MyInterceptor2&gt;&gt;&gt;&gt;&gt;&gt;&gt;在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作）&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 MyWebAppConfigurer.java package org.springboot.sample.config; import org.springboot.sample.interceptor.MyInterceptor1; import org.springboot.sample.interceptor.MyInterceptor2; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; @Configuration public class MyWebAppConfigurer extends WebMvcConfigurerAdapter { @Override public void addInterceptors(InterceptorRegistry registry) { // 多个拦截器组成一个拦截器链 // addPathPatterns 用于添加拦截规则 // excludePathPatterns 用户排除拦截 registry.addInterceptor(new MyInterceptor1()).addPathPatterns(&quot;/**&quot;); registry.addInterceptor(new MyInterceptor2()).addPathPatterns(&quot;/**&quot;); super.addInterceptors(registry); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 然后在浏览器输入地址： http://localhost:8080/index 后，控制台的输出为： &gt;&gt;&gt;MyInterceptor1&gt;&gt;&gt;&gt;&gt;&gt;&gt;在请求处理之前进行调用（Controller方法调用之前） &gt;&gt;&gt;MyInterceptor2&gt;&gt;&gt;&gt;&gt;&gt;&gt;在请求处理之前进行调用（Controller方法调用之前） &gt;&gt;&gt;MyInterceptor2&gt;&gt;&gt;&gt;&gt;&gt;&gt;请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后） &gt;&gt;&gt;MyInterceptor1&gt;&gt;&gt;&gt;&gt;&gt;&gt;请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后） &gt;&gt;&gt;MyInterceptor2&gt;&gt;&gt;&gt;&gt;&gt;&gt;在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作） &gt;&gt;&gt;MyInterceptor1&gt;&gt;&gt;&gt;&gt;&gt;&gt;在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作） 1 2 3 4 5 6 1 2 3 4 5 6 根据输出可以了解拦截器链的执行顺序（具体原理介绍，大家找度娘一问便知） 最后强调一点：只有经过DispatcherServlet 的请求，才会走拦截器链，我们自定义的Servlet请求是不会被拦截的，比如我们自定义的Servlet地址 http://localhost:8080/xs/myservlet 是不会被拦截器拦截的。并且不管是属于哪个Servlet只要复合过滤器的过滤规则，过滤器都会拦截。 最后说明下，我们上面用到的 WebMvcConfigurerAdapter 并非只是注册添加拦截器使用，其顾名思义是做Web配置用的，它还可以有很多其他作用，通过下面截图便可以大概了解，具体每个方法都是干什么用的，留给大家自己研究（其实都大同小异也很简单）。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot 静态资源处理","slug":"Spring Boot 静态资源处理","date":"2018-04-19T16:34:21.438Z","updated":"2018-04-19T16:30:12.414Z","comments":true,"path":"2018/04/20/Spring Boot 静态资源处理/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 静态资源处理/","excerpt":"","text":"Spring Boot 默认为我们提供了静态资源处理，使用 WebMvcAutoConfiguration 中的配置各种属性。 建议大家使用Spring Boot的默认配置方式，如果需要特殊处理的再通过配置进行修改。 如果想要自己完全控制WebMVC，就需要在@Configuration注解的配置类上增加@EnableWebMvc（@SpringBootApplication 注解的程序入口类已经包含@Configuration），增加该注解以后WebMvcAutoConfiguration中配置就不会生效，你需要自己来配置需要的每一项。这种情况下的配置还是要多看一下WebMvcAutoConfiguration类。 我们既然是快速使用Spring Boot，并不想过多的自己再重新配置。本文还是主要针对Spring Boot的默认处理方式，部分配置在application配置文件中（.properties 或 .yml） 默认资源映射我们在启动应用的时候，可以在控制台中看到如下信息： 2016-01-08 09:29:30.362 INFO 24932 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2016-01-08 09:29:30.362 INFO 24932 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2016-01-08 09:29:30.437 INFO 24932 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 1 2 3 1 2 3 其中默认配置的 / 映射到 /static （或/public、/resources、/META-INF/resources）其中默认配置的 /webjars/ 映射到 classpath:/META-INF/resources/webjars/PS：上面的 static、public、resources 等目录都在 classpath: 下面（如src/main/resources/static）。 如果我按如下结构存放相同名称的图片，那么Spring Boot 读取图片的优先级是怎样的呢？如下图： 当我们访问地址 http://localhost:8080/fengjing.jpg 的时候，显示哪张图片？这里博主可以直接告诉大家，优先级顺序为：META/resources &gt; resources &gt; static &gt; public如果我们想访问pic2.jpg，请求地址 http://localhost:8080/img/pic2.jpg 自定义资源映射上面我们介绍了Spring Boot 的默认资源映射，一般够用了，那我们如何自定义目录？这些资源都是打包在jar包中的，然后实际应用中，我们还有很多资源是在管理系统中动态维护的，并不可能在程序包中，对于这种随意指定目录的资源，如何访问？ 自定义目录以增加 /myres/ _ 映射到 classpath:/myres/ _ 为例的代码处理为：实现类继承 WebMvcConfigurerAdapter 并重写方法 addResourceHandlers （对于WebMvcConfigurerAdapter 上篇介绍拦截器的文章中已经有提到） package org.springboot.sample.config; import org.springboot.sample.interceptor.MyInterceptor1; import org.springboot.sample.interceptor.MyInterceptor2; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; @Configuration public class MyWebAppConfigurer extends WebMvcConfigurerAdapter { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/myres/**&quot;).addResourceLocations(&quot;classpath:/myres/&quot;); super.addResourceHandlers(registry); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 访问myres 文件夹中的fengjing.jpg 图片的地址为 http://localhost:8080/myres/fengjing.jpg 这样使用代码的方式自定义目录映射，并不影响Spring Boot的默认映射，可以同时使用。 如果我们将/myres/ _ 修改为 / _ 与默认的相同时，则会覆盖系统的配置，可以多次使用 addResourceLocations添加目录，优先级先添加的高于后添加的。 // 访问myres根目录下的fengjing.jpg 的URL为 http://localhost:8080/fengjing.jpg （/** 会覆盖系统默认的配置） // registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;classpath:/myres/&quot;).addResourceLocations(&quot;classpath:/static/&quot;); 1 2 1 2 其中 addResourceLocations 的参数是动参，可以这样写 addResourceLocations(“classpath:/img1/”,“classpath:/img2/”, “classpath:/img3/”); 使用外部目录如果我们要指定一个绝对路径的文件夹（如 H:/myimgs/ ），则只需要使用 addResourceLocations 指定即可。 // 可以直接使用addResourceLocations 指定磁盘绝对路径，同样可以配置多个位置，注意路径写法需要加上file: registry.addResourceHandler(&quot;/myimgs/**&quot;).addResourceLocations(&quot;file:H:/myimgs/&quot;); 1 2 1 2 通过配置文件配置上面是使用代码来定义静态资源的映射，其实Spring Boot也为我们提供了可以直接在application.properties（或.yml）中配置的方法。配置方法如下： # 默认值为 /** spring.mvc.static-path-pattern= # 默认值为 classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ spring.resources.static-locations=这里设置要指向的路径，多个使用英文逗号隔开， 1 2 3 4 1 2 3 4 使用 spring.mvc.static-path-pattern 可以重新定义pattern，如修改为 /myres/** ，则访问static等目录下的fengjing.jpg文件应该为 http://localhost:8080/myres/fengjing.jpg ，修改之前为 http://localhost:8080/fengjing.jpg 使用 spring.resources.static-locations 可以重新定义 pattern 所指向的路径，支持 classpath: 和file: （上面已经做过说明）注意 spring.mvc.static-path-pattern 只可以定义一个，目前不支持多个逗号分割的方式。 页面中使用上面几个例子中也已经说明了怎么访问静态资源，其实在页面中使用不管是jsp还是freemarker，并没有什么特殊之处，也我们平时开发web项目一样即可。下面是我的index.jsp： &lt;body&gt; &lt;img alt=&quot;读取默认配置中的图片&quot; src=&quot;${pageContext.request.contextPath }/pic.jpg&quot;&gt; &lt;br/&gt; &lt;img alt=&quot;读取自定义配置myres中的图片&quot; src=&quot;${pageContext.request.contextPath }/myres/fengjing.jpg&quot;&gt; &lt;/body&gt; 1 2 3 4 5 1 2 3 4 5 使用webjars先说一下什么是webjars？我们在Web开发中，前端页面中用了越来越多的JS或CSS，如 jQuery 等等，平时我们是将这些Web资源拷贝到 Java 的目录下，这种通过人工方式拷贝可能会产生版本误差，拷贝版本错误，前端页面就无法正确展示。WebJars 就是为了解决这种问题衍生的，将这些Web前端资源打包成Java的Jar包，然后借助Maven这些依赖库的管理，保证这些Web资源版本唯一性。 WebJars 就是将js, css 等资源文件放到 classpath:/META-INF/resources/webjars/ 中，然后打包成jar发布到maven仓库中。 简单应用以jQuery为例，文件存放结构为： META-INF/resources/webjars/jquery/2.1.4/jquery.js META-INF/resources/webjars/jquery/2.1.4/jquery.min.js META-INF/resources/webjars/jquery/2.1.4/jquery.min.map META-INF/resources/webjars/jquery/2.1.4/webjars-requirejs.js 1 2 3 4 1 2 3 4 Spring Boot 默认将 /webjars/** 映射到 classpath:/META-INF/resources/webjars/，结合我们上面讲到的访问资源的规则，便可以得知我们在JSP页面中引入jquery.js的方法为： &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/webjars/jquery/2.1.4/jquery.js&quot;&gt;&lt;/script&gt; 1 1 想实现这样，我们只需要在pom.xml 文件中添加jquery的webjars 依赖即可，如下： &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; 1 2 3 4 5 1 2 3 4 5 版本号统一管理但是我们实际开发中，可能会遇到升级版本号的情况，如果我们有100多个页面，几乎每个页面上都有按上面引入jquery.js那么我们要把版本号更换为3.0.0，一个一个替换显然不是最好的办法。如何来解决？按如下方法处理即可。 首先在pom.xml 中添加依赖： &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator&lt;/artifactId&gt; &lt;/dependency&gt; 1 2 3 4 1 2 3 4 然后增加一个WebJarsController： package org.springboot.sample.controller; import javax.servlet.http.HttpServletRequest; import org.springframework.core.io.ClassPathResource; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.servlet.HandlerMapping; import org.webjars.WebJarAssetLocator; /** * 处理WebJars，自动读取版本号 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月8日 */ @Controller public class WebJarsController { private final WebJarAssetLocator assetLocator = new WebJarAssetLocator(); @ResponseBody @RequestMapping(&quot;/webjarslocator/{webjar}/**&quot;) public ResponseEntity&lt;Object&gt; locateWebjarAsset(@PathVariable String webjar, HttpServletRequest request) { try { String mvcPrefix = &quot;/webjarslocator/&quot; + webjar + &quot;/&quot;; // This prefix must match the mapping path! String mvcPath = (String) request.getAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE); String fullPath = assetLocator.getFullPath(webjar, mvcPath.substring(mvcPrefix.length())); return new ResponseEntity&lt;&gt;(new ClassPathResource(fullPath), HttpStatus.OK); } catch (Exception e) { return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 最后在页面中使用的方式： &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/webjarslocator/jquery/jquery.js&quot;&gt;&lt;/script&gt; 1 1 静态资源版本管理Spring 默认提供了静态资源版本映射的支持。当我们的资源内容发生改变时，由于浏览器缓存，用户本地的资源还是旧资源，为了防止这种情况发生导致的问题。我们可能会选择在资源文件后面加上参数“版本号”或其他方式。 使用版本号参数，如： &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/common.js?v=1.0.1&quot;&gt;&lt;/script&gt; 1 1 使用这种方式，当我们文件修改后，手工修改版本号来达到URL文件不被浏览器缓存的目的。同样也存在很多文件都需要修改的问题。或者有的人会增加时间戳的方式，这样我认为是最不可取的，每次浏览器都要请求为服务器增加了不必要的压力。 然而Spring在解决这种问题方面，提供了2种解决方式。_ 资源名称md5方式 _1. 修改 application.properties 配置文件（或.yml） spring.resources.chain.strategy.content.enabled=true spring.resources.chain.strategy.content.paths=/** 1 2 1 2 所有 /** 请求的静态资源都会被处理。 创建 ResourceUrlProviderController 文件 package org.springboot.sample.config; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.servlet.resource.ResourceUrlProvider; /** * 处理静态资源URL * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月8日 */ @ControllerAdvice public class ResourceUrlProviderController { @Autowired private ResourceUrlProvider resourceUrlProvider; @ModelAttribute(&quot;urls&quot;) public ResourceUrlProvider urls() { return this.resourceUrlProvider; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 在页面中使用的写法 &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }${urls.getForLookupPath(&apos;/js/common.js&apos;) }&quot;&gt;&lt;/script&gt; 1 1 当我们访问页面后，HTML中实际生成的代码为： &lt;script type=&quot;text/javascript&quot; src=&quot;/myspringboot/js/common-c6b7da8fffc9be141b48c073e39c7340.js&quot;&gt;&lt;/script&gt; 1 1 其中 /myspringboot 为我这个项目的 contextPath _ 资源版本号方式 _该方式本人觉得并无多大意义，也不做详细说明，这是对所有资源的统一版本控制，不像上面一个md5是针对文件的。除了在 application.properties（或.yml）中的配置有所区别，页面使用和md5的一样。 spring.resources.chain.strategy.fixed.enabled=true spring.resources.chain.strategy.fixed.paths=/js/**,/v1.0.0/** spring.resources.chain.strategy.fixed.version=v1.0.0 1 2 3 1 2 3 这样配置后，以上面 common.js 为例，实际页面中生成的HTML代码为： &lt;script type=&quot;text/javascript&quot; src=&quot;/myspringboot/v1.0.0/js/common.js&quot;&gt;&lt;/script&gt; 1 1 _ md5与版本号方式的处理原理 _页面中首先会调用urls.getForLookupPath方法，返回一个/v1.0.0/js/common.js或/css/common-c6b7da8fffc9be141b48c073e39c7340.js然后浏览器发起请求。当请求的地址为md5方式时，会尝试url中的文件名中是否包含-，如果包含会去掉后面这部分，然后去映射的目录（如/static/）查找/js/common.js文件，如果能找到就返回。 当请求的地址为版本号方式时，会在url中判断是否存在/v1.0.0 ，如果存在，则先从URL中把 /v1.0.0去掉，然后再去映射目录查找对应文件，找到就返回。 总结有这么多方式来管理我们的资源文件，然而在实际应用中虽然也都有可能用到（存在就有存在的道理嘛），但是凭借个人经验来说。1. 我们使用第三方的库时，建议使用webjars的方式，通过动态版本号（webjars-locator的方式）来使用（因为第三方库在项目开发中变动频率很小，即便是变动也是版本号的修改）。2. 我们使用自己存放在静态资源映射目录中的资源的时候，建议使用md5 资源文件名的方式来使用（项目开发中一些css、js文件会经常修改）。3. 项目素材文件建议放到 classpath:/static（或其他）目录中，打包在项目中，通过CMS维护的一些图片和资源，我们使用配置引用到具体的磁盘绝对路径来使用。4. 注意使用md5文件名方式的时候，Spring 是有缓存机制的，也就是说，在服务不重启的情况下，你去变动修改这些资源文件，其文件名的md5值并不会改变，只有重启服务再次访问才会生效。如果需要每次都获取实际文件的md5值，需要重写相关类来实现，我们不建议这样做，因为一直去计算文件md5值是需要性能代价的。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot 集成Shiro和CAS","slug":"Spring Boot 集成Shiro和CAS","date":"2018-04-19T16:34:21.437Z","updated":"2018-04-19T16:30:07.548Z","comments":true,"path":"2018/04/20/Spring Boot 集成Shiro和CAS/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 集成Shiro和CAS/","excerpt":"","text":"请大家在看本文之前，先了解如下知识点：1、Shiro 是什么？怎么用？2、Cas 是什么？怎么用？3、最好有Spring基础 可以先看看这两篇文章，按照这2篇文章的内容做一遍： Spring Boot Shiro 权限管理 CAS单点登录 首先看一下下面这张图：第一个流程是单纯使用Shiro的流程。第二个流程是单纯使用Cas的流程。第三个图是Shiro集成Cas后的流程。 【流程图高清图连接： https://img-blog.csdn.net/20160117224937078 】 PS：流程图急急忙忙画的，整体上应该没有什么问题，具体细节问题还请大家留言指正。 如果你只是打算用到你的Spring Boot项目中，那么看着如下配置完成便可。如果你想进一步了解其中的细节，还是建议大家单独配置Shiro、单独配置Cas，看看官方相关文档。Shiro在1.2版本开始提供了对cas的集成，按下面添加依赖到pom.xml中： &lt;!--Apache Shiro所需的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-cas&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 shiro-cas 依赖 shiro-web，shiro-web 依赖 shiro-core，所以添加shiro-cas后shiro-web.jar和shiro-core.jar会自动被引用。cas被shiro集成后，其原理就是shiro将casFilter加入到shiroFilter的filterChain中。 在SpringBoot工程中创建ShiroCasConfiguration. Java package org.springboot.sample.config; import java.util.HashMap; import java.util.LinkedHashMap; import java.util.Map; import javax.servlet.Filter; import org.apache.shiro.cache.ehcache.EhCacheManager; import org.apache.shiro.cas.CasFilter; import org.apache.shiro.cas.CasSubjectFactory; import org.apache.shiro.spring.LifecycleBeanPostProcessor; import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor; import org.apache.shiro.spring.web.ShiroFilterFactoryBean; import org.apache.shiro.web.mgt.DefaultWebSecurityManager; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springboot.sample.dao.IScoreDao; import org.springboot.sample.security.MyShiroCasRealm; import org.springboot.sample.service.StudentService; import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator; import org.springframework.boot.context.embedded.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.filter.DelegatingFilterProxy; /** * Shiro集成Cas配置 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月17日 */ @Configuration public class ShiroCasConfiguration { private static final Logger logger = LoggerFactory.getLogger(ShiroCasConfiguration.class); // CasServerUrlPrefix public static final String casServerUrlPrefix = &quot;https://localhost:8443/cas&quot;; // Cas登录页面地址 public static final String casLoginUrl = casServerUrlPrefix + &quot;/login&quot;; // Cas登出页面地址 public static final String casLogoutUrl = casServerUrlPrefix + &quot;/logout&quot;; // 当前工程对外提供的服务地址 public static final String shiroServerUrlPrefix = &quot;http://localhost:9090/myspringboot&quot;; // casFilter UrlPattern public static final String casFilterUrlPattern = &quot;/shiro-cas&quot;; // 登录地址 public static final String loginUrl = casLoginUrl + &quot;?service=&quot; + shiroServerUrlPrefix + casFilterUrlPattern; @Bean public EhCacheManager getEhCacheManager() { EhCacheManager em = new EhCacheManager(); em.setCacheManagerConfigFile(&quot;classpath:ehcache-shiro.xml&quot;); return em; } @Bean(name = &quot;myShiroCasRealm&quot;) public MyShiroCasRealm myShiroCasRealm(EhCacheManager cacheManager) { MyShiroCasRealm realm = new MyShiroCasRealm(); realm.setCacheManager(cacheManager); return realm; } /** * 注册DelegatingFilterProxy（Shiro） * * @param dispatcherServlet * @return * @author SHANHY * @create 2016年1月13日 */ @Bean public FilterRegistrationBean filterRegistrationBean() { FilterRegistrationBean filterRegistration = new FilterRegistrationBean(); filterRegistration.setFilter(new DelegatingFilterProxy(&quot;shiroFilter&quot;)); // 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 filterRegistration.addInitParameter(&quot;targetFilterLifecycle&quot;, &quot;true&quot;); filterRegistration.setEnabled(true); filterRegistration.addUrlPatterns(&quot;/*&quot;); return filterRegistration; } @Bean(name = &quot;lifecycleBeanPostProcessor&quot;) public LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() { return new LifecycleBeanPostProcessor(); } @Bean public DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() { DefaultAdvisorAutoProxyCreator daap = new DefaultAdvisorAutoProxyCreator(); daap.setProxyTargetClass(true); return daap; } @Bean(name = &quot;securityManager&quot;) public DefaultWebSecurityManager getDefaultWebSecurityManager(MyShiroCasRealm myShiroCasRealm) { DefaultWebSecurityManager dwsm = new DefaultWebSecurityManager(); dwsm.setRealm(myShiroCasRealm); // &lt;!-- 用户授权/认证信息Cache, 采用EhCache 缓存 --&gt; dwsm.setCacheManager(getEhCacheManager()); // 指定 SubjectFactory dwsm.setSubjectFactory(new CasSubjectFactory()); return dwsm; } @Bean public AuthorizationAttributeSourceAdvisor getAuthorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager) { AuthorizationAttributeSourceAdvisor aasa = new AuthorizationAttributeSourceAdvisor(); aasa.setSecurityManager(securityManager); return aasa; } /** * 加载shiroFilter权限控制规则（从数据库读取然后配置） * * @author SHANHY * @create 2016年1月14日 */ private void loadShiroFilterChain(ShiroFilterFactoryBean shiroFilterFactoryBean, StudentService stuService, IScoreDao scoreDao){ /////////////////////// 下面这些规则配置最好配置到配置文件中 /////////////////////// Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;(); filterChainDefinitionMap.put(casFilterUrlPattern, &quot;casFilter&quot;);// shiro集成cas后，首先添加该规则 // authc：该过滤器下的页面必须验证后才能访问，它是Shiro内置的一个拦截器org.apache.shiro.web.filter.authc.FormAuthenticationFilter filterChainDefinitionMap.put(&quot;/user&quot;, &quot;authc&quot;);// 这里为了测试，只限制/user，实际开发中请修改为具体拦截的请求规则 // anon：它对应的过滤器里面是空的,什么都没做 logger.info(&quot;##################从数据库读取权限规则，加载到shiroFilter中##################&quot;); filterChainDefinitionMap.put(&quot;/user/edit/**&quot;, &quot;authc,perms[user:edit]&quot;);// 这里为了测试，固定写死的值，也可以从数据库或其他配置中读取 filterChainDefinitionMap.put(&quot;/login&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/**&quot;, &quot;anon&quot;);//anon 可以理解为不拦截 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); } /** * CAS过滤器 * * @return * @author SHANHY * @create 2016年1月17日 */ @Bean(name = &quot;casFilter&quot;) public CasFilter getCasFilter() { CasFilter casFilter = new CasFilter(); casFilter.setName(&quot;casFilter&quot;); casFilter.setEnabled(true); // 登录失败后跳转的URL，也就是 Shiro 执行 CasRealm 的 doGetAuthenticationInfo 方法向CasServer验证tiket casFilter.setFailureUrl(loginUrl);// 我们选择认证失败后再打开登录页面 return casFilter; } /** * ShiroFilter&lt;br/&gt; * 注意这里参数中的 StudentService 和 IScoreDao 只是一个例子，因为我们在这里可以用这样的方式获取到相关访问数据库的对象， * 然后读取数据库相关配置，配置到 shiroFilterFactoryBean 的访问规则中。实际项目中，请使用自己的Service来处理业务逻辑。 * * @param myShiroCasRealm * @param stuService * @param scoreDao * @return * @author SHANHY * @create 2016年1月14日 */ @Bean(name = &quot;shiroFilter&quot;) public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager, CasFilter casFilter, StudentService stuService, IScoreDao scoreDao) { ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 如果不设置默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 shiroFilterFactoryBean.setLoginUrl(loginUrl); // 登录成功后要跳转的连接 shiroFilterFactoryBean.setSuccessUrl(&quot;/user&quot;); shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/403&quot;); // 添加casFilter到shiroFilter中 Map&lt;String, Filter&gt; filters = new HashMap&lt;&gt;(); filters.put(&quot;casFilter&quot;, casFilter); shiroFilterFactoryBean.setFilters(filters); loadShiroFilterChain(shiroFilterFactoryBean, stuService, scoreDao); return shiroFilterFactoryBean; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 创建权限认证的 MyShiroCasRealm.java package org.springboot.sample.security; import java.util.List; import javax.annotation.PostConstruct; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.cas.CasRealm; import org.apache.shiro.subject.PrincipalCollection; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springboot.sample.config.ShiroCasConfiguration; import org.springboot.sample.dao.IUserDao; import org.springboot.sample.entity.Role; import org.springboot.sample.entity.User; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; public class MyShiroCasRealm extends CasRealm{ private static final Logger logger = LoggerFactory.getLogger(MyShiroCasRealm.class); @Autowired private IUserDao userDao; @PostConstruct public void initProperty(){ // setDefaultRoles(&quot;ROLE_USER&quot;); setCasServerUrlPrefix(ShiroCasConfiguration.casServerUrlPrefix); // 客户端回调地址 setCasService(ShiroCasConfiguration.shiroServerUrlPrefix + ShiroCasConfiguration.casFilterUrlPattern); } /** * 权限认证，为当前登录的Subject授予角色和权限 * @see 经测试：本例中该方法的调用时机为需授权资源被访问时 * @see 经测试：并且每次访问需授权资源时都会执行该方法中的逻辑，这表明本例中默认并未启用AuthorizationCache * @see 经测试：如果连续访问同一个URL（比如刷新），该方法不会被重复调用，Shiro有一个时间间隔（也就是cache时间，在ehcache-shiro.xml中配置），超过这个时间间隔再刷新页面，该方法会被执行 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { logger.info(&quot;##################执行Shiro权限认证##################&quot;); //获取当前登录输入的用户名，等价于(String) principalCollection.fromRealm(getName()).iterator().next(); String loginName = (String)super.getAvailablePrincipal(principalCollection); //到数据库查是否有此对象 User user=userDao.findByName(loginName);// 实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 if(user!=null){ //权限信息对象info,用来存放查出的用户的所有的角色（role）及权限（permission） SimpleAuthorizationInfo info=new SimpleAuthorizationInfo(); //用户的角色集合 info.setRoles(user.getRolesName()); //用户的角色对应的所有权限，如果只使用角色定义访问权限，下面的四行可以不要 List&lt;Role&gt; roleList=user.getRoleList(); for (Role role : roleList) { info.addStringPermissions(role.getPermissionsName()); } // 或者按下面这样添加 //添加一个角色,不是配置意义上的添加,而是证明该用户拥有admin角色 // simpleAuthorInfo.addRole(&quot;admin&quot;); //添加权限 // simpleAuthorInfo.addStringPermission(&quot;admin:manage&quot;); // logger.info(&quot;已为用户[mike]赋予了[admin]角色和[admin:manage]权限&quot;); return info; } // 返回null的话，就会导致任何用户访问被拦截的请求时，都会自动跳转到unauthorizedUrl指定的地址 return null; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 在Controller中添加一个方法，用于将登录URL简单化，提供一个重定向功能 @RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET) public String loginForm(Model model){ model.addAttribute(&quot;user&quot;, new User()); // return &quot;login&quot;; return &quot;redirect:&quot; + ShiroCasConfiguration.loginUrl; } 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 本文主要是介绍如何在Spring Boot中集成Shiro+Cas，并非一个从零创建工程到整体完成的介绍。上面贴出了2个主要的Java类，整个工程的其他所有代码没有任何与Shiro和Cas耦合的地方。如果需要jsp页面、Controller、实体类、连接 数据库 测试数据等代码，可以先参考文章： http://blog.csdn.net/lsy0903/article/details/52910744 （建议先看这篇文章再看本文）","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"},{"name":"shiro","slug":"shiro","permalink":"https://www.itchina.top/tags/shiro/"},{"name":"cas","slug":"cas","permalink":"https://www.itchina.top/tags/cas/"}]},{"title":"Spring Boot 环境变量读取 和 属性对象的绑定","slug":"Spring Boot 环境变量读取 和 属性对象的绑定","date":"2018-04-19T16:34:21.437Z","updated":"2018-04-19T16:30:07.075Z","comments":true,"path":"2018/04/20/Spring Boot 环境变量读取 和 属性对象的绑定/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 环境变量读取 和 属性对象的绑定/","excerpt":"","text":"凡是被Spring管理的类，实现接口 EnvironmentAware 重写方法 setEnvironment可以在工程启动时，获取到系统环境变量和application配置文件中的变量。如： @Configuration public class MyWebAppConfigurer implements EnvironmentAware { private static final Logger logger = LoggerFactory.getLogger(MyWebAppConfigurer.class); private RelaxedPropertyResolver propertyResolver; @Value(&quot;${spring.datasource.url}&quot;) private String myUrl; /** * 这个方法只是测试实现EnvironmentAware接口，读取环境变量的方法。 */ @Override public void setEnvironment(Environment env) { logger.info(env.getProperty(&quot;JAVA_HOME&quot;)); logger.info(myUrl); String str = env.getProperty(&quot;spring.datasource.url&quot;); logger.info(str); propertyResolver = new RelaxedPropertyResolver(env, &quot;spring.datasource.&quot;); String url = propertyResolver.getProperty(&quot;url&quot;); logger.info(url); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Controller @Service 等被Spring管理的类都支持，注意重写的方法 setEnvironment 是在系统启动的时候被执行。或者如下Controller： @Controller public class PageController implements EnvironmentAware{ @Override public void setEnvironment(Environment environment) { String s = environment.getProperty(&quot;JAVA_HOME&quot;); System.out.println(s); } } 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 我们还可以通过@ConfigurationProperties 读取application属性配置文件中的属性。 @Configuration @ConditionalOnClass(Mongo.class) @EnableConfigurationProperties(MongoProperties.class) public class MongoAutoConfiguration { @Autowired private MongoProperties properties; } 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 @ConditionOnClass表明该@Configuration仅仅在一定条件下才会被加载，这里的条件是Mongo.class位于类路径上 @EnableConfigurationProperties将Spring Boot的配置文件（application.properties）中的spring.data.mongodb.*属性映射为MongoProperties并注入到MongoAutoConfiguration中。 @ConditionalOnMissingBean说明Spring Boot仅仅在当前上下文中不存在Mongo对象时，才会实例化一个Bean。这个逻辑也体现了Spring Boot的另外一个特性——自定义的Bean优先于框架的默认配置，我们如果显式的在业务代码中定义了一个Mongo对象，那么Spring Boot就不再创建。 @ConfigurationProperties(prefix = &quot;spring.data.mongodb&quot;) public class MongoProperties { private String host; private int port = DBPort.PORT; private String uri = &quot;mongodb://localhost/test&quot;; private String database; // ... getters/ setters omitted } 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 它就是以spring.data.mongodb作为前缀的属性，然后通过名字直接映射为对象的属性，同时还包含了一些默认值。如果不配置，那么mongo.uri就是mongodb://localhost/test。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot 过滤器、监听器","slug":"Spring Boot 过滤器、监听器","date":"2018-04-19T16:34:21.436Z","updated":"2018-04-19T16:30:13.349Z","comments":true,"path":"2018/04/20/Spring Boot 过滤器、监听器/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 过滤器、监听器/","excerpt":"","text":"上一篇文章已经对定义Servlet 的方法进行了说明，过滤器（Filter）和 监听器（Listener）的注册方法和 Servlet一样，不清楚的可以查看下上一篇文章： http://blog.csdn.net/lsy0903/article/details/52910612 本文将直接使用@WebFilter和@WebListener的方式，完成一个Filter 和一个 Listener。 过滤器（Filter）文件 MyFilter. Java package org.springboot.sample.filter; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; /** * 使用注解标注过滤器 * @WebFilter将一个实现了javax.servlet.Filter接口的类定义为过滤器 * 属性filterName声明过滤器的名称,可选 * 属性urlPatterns指定要过滤 的URL模式,也可使用属性value来声明.(指定要过滤的URL模式是必选属性) * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月6日 */ @WebFilter(filterName=&quot;myFilter&quot;,urlPatterns=&quot;/*&quot;) public class MyFilter implements Filter { @Override public void destroy() { System.out.println(&quot;过滤器销毁&quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&quot;执行过滤操作&quot;); chain.doFilter(request, response); } @Override public void init(FilterConfig config) throws ServletException { System.out.println(&quot;过滤器初始化&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 ServletContext监听器（Listener）文件 MyServletContextListener.java package org.springboot.sample.listener; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; /** * 使用@WebListener注解，实现ServletContextListener接口 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月6日 */ @WebListener public class MyServletContextListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(&quot;ServletContex初始化&quot;); System.out.println(sce.getServletContext().getServerInfo()); } @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(&quot;ServletContex销毁&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ServletContext监听器（Listener）文件 MyHttpSessionListener.java package org.springboot.sample.listener; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; /** * 监听Session的创建与销毁 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月6日 */ @WebListener public class MyHttpSessionListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent se) { System.out.println(&quot;Session 被创建&quot;); } @Override public void sessionDestroyed(HttpSessionEvent se) { System.out.println(&quot;ServletContex初始化&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 注意不要忘记在 SpringBootSampleApplication.java 上添加 @ServletComponentScan 注解。 在启动的过程中我们会看到输出： ServletContex初始化 Apache Tomcat/8.0.30 过滤器初始化 1 2 3 1 2 3 服务启动后，随便访问一个页面，会看到输出： 执行过滤操作 Session 被创建 1 2 1 2 至于如何使用代码的方式注册Filter和Listener，请参考上一篇文章关键Servlet的介绍。不同的是需要使用FilterRegistrationBean 和 ServletListenerRegistrationBean 这两个类。 最后上一张工程结构图： 代码目前还没有一个警告 ^_^","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot 多数据源","slug":"Spring Boot 多数据源","date":"2018-04-19T16:34:21.435Z","updated":"2018-04-19T16:30:08.960Z","comments":true,"path":"2018/04/20/Spring Boot 多数据源/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 多数据源/","excerpt":"","text":"上篇文章介绍了如何手工使用 Java 代码将对象注册到Spring中，为本文“多数据源”做了基础。 下面一个Java类是我已经写好的根据配置文件动态创建多dataSource的代码，其原理也很简单，就是读取配置文件，根据配置文件中配置的数据源数量，动态创建dataSource并注册到Spring中。代码如下： package org.springboot.sample.config; import java.util.HashMap; import java.util.Map; import java.util.Map.Entry; import javax.sql.DataSource; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.BeansException; import org.springframework.beans.MutablePropertyValues; import org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanDefinitionHolder; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.support.BeanDefinitionReaderUtils; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor; import org.springframework.beans.factory.support.BeanNameGenerator; import org.springframework.boot.bind.RelaxedPropertyResolver; import org.springframework.context.EnvironmentAware; import org.springframework.context.annotation.AnnotationBeanNameGenerator; import org.springframework.context.annotation.AnnotationConfigUtils; import org.springframework.context.annotation.AnnotationScopeMetadataResolver; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.ScopeMetadata; import org.springframework.context.annotation.ScopeMetadataResolver; import org.springframework.core.env.Environment; /** * 动态创建多数据源注册到Spring中 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月22日 */ @Configuration public class MultipleDataSourceBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware { private static final Logger logger = LoggerFactory .getLogger(MultipleDataSourceBeanDefinitionRegistryPostProcessor.class); // 如配置文件中未指定数据源类型，使用该默认值 private static final Object DATASOURCE_TYPE_DEFAULT = &quot;org.apache.tomcat.jdbc.pool.DataSource&quot;; // private static final Object DATASOURCE_TYPE_DEFAULT = &quot;com.zaxxer.hikari.HikariDataSource&quot;; private ScopeMetadataResolver scopeMetadataResolver = new AnnotationScopeMetadataResolver(); private BeanNameGenerator beanNameGenerator = new AnnotationBeanNameGenerator(); // 存放DataSource配置的集合，模型&lt;dataSourceName,dataSourceMap&gt; private Map&lt;String, Map&lt;String, Object&gt;&gt; dataSourceMap = new HashMap&lt;&gt;(); @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { logger.info(&quot;Invoke Metho postProcessBeanFactory&quot;); beanFactory.getBeanDefinition(&quot;dataSource&quot;).setPrimary(true); BeanDefinition bd = null; Map&lt;String, Object&gt; dsMap = null; for (Entry&lt;String, Map&lt;String, Object&gt;&gt; entry : dataSourceMap.entrySet()) { bd = beanFactory.getBeanDefinition(entry.getKey()); MutablePropertyValues mpv = bd.getPropertyValues(); dsMap = entry.getValue(); mpv.addPropertyValue(&quot;driverClassName&quot;, dsMap.get(&quot;url&quot;)); mpv.addPropertyValue(&quot;url&quot;, dsMap.get(&quot;url&quot;)); mpv.addPropertyValue(&quot;username&quot;, dsMap.get(&quot;username&quot;)); mpv.addPropertyValue(&quot;password&quot;, dsMap.get(&quot;password&quot;)); } } @SuppressWarnings(&quot;unchecked&quot;) @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { logger.info(&quot;Invoke Metho postProcessBeanDefinitionRegistry&quot;); try { if(!dataSourceMap.isEmpty()){ for (Entry&lt;String, Map&lt;String, Object&gt;&gt; entry : dataSourceMap.entrySet()) { Object type = entry.getValue().get(&quot;type&quot;); if(type == null) type = DATASOURCE_TYPE_DEFAULT;// 默认DataSource registerBean(registry, entry.getKey(), (Class&lt;? extends DataSource&gt;)Class.forName(type.toString())); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 注册Bean到Spring * * @param registry * @param name * @param beanClass * @author SHANHY * @create 2016年1月22日 */ private void registerBean(BeanDefinitionRegistry registry, String name, Class&lt;?&gt; beanClass) { AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd); abd.setScope(scopeMetadata.getScopeName()); // 可以自动生成name String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, registry)); AnnotationConfigUtils.processCommonDefinitionAnnotations(abd); BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName); BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry); } /** * 加载多数据源配置 */ @Override public void setEnvironment(Environment env) { RelaxedPropertyResolver propertyResolver = new RelaxedPropertyResolver(env, &quot;custom.datasource.&quot;); String dsPrefixs = propertyResolver.getProperty(&quot;names&quot;); for (String dsPrefix : dsPrefixs.split(&quot;,&quot;)) {// 多个数据源 Map&lt;String, Object&gt; dsMap = propertyResolver.getSubProperties(dsPrefix + &quot;.&quot;); dataSourceMap.put(dsPrefix, dsMap); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 将该Java文件直接添加到项目中便可，无其他任何代码耦合，就是单纯一个类。 再来看一下在配置文件中配置多数据源的方法： # 主数据源，默认的 spring.datasource.type=com.zaxxer.hikari.HikariDataSource spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/test spring.datasource.username=root spring.datasource.password=123456 # 更多数据源 custom.datasource.names=ds1,ds2,ds3 custom.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource custom.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver custom.datasource.ds1.url=jdbc:mysql://localhost:3306/test custom.datasource.ds1.username=root custom.datasource.ds1.password=123456 custom.datasource.ds2.type=com.zaxxer.hikari.HikariDataSource custom.datasource.ds2.driver-class-name=com.mysql.jdbc.Driver custom.datasource.ds2.url=jdbc:mysql://localhost:3306/test custom.datasource.ds2.username=root custom.datasource.ds2.password=123456 custom.datasource.ds3.type=com.zaxxer.hikari.HikariDataSource custom.datasource.ds3.driver-class-name=com.mysql.jdbc.Driver custom.datasource.ds3.url=jdbc:mysql://localhost:3306/test custom.datasource.ds3.username=root custom.datasource.ds3.password=123456 # 下面为连接池的补充设置，应用到上面所有数据源中 spring.datasource.maximum-pool-size=100 spring.datasource.max-idle=10 spring.datasource.max-wait=10000 spring.datasource.min-idle=5 spring.datasource.initial-size=5 spring.datasource.validation-query=SELECT 1 spring.datasource.test-on-borrow=false spring.datasource.test-while-idle=true spring.datasource.time-between-eviction-runs-millis=18800 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 配置文件包括1个主数据源和多个数据源，其中主数据源在Spring中的beanName默认为dataSource，另外几个数据源的beanName分包为：ds1、ds2、ds3，大家看一下配置的规则，想必不用多说。其中datasource的type属性可以具体指定到我们需要的数据源上面，不指定情况下默认为：org.apache.tomcat.jdbc.pool.DataSource 当然你也可以把这些数据源配置到主dataSource 数据库 中，然后读取数据库生成多数据源。当然这样做的必要性并不大，难不成数据源还会经常变吗。 在需要应用dataSource的地方需要指定名称，如： // 方法参数注入方式 public void testDataSource(@Qualifier(&quot;ds1&quot;) DataSource myDataSource, @Qualifier(&quot;dataSource&quot;) DataSource dataSource) { } 1 2 3 4 1 2 3 4 或者 // 类成员属性注入方式 @Autowired @Qualifier(&quot;ds1&quot;) private DataSource dataSource1; @Resource(name = &quot;ds2&quot;) private DataSource dataSource2; 1 2 3 4 5 6 7 1 2 3 4 5 6 7 本文共享的代码可以直接使用了，大家可以根据自己需要进行调整。 然而我们在项目中不一定需要直接使用dataSource的，大家都习惯使用JDBC的jdbcTemplate、Mybatis的sqlSessionTemplate，再或者就是以Mybatis为例直接动态代理到Mapper接口上。 那么如何做到完全动态数据源呢，以至于实现我们可以为同一个Java类的不同方法，分别指定使用不同的数据源？下篇文章将为大家揭晓。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot 部署与服务配置","slug":"Spring Boot 部署与服务配置","date":"2018-04-19T16:34:21.434Z","updated":"2018-04-19T16:30:05.673Z","comments":true,"path":"2018/04/20/Spring Boot 部署与服务配置/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 部署与服务配置/","excerpt":"","text":"Spring Boot 其默认是集成web容器的，启动方式由像普通 Java 程序一样，main函数入口启动。其内置Tomcat容器或Jetty容器，具体由配置来决定（默认Tomcat）。当然你也可以将项目打包成war包，放到独立的web容器中（Tomcat、weblogic等等），当然在此之前你要对程序入口做简单调整。 项目构建我们使用Maven或Gradle，这将使项目依赖、jar包管理、以及打包部署变的非常方便。 一、内嵌 Server 配置Spring Boot将容器内置后，它通过配置文件的方式类修改相关server配置。先看一下下面的图，为关于server的配置列项： 其中常用的配置只有少数几个，已经用紫色标记起来。红框圈起来的部分，看名称分类就可以明白其作用。对server的几个常用的配置做个简单说明： # 项目contextPath，一般在正式发布版本中，我们不配置 server.context-path=/myspringboot # 错误页，指定发生错误时，跳转的URL。请查看BasicErrorController源码便知 server.error.path=/error # 服务端口 server.port=9090 # session最大超时时间(分钟)，默认为30 server.session-timeout=60 # 该服务绑定IP地址，启动服务器时如本机不是该IP地址则抛出异常启动失败，只有特殊需求的情况下才配置 # server.address=192.168.16.11 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 Tomcat Tomcat为Spring Boot的默认容器，下面是几个常用配置： # tomcat最大线程数，默认为200 server.tomcat.max-threads=800 # tomcat的URI编码 server.tomcat.uri-encoding=UTF-8 # 存放Tomcat的日志、Dump等文件的临时文件夹，默认为系统的tmp文件夹（如：C:\\Users\\Shanhy\\AppData\\Local\\Temp） server.tomcat.basedir=H:/springboot-tomcat-tmp # 打开Tomcat的Access日志，并可以设置日志格式的方法： #server.tomcat.access-log-enabled=true #server.tomcat.access-log-pattern= # accesslog目录，默认在basedir/logs #server.tomcat.accesslog.directory= # 日志文件目录 logging.path=H:/springboot-tomcat-tmp # 日志文件名称，默认为spring.log logging.file=myapp.log 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Jetty 如果你要选择Jetty，也非常简单，就是把pom中的tomcat依赖排除，并加入Jetty容器的依赖，如下： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependencies&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 打包 打包方法：CMD进入项目目录，使用 mvn clean package 命令打包，以我的项目工程为例： E:\\spring-boot-sample&gt;mvn clean package 1 1 可以追加参数 -Dmaven.test.skip=true 跳过测试。打包后的文件存放于项目下的target目录中，如：spring-boot-sample-0.0.1-SNAPSHOT.jar如果pom配置的是war包，则为spring-boot-sample-0.0.1-SNAPSHOT.war 二、部署到JavaEE容器 修改启动类，继承 SpringBootServletInitializer 并重写 configure 方法 public class SpringBootSampleApplication extends SpringBootServletInitializer{ private static final Logger logger = LoggerFactory.getLogger(SpringBootSampleApplication.class); @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(this.getClass()); } } 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 修改pom文件中jar 为 war &lt;!-- &lt;packaging&gt;jar&lt;/packaging&gt; --&gt; &lt;packaging&gt;war&lt;/packaging&gt; 1 2 1 2 修改pom，排除tomcat插件 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 打包部署到容器使用命令 mvn clean package 打包后，同一般J2EE项目一样部署到web容器。 三、使用Profile区分环境spring boot 可以在 “配置文件”、“Java代码类”、“日志配置” 中来配置profile区分不同环境执行不同的结果 1、配置文件使用配置文件application.yml 和 application.properties 有所区别以application.properties 为例，通过文件名来区分环境 application-{profile}.propertiesapplication.properties app.name=MyApp server.port=8080 spring.profiles.active=dev 1 2 3 1 2 3 application-dev.properties server.port=8081 1 1 application-stg.properties server.port=8082 1 1 在启动程序的时候通过添加 –spring.profiles.active={profile} 来指定具体使用的配置例如我们执行 java -jar demo.jar –spring.profiles.active=dev 那么上面3个文件中的内容将被如何应用？Spring Boot 会先加载默认的配置文件，然后使用具体指定的profile中的配置去覆盖默认配置。 app.name 只存在于默认配置文件 application.properties 中，因为指定环境中不存在同样的配置，所以该值不会被覆盖server.port 默认为8080，但是我们指定了环境后，将会被覆盖。如果指定stg环境，server.port 则为 8082spring.profiles.active 默认指定dev环境，如果我们在运行时指定 –spring.profiles.active=stg那么将应用stg环境，最终 server.port 的值为8082 2、Java类中@Profile注解下面2个不同的类实现了同一个接口，@Profile注解指定了具体环境 // 接口定义 public interface SendMessage { // 发送短信方法定义 public void send(); } // Dev 环境实现类 @Component @Profile(&quot;dev&quot;) public class DevSendMessage implements SendMessage { @Override public void send() { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Dev Send()&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); } } // Stg环境实现类 @Component @Profile(&quot;stg&quot;) public class StgSendMessage implements SendMessage { @Override public void send() { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Stg Send()&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); } } // 启动类 @SpringBootApplication public class ProfiledemoApplication { @Value(&quot;${app.name}&quot;) private String name; @Autowired private SendMessage sendMessage; @PostConstruct public void init(){ sendMessage.send();// 会根据profile指定的环境实例化对应的类 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 3、logback-spring.xml也支持有节点来支持区分 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/base.xml&quot; /&gt; &lt;logger name=&quot;org.springframework.web&quot; level=&quot;INFO&quot;/&gt; &lt;springProfile name=&quot;default&quot;&gt; &lt;logger name=&quot;org.springboot.sample&quot; level=&quot;TRACE&quot; /&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;logger name=&quot;org.springboot.sample&quot; level=&quot;DEBUG&quot; /&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;staging&quot;&gt; &lt;logger name=&quot;org.springboot.sample&quot; level=&quot;INFO&quot; /&gt; &lt;/springProfile&gt; &lt;/configuration&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 再说一遍文件名不要用logback.xml 请使用logback-spring.xml 四、指定外部的配置文件有些系统，关于一些 数据库 或其他第三方账户等信息，由于安全问题，其配置并不会提前配置在项目中暴露给开发人员。对于这种情况，我们在运行程序的时候，可以通过参数指定一个外部配置文件。以 demo.jar 为例，方法如下： java -jar demo.jar --spring.config.location=/opt/config/application.properties 1 1 其中文件名随便定义，无固定要求。 五、创建一个Linux 应用的sh脚本下面几个脚本仅供参考，请根据自己需要做调整start.sh #!/bin/sh rm -f tpid nohup java -jar myapp.jar --spring.config.location=application.yml &gt; /dev/null 2&gt;&amp;1 &amp; echo $! &gt; tpid echo Start Success! 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 stop.sh #!/bin/sh APP_NAME=myapp tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &apos;{print $2}&apos;` if [ ${tpid} ]; then echo &apos;Stop Process...&apos; kill -15 $tpid fi sleep 5 tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &apos;{print $2}&apos;` if [ ${tpid} ]; then echo &apos;Kill Process!&apos; kill -9 $tpid else echo &apos;Stop Success!&apos; fi 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 check.sh #!/bin/sh APP_NAME=myapp tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &apos;{print $2}&apos;` if [ ${tpid} ]; then echo &apos;App is running.&apos; else echo &apos;App is NOT running.&apos; fi 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 kill.sh #!/bin/sh APP_NAME=myapp tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &apos;{print $2}&apos;` if [ ${tpid} ]; then echo &apos;Kill Process!&apos; kill -9 $tpid fi 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot 动态数据源（多数据源自动切换）","slug":"Spring Boot 动态数据源（多数据源自动切换）","date":"2018-04-19T16:34:21.434Z","updated":"2018-04-19T16:30:06.673Z","comments":true,"path":"2018/04/20/Spring Boot 动态数据源（多数据源自动切换）/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot 动态数据源（多数据源自动切换）/","excerpt":"","text":"本文实现案例场景：某系统除了需要从自己的主要 数据库 上读取和管理数据外，还有一部分业务涉及到其他多个数据库，要求可以在任何方法上可以灵活指定具体要操作的数据库。 为了在开发中以最简单的方法使用，本文基于注解和AOP的方法实现，在springboot框架的项目中，添加本文实现的代码类后，只需要配置好数据源就可以直接通过注解使用，简单方便。 一配置二使用 1. 启动类注册动态数据源 2. 配置文件中配置多个数据源 3. 在需要的方法上使用注解指定数据源 1、在启动类添加 @Import({DynamicDataSourceRegister.class,MProxyTransactionManagementConfiguration.class}) @SpringBootApplication @Import({DynamicDataSourceRegister.class}) // 注册动态多数据源 public class SpringBootSampleApplication { // 省略其他代码 } 1 2 3 4 5 6 1 2 3 4 5 6 2、配置文件配置内容为：（不包括项目中的其他配置，这里只是数据源相关的） # 主数据源，默认的 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/test spring.datasource.username=root spring.datasource.password=123456 # 更多数据源 custom.datasource.names=ds1,ds2 custom.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver custom.datasource.ds1.url=jdbc:mysql://localhost:3306/test1 custom.datasource.ds1.username=root custom.datasource.ds1.password=123456 custom.datasource.ds2.driver-class-name=com.mysql.jdbc.Driver custom.datasource.ds2.url=jdbc:mysql://localhost:3306/test2 custom.datasource.ds2.username=root custom.datasource.ds2.password=123456 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 3、使用方法 package org.springboot.sample.service; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import org.springboot.sample.datasource.TargetDataSource; import org.springboot.sample.entity.Student; import org.springboot.sample.mapper.StudentMapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import org.springframework.stereotype.Service; /** * Student Service * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月12日 */ @Service public class StudentService { @Autowired private JdbcTemplate jdbcTemplate; // MyBatis的Mapper方法定义接口 @Autowired private StudentMapper studentMapper; @TargetDataSource(name=&quot;ds2&quot;) public List&lt;Student&gt; likeName(String name){ return studentMapper.likeName(name); } public List&lt;Student&gt; likeNameByDefaultDataSource(String name){ return studentMapper.likeName(name); } /** * 不指定数据源使用默认数据源 * * @return * @author SHANHY * @create 2016年1月24日 */ public List&lt;Student&gt; getList(){ String sql = &quot;SELECT ID,NAME,SCORE_SUM,SCORE_AVG, AGE FROM STUDENT&quot;; return (List&lt;Student&gt;) jdbcTemplate.query(sql, new RowMapper&lt;Student&gt;(){ @Override public Student mapRow(ResultSet rs, int rowNum) throws SQLException { Student stu = new Student(); stu.setId(rs.getInt(&quot;ID&quot;)); stu.setAge(rs.getInt(&quot;AGE&quot;)); stu.setName(rs.getString(&quot;NAME&quot;)); stu.setSumScore(rs.getString(&quot;SCORE_SUM&quot;)); stu.setAvgScore(rs.getString(&quot;SCORE_AVG&quot;)); return stu; } }); } /** * 指定数据源 * * @return * @author SHANHY * @create 2016年1月24日 */ @TargetDataSource(name=&quot;ds1&quot;) public List&lt;Student&gt; getListByDs1(){ String sql = &quot;SELECT ID,NAME,SCORE_SUM,SCORE_AVG, AGE FROM STUDENT&quot;; return (List&lt;Student&gt;) jdbcTemplate.query(sql, new RowMapper&lt;Student&gt;(){ @Override public Student mapRow(ResultSet rs, int rowNum) throws SQLException { Student stu = new Student(); stu.setId(rs.getInt(&quot;ID&quot;)); stu.setAge(rs.getInt(&quot;AGE&quot;)); stu.setName(rs.getString(&quot;NAME&quot;)); stu.setSumScore(rs.getString(&quot;SCORE_SUM&quot;)); stu.setAvgScore(rs.getString(&quot;SCORE_AVG&quot;)); return stu; } }); } /** * 指定数据源 * * @return * @author SHANHY * @create 2016年1月24日 */ @TargetDataSource(name=&quot;ds2&quot;) public List&lt;Student&gt; getListByDs2(){ String sql = &quot;SELECT ID,NAME,SCORE_SUM,SCORE_AVG, AGE FROM STUDENT&quot;; return (List&lt;Student&gt;) jdbcTemplate.query(sql, new RowMapper&lt;Student&gt;(){ @Override public Student mapRow(ResultSet rs, int rowNum) throws SQLException { Student stu = new Student(); stu.setId(rs.getInt(&quot;ID&quot;)); stu.setAge(rs.getInt(&quot;AGE&quot;)); stu.setName(rs.getString(&quot;NAME&quot;)); stu.setSumScore(rs.getString(&quot;SCORE_SUM&quot;)); stu.setAvgScore(rs.getString(&quot;SCORE_AVG&quot;)); return stu; } }); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 要注意的是，在使用MyBatis时，注解@TargetDataSource 不能直接在接口类Mapper上使用。按上面的代码中StudentMapper为接口，代码如下： package org.springboot.sample.mapper; import java.util.List; import org.springboot.sample.entity.Student; /** * StudentMapper，映射SQL语句的接口，无逻辑实现 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月20日 */ public interface StudentMapper { // 注解 @TargetDataSource 不可以在这里使用 List&lt;Student&gt; likeName(String name); Student getById(int id); String getNameById(int id); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 请将下面几个类放到Spring Boot项目中。DynamicDataSource. Java DynamicDataSourceAspect.javaDynamicDataSourceContextHolder.javaDynamicDataSourceRegister.javaTargetDataSource.java package org.springboot.sample.datasource; import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource; /** * 动态数据源 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月22日 */ public class DynamicDataSource extends AbstractRoutingDataSource { @Override protected Object determineCurrentLookupKey() { return DynamicDataSourceContextHolder.getDataSourceType(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package org.springboot.sample.datasource; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; /** * 切换数据源Advice * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月23日 */ @Aspect @Order(-1)// 保证该AOP在@Transactional之前执行 @Component public class DynamicDataSourceAspect { private static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class); @Before(&quot;@annotation(ds)&quot;) public void changeDataSource(JoinPoint point, TargetDataSource ds) throws Throwable { String dsId = ds.name(); if (!DynamicDataSourceContextHolder.containsDataSource(dsId)) { logger.error(&quot;数据源[{}]不存在，使用默认数据源 &gt; {}&quot;, ds.name(), point.getSignature()); } else { logger.debug(&quot;Use DataSource : {} &gt; {}&quot;, ds.name(), point.getSignature()); DynamicDataSourceContextHolder.setDataSourceType(ds.name()); } } @After(&quot;@annotation(ds)&quot;) public void restoreDataSource(JoinPoint point, TargetDataSource ds) { logger.debug(&quot;Revert DataSource : {} &gt; {}&quot;, ds.name(), point.getSignature()); DynamicDataSourceContextHolder.clearDataSourceType(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package org.springboot.sample.datasource; import java.util.ArrayList; import java.util.List; public class DynamicDataSourceContextHolder { private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;String&gt;(); public static List&lt;String&gt; dataSourceIds = new ArrayList&lt;&gt;(); public static void setDataSourceType(String dataSourceType) { contextHolder.set(dataSourceType); } public static String getDataSourceType() { return contextHolder.get(); } public static void clearDataSourceType() { contextHolder.remove(); } /** * 判断指定DataSrouce当前是否存在 * * @param dataSourceId * @return * @author SHANHY * @create 2016年1月24日 */ public static boolean containsDataSource(String dataSourceId){ return dataSourceIds.contains(dataSourceId); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package org.springboot.sample.datasource; import java.util.HashMap; import java.util.Map; import javax.sql.DataSource; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.MutablePropertyValues; import org.springframework.beans.PropertyValues; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.GenericBeanDefinition; import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder; import org.springframework.boot.bind.RelaxedDataBinder; import org.springframework.boot.bind.RelaxedPropertyResolver; import org.springframework.context.EnvironmentAware; import org.springframework.context.annotation.ImportBeanDefinitionRegistrar; import org.springframework.core.convert.ConversionService; import org.springframework.core.convert.support.DefaultConversionService; import org.springframework.core.env.Environment; import org.springframework.core.type.AnnotationMetadata; /** * 动态数据源注册&lt;br/&gt; * 启动动态数据源请在启动类中（如SpringBootSampleApplication） * 添加 @Import(DynamicDataSourceRegister.class) * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月24日 */ public class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware { private static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceRegister.class); private ConversionService conversionService = new DefaultConversionService(); private PropertyValues dataSourcePropertyValues; // 如配置文件中未指定数据源类型，使用该默认值 private static final Object DATASOURCE_TYPE_DEFAULT = &quot;org.apache.tomcat.jdbc.pool.DataSource&quot;; // private static final Object DATASOURCE_TYPE_DEFAULT = // &quot;com.zaxxer.hikari.HikariDataSource&quot;; // 数据源 private DataSource defaultDataSource; private Map&lt;String, DataSource&gt; customDataSources = new HashMap&lt;&gt;(); @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;Object, Object&gt;(); // 将主数据源添加到更多数据源中 targetDataSources.put(&quot;dataSource&quot;, defaultDataSource); DynamicDataSourceContextHolder.dataSourceIds.add(&quot;dataSource&quot;); // 添加更多数据源 targetDataSources.putAll(customDataSources); for (String key : customDataSources.keySet()) { DynamicDataSourceContextHolder.dataSourceIds.add(key); } // 创建DynamicDataSource GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(DynamicDataSource.class); beanDefinition.setSynthetic(true); MutablePropertyValues mpv = beanDefinition.getPropertyValues(); mpv.addPropertyValue(&quot;defaultTargetDataSource&quot;, defaultDataSource); mpv.addPropertyValue(&quot;targetDataSources&quot;, targetDataSources); registry.registerBeanDefinition(&quot;dataSource&quot;, beanDefinition); logger.info(&quot;Dynamic DataSource Registry&quot;); } /** * 创建DataSource * * @param type * @param driverClassName * @param url * @param username * @param password * @return * @author SHANHY * @create 2016年1月24日 */ @SuppressWarnings(&quot;unchecked&quot;) public DataSource buildDataSource(Map&lt;String, Object&gt; dsMap) { try { Object type = dsMap.get(&quot;type&quot;); if (type == null) type = DATASOURCE_TYPE_DEFAULT;// 默认DataSource Class&lt;? extends DataSource&gt; dataSourceType; dataSourceType = (Class&lt;? extends DataSource&gt;) Class.forName((String) type); String driverClassName = dsMap.get(&quot;driver-class-name&quot;).toString(); String url = dsMap.get(&quot;url&quot;).toString(); String username = dsMap.get(&quot;username&quot;).toString(); String password = dsMap.get(&quot;password&quot;).toString(); DataSourceBuilder factory = DataSourceBuilder.create().driverClassName(driverClassName).url(url) .username(username).password(password).type(dataSourceType); return factory.build(); } catch (ClassNotFoundException e) { e.printStackTrace(); } return null; } /** * 加载多数据源配置 */ @Override public void setEnvironment(Environment env) { initDefaultDataSource(env); initCustomDataSources(env); } /** * 初始化主数据源 * * @author SHANHY * @create 2016年1月24日 */ private void initDefaultDataSource(Environment env) { // 读取主数据源 RelaxedPropertyResolver propertyResolver = new RelaxedPropertyResolver(env, &quot;spring.datasource.&quot;); Map&lt;String, Object&gt; dsMap = new HashMap&lt;&gt;(); dsMap.put(&quot;type&quot;, propertyResolver.getProperty(&quot;type&quot;)); dsMap.put(&quot;driver-class-name&quot;, propertyResolver.getProperty(&quot;driver-class-name&quot;)); dsMap.put(&quot;url&quot;, propertyResolver.getProperty(&quot;url&quot;)); dsMap.put(&quot;username&quot;, propertyResolver.getProperty(&quot;username&quot;)); dsMap.put(&quot;password&quot;, propertyResolver.getProperty(&quot;password&quot;)); defaultDataSource = buildDataSource(dsMap); dataBinder(defaultDataSource, env); } /** * 为DataSource绑定更多数据 * * @param dataSource * @param env * @author SHANHY * @create 2016年1月25日 */ private void dataBinder(DataSource dataSource, Environment env){ RelaxedDataBinder dataBinder = new RelaxedDataBinder(dataSource); //dataBinder.setValidator(new LocalValidatorFactory().run(this.applicationContext)); dataBinder.setConversionService(conversionService); dataBinder.setIgnoreNestedProperties(false);//false dataBinder.setIgnoreInvalidFields(false);//false dataBinder.setIgnoreUnknownFields(true);//true if(dataSourcePropertyValues == null){ Map&lt;String, Object&gt; rpr = new RelaxedPropertyResolver(env, &quot;spring.datasource&quot;).getSubProperties(&quot;.&quot;); Map&lt;String, Object&gt; values = new HashMap&lt;&gt;(rpr); // 排除已经设置的属性 values.remove(&quot;type&quot;); values.remove(&quot;driver-class-name&quot;); values.remove(&quot;url&quot;); values.remove(&quot;username&quot;); values.remove(&quot;password&quot;); dataSourcePropertyValues = new MutablePropertyValues(values); } dataBinder.bind(dataSourcePropertyValues); } /** * 初始化更多数据源 * * @author SHANHY * @create 2016年1月24日 */ private void initCustomDataSources(Environment env) { // 读取配置文件获取更多数据源，也可以通过defaultDataSource读取数据库获取更多数据源 RelaxedPropertyResolver propertyResolver = new RelaxedPropertyResolver(env, &quot;custom.datasource.&quot;); String dsPrefixs = propertyResolver.getProperty(&quot;names&quot;); for (String dsPrefix : dsPrefixs.split(&quot;,&quot;)) {// 多个数据源 Map&lt;String, Object&gt; dsMap = propertyResolver.getSubProperties(dsPrefix + &quot;.&quot;); DataSource ds = buildDataSource(dsMap); customDataSources.put(dsPrefix, ds); dataBinder(ds, env); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 package org.springboot.sample.datasource; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * 在方法上使用，用于指定使用哪个数据源 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月23日 */ @Target({ ElementType.METHOD, ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface TargetDataSource { String name(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 本文代码博主是经过测试后没有问题才发出来共享给大家的。对于连接池参数配置会应用到所有数据源上。比如配置一个： spring.datasource.maximum-pool-size=80 1 1 那么我们所有的数据源都会自动应用上。 补充：如果你使用的是SpringMVC，并集成了Shiro，一般按网上的配置你可能是： &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on=&quot;lifecycleBeanPostProcessor&quot;&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; 1 2 3 4 5 6 7 1 2 3 4 5 6 7 那么你请不要这样做，请按下面方法配置： &lt;!-- AOP式方法级权限检查 --&gt; &lt;!-- 不要使用 DefaultAdvisorAutoProxyCreator 会出现二次代理的问题，这里不详述。 mark by shanhy 2016-05-15 --&gt; &lt;aop:config proxy-target-class=&quot;true&quot;/&gt; &lt;!-- 或者你使用了 &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt; 也可以。 --&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot Shiro 权限管理","slug":"Spring Boot Shiro 权限管理","date":"2018-04-19T16:34:21.433Z","updated":"2018-04-19T16:30:08.382Z","comments":true,"path":"2018/04/20/Spring Boot Shiro 权限管理/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot Shiro 权限管理/","excerpt":"","text":"本来是打算接着写关于 数据库 方面，集成MyBatis的，刚好赶上朋友问到Shiro权限管理，就先总结下发出来了。 使用Shiro之前用在Spring MVC中，是通过XML文件进行配置。既然现在在写Spring Boot的帖子，就将Shiro应用到SpringBoot中，我本地已经完成了SpringBoot使用Shiro的实例，将配置方法共享一下。 先简单介绍一下Shiro，对于没有用过Shiro的朋友，也算是做个简介吧。Shiro是Apache下的一个开源项目，我们称之为Apache Shiro。它是一个很易用与 Java 项目的的安全框架，提供了认证、授权、加密、会话管理，与 Spring Security一样都是做一个权限的安全框架，但是与Spring Security 相比，在于 Shiro 使用了比较简单易懂易于使用的授权方式。 Apache Shiro 的三大核心组件- Subject 当前用户操作- SecurityManager 用于管理所有的Subject- Realms 用于进行权限信息的验证，也是我们需要自己实现的。 我们需要实现Realms的Authentication 和 Authorization。其中 Authentication是用来验证用户身份，Authorization 是授权访问控制，用于对用户进行的操作授权，证明该用户是否允许进行当前操作，如访问某个链接，某个资源文件等。 Apache Shiro 核心通过 Filter 来实现，就好像SpringMvc 通过DispachServlet 来主控制一样。既然是使用 Filter 一般也就能猜到，是通过URL规则来进行过滤和权限校验，所以我们需要定义一系列关于URL的规则和访问权限。 另外我们可以通过Shiro 提供的会话管理来获取Session中的信息。Shiro 也提供了缓存支持，使用 CacheManager 来管理。 官方网站： http://shiro.apache.org/ 完整 架构 图： 下面我们通过代码实战来看下Spring Boot 中应用Shiro：1、创建数据库表 表（t_permission） id permissionname role_id ------ -------------- --------- 1 add 2 2 del 1 3 update 2 4 query 3 5 user:query 1 6 user:edit 2 表（t_role） id rolename ------ ---------- 1 admin 2 manager 3 normal 表（t_user） id username password ------ -------- ---------- 1 tom 123456 2 jack 123456 3 rose 123456 表（t_user_role） user_id role_id ------- --------- 1 1 1 3 2 2 2 3 3 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 看截图，上面3张表是我测试别的用的，可以忽略。 下面是，数据库脚本和测试数据。 /* SQLyog Ultimate v10.00 Beta1 MySQL - 5.5.28 : Database - test ********************************************************************* */ /*!40101 SET NAMES utf8 */; /*!40101 SET SQL_MODE=&apos;&apos;*/; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&apos;NO_AUTO_VALUE_ON_ZERO&apos; */; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */; CREATE DATABASE /*!32312 IF NOT EXISTS*/`test` /*!40100 DEFAULT CHARACTER SET utf8 */; USE `test`; /*Table structure for table `t_permission` */ DROP TABLE IF EXISTS `t_permission`; CREATE TABLE `t_permission` ( `id` int(11) NOT NULL AUTO_INCREMENT, `permissionname` varchar(32) DEFAULT NULL, `role_id` int(11) DEFAULT NULL, KEY `id` (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; /*Data for the table `t_permission` */ insert into `t_permission`(`id`,`permissionname`,`role_id`) values (1,&apos;add&apos;,2),(2,&apos;del&apos;,1),(3,&apos;update&apos;,2),(4,&apos;query&apos;,3),(5,&apos;user:query&apos;,1),(6,&apos;user:edit&apos;,2); /*Table structure for table `t_role` */ DROP TABLE IF EXISTS `t_role`; CREATE TABLE `t_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `rolename` varchar(32) DEFAULT NULL, KEY `id` (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; /*Data for the table `t_role` */ insert into `t_role`(`id`,`rolename`) values (1,&apos;admin&apos;),(2,&apos;manager&apos;),(3,&apos;normal&apos;); /*Table structure for table `t_user` */ DROP TABLE IF EXISTS `t_user`; CREATE TABLE `t_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) DEFAULT NULL, `password` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; /*Data for the table `t_user` */ insert into `t_user`(`id`,`username`,`password`) values (1,&apos;tom&apos;,&apos;123456&apos;),(2,&apos;jack&apos;,&apos;123456&apos;),(3,&apos;rose&apos;,&apos;123456&apos;); /*Table structure for table `t_user_role` */ DROP TABLE IF EXISTS `t_user_role`; CREATE TABLE `t_user_role` ( `user_id` int(11) DEFAULT NULL, `role_id` int(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; /*Data for the table `t_user_role` */ insert into `t_user_role`(`user_id`,`role_id`) values (1,1),(1,3),(2,2),(2,3),(3,3); /*!40101 SET SQL_MODE=@OLD_SQL_MODE */; /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */; /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */; /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 2、创建对应实体类User.java package org.springboot.sample.entity; import java.util.HashSet; import java.util.List; import java.util.Set; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.JoinTable; import javax.persistence.ManyToMany; import javax.persistence.Table; import javax.persistence.Transient; import org.hibernate.validator.constraints.NotEmpty; /** * 用户 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月13日 */ @Entity @Table(name = &quot;t_user&quot;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @NotEmpty(message = &quot;用户名不能为空&quot;) private String username; @NotEmpty(message = &quot;密码不能为空&quot;) private String password; @ManyToMany(fetch=FetchType.EAGER) @JoinTable(name = &quot;t_user_role&quot;, joinColumns = { @JoinColumn(name = &quot;user_id&quot;) }, inverseJoinColumns = { @JoinColumn(name = &quot;role_id&quot;) }) private List&lt;Role&gt; roleList;// 一个用户具有多个角色 public User() { super(); } public User(String username, String password) { super(); this.username = username; this.password = password; } // 省略 get set 方法 @Transient public Set&lt;String&gt; getRolesName() { List&lt;Role&gt; roles = getRoleList(); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); for (Role role : roles) { set.add(role.getRolename()); } return set; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 Role.java package org.springboot.sample.entity; import java.util.ArrayList; import java.util.List; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.JoinTable; import javax.persistence.ManyToMany; import javax.persistence.OneToMany; import javax.persistence.Table; import javax.persistence.Transient; /** * 角色（管理员，普通用户等） * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月13日 */ @Entity @Table(name = &quot;t_role&quot;) public class Role { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String rolename; @OneToMany(mappedBy = &quot;role&quot;, fetch=FetchType.EAGER) private List&lt;Permission&gt; permissionList;// 一个角色对应多个权限 @ManyToMany @JoinTable(name = &quot;t_user_role&quot;, joinColumns = { @JoinColumn(name = &quot;role_id&quot;) }, inverseJoinColumns = { @JoinColumn(name = &quot;user_id&quot;) }) private List&lt;User&gt; userList;// 一个角色对应多个用户 // 省略 get set 方法 @Transient public List&lt;String&gt; getPermissionsName() { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); List&lt;Permission&gt; perlist = getPermissionList(); for (Permission per : perlist) { list.add(per.getPermissionname()); } return list; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 Permission.java package org.springboot.sample.entity; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.Table; /** * 权限（增删改查等） * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月13日 */ @Entity @Table(name = &quot;t_permission&quot;) public class Permission { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String permissionname; @ManyToOne @JoinColumn(name = &quot;role_id&quot;) private Role role;// 一个权限对应一个角色 // 省略 get set } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 3、Shiro 配置，相当于SpringMVC 中的XML配置ShiroConfiguration.java package org.springboot.sample.config; import java.util.LinkedHashMap; import java.util.Map; import org.apache.shiro.cache.ehcache.EhCacheManager; import org.apache.shiro.spring.LifecycleBeanPostProcessor; import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor; import org.apache.shiro.spring.web.ShiroFilterFactoryBean; import org.apache.shiro.web.mgt.DefaultWebSecurityManager; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springboot.sample.dao.IScoreDao; import org.springboot.sample.security.MyShiroRealm; import org.springboot.sample.service.StudentService; import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator; import org.springframework.boot.context.embedded.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.filter.DelegatingFilterProxy; /** * Shiro 配置 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月13日 */ @Configuration public class ShiroConfiguration { private static final Logger logger = LoggerFactory.getLogger(ShiroConfiguration.class); @Bean public EhCacheManager getEhCacheManager() { EhCacheManager em = new EhCacheManager(); em.setCacheManagerConfigFile(&quot;classpath:ehcache-shiro.xml&quot;); return em; } @Bean(name = &quot;myShiroRealm&quot;) public MyShiroRealm myShiroRealm(EhCacheManager cacheManager) { MyShiroRealm realm = new MyShiroRealm(); realm.setCacheManager(cacheManager); return realm; } /** * 注册DelegatingFilterProxy（Shiro） * 集成Shiro有2种方法： * 1. 按这个方法自己组装一个FilterRegistrationBean（这种方法更为灵活，可以自己定义UrlPattern， * 在项目使用中你可能会因为一些很但疼的问题最后采用它， 想使用它你可能需要看官网或者已经很了解Shiro的处理原理了） * 2. 直接使用ShiroFilterFactoryBean（这种方法比较简单，其内部对ShiroFilter做了组装工作，无法自己定义UrlPattern， * 默认拦截 /*） * * @param dispatcherServlet * @return * @author SHANHY * @create 2016年1月13日 */ // @Bean // public FilterRegistrationBean filterRegistrationBean() { // FilterRegistrationBean filterRegistration = new FilterRegistrationBean(); // filterRegistration.setFilter(new DelegatingFilterProxy(&quot;shiroFilter&quot;)); // // 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 // filterRegistration.addInitParameter(&quot;targetFilterLifecycle&quot;, &quot;true&quot;); // filterRegistration.setEnabled(true); // filterRegistration.addUrlPatterns(&quot;/*&quot;);// 可以自己灵活的定义很多，避免一些根本不需要被Shiro处理的请求被包含进来 // return filterRegistration; // } @Bean(name = &quot;lifecycleBeanPostProcessor&quot;) public LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() { return new LifecycleBeanPostProcessor(); } @Bean public DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() { DefaultAdvisorAutoProxyCreator daap = new DefaultAdvisorAutoProxyCreator(); daap.setProxyTargetClass(true); return daap; } @Bean(name = &quot;securityManager&quot;) public DefaultWebSecurityManager getDefaultWebSecurityManager(MyShiroRealm myShiroRealm) { DefaultWebSecurityManager dwsm = new DefaultWebSecurityManager(); dwsm.setRealm(myShiroRealm); // &lt;!-- 用户授权/认证信息Cache, 采用EhCache 缓存 --&gt; dwsm.setCacheManager(getEhCacheManager()); return dwsm; } @Bean public AuthorizationAttributeSourceAdvisor getAuthorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager) { AuthorizationAttributeSourceAdvisor aasa = new AuthorizationAttributeSourceAdvisor(); aasa.setSecurityManager(securityManager); return aasa; } /** * 加载shiroFilter权限控制规则（从数据库读取然后配置） * * @author SHANHY * @create 2016年1月14日 */ private void loadShiroFilterChain(ShiroFilterFactoryBean shiroFilterFactoryBean, StudentService stuService, IScoreDao scoreDao){ /////////////////////// 下面这些规则配置最好配置到配置文件中 /////////////////////// Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;(); // authc：该过滤器下的页面必须验证后才能访问，它是Shiro内置的一个拦截器org.apache.shiro.web.filter.authc.FormAuthenticationFilter filterChainDefinitionMap.put(&quot;/user&quot;, &quot;authc&quot;);// 这里为了测试，只限制/user，实际开发中请修改为具体拦截的请求规则 // anon：它对应的过滤器里面是空的,什么都没做 logger.info(&quot;##################从数据库读取权限规则，加载到shiroFilter中##################&quot;); filterChainDefinitionMap.put(&quot;/user/edit/**&quot;, &quot;authc,perms[user:edit]&quot;);// 这里为了测试，固定写死的值，也可以从数据库或其他配置中读取 filterChainDefinitionMap.put(&quot;/login&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/**&quot;, &quot;anon&quot;);//anon 可以理解为不拦截 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); } /** * ShiroFilter&lt;br/&gt; * 注意这里参数中的 StudentService 和 IScoreDao 只是一个例子，因为我们在这里可以用这样的方式获取到相关访问数据库的对象， * 然后读取数据库相关配置，配置到 shiroFilterFactoryBean 的访问规则中。实际项目中，请使用自己的Service来处理业务逻辑。 * * @param myShiroRealm * @param stuService * @param scoreDao * @return * @author SHANHY * @create 2016年1月14日 */ @Bean(name = &quot;shiroFilter&quot;) public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager, StudentService stuService, IScoreDao scoreDao) { ShiroFilterFactoryBean shiroFilterFactoryBean = new MShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 如果不设置默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;); // 登录成功后要跳转的连接 shiroFilterFactoryBean.setSuccessUrl(&quot;/user&quot;); shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/403&quot;); loadShiroFilterChain(shiroFilterFactoryBean, stuService, scoreDao); return shiroFilterFactoryBean; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 /** * 继承 ShiroFilterFactoryBean 处理拦截资源文件问题。 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年3月8日 */ public class MShiroFilterFactoryBean extends ShiroFilterFactoryBean { // 对ShiroFilter来说，需要直接忽略的请求 private Set&lt;String&gt; ignoreExt; public MShiroFilterFactoryBean() { super(); ignoreExt = new HashSet&lt;&gt;(); ignoreExt.add(&quot;.jpg&quot;); ignoreExt.add(&quot;.png&quot;); ignoreExt.add(&quot;.gif&quot;); ignoreExt.add(&quot;.bmp&quot;); ignoreExt.add(&quot;.js&quot;); ignoreExt.add(&quot;.css&quot;); } @Override protected AbstractShiroFilter createInstance() throws Exception { SecurityManager securityManager = getSecurityManager(); if (securityManager == null) { String msg = &quot;SecurityManager property must be set.&quot;; throw new BeanInitializationException(msg); } if (!(securityManager instanceof WebSecurityManager)) { String msg = &quot;The security manager does not implement the WebSecurityManager interface.&quot;; throw new BeanInitializationException(msg); } FilterChainManager manager = createFilterChainManager(); PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver(); chainResolver.setFilterChainManager(manager); return new MSpringShiroFilter((WebSecurityManager) securityManager, chainResolver); } private final class MSpringShiroFilter extends AbstractShiroFilter { protected MSpringShiroFilter(WebSecurityManager webSecurityManager, FilterChainResolver resolver) { super(); if (webSecurityManager == null) { throw new IllegalArgumentException(&quot;WebSecurityManager property cannot be null.&quot;); } setSecurityManager(webSecurityManager); if (resolver != null) { setFilterChainResolver(resolver); } } @Override protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws ServletException, IOException { HttpServletRequest request = (HttpServletRequest)servletRequest; String str = request.getRequestURI().toLowerCase(); // 因为ShiroFilter 拦截所有请求（在上面我们配置了urlPattern 为 * ，当然你也可以在那里精确的添加要处理的路径，这样就不需要这个类了），而在每次请求里面都做了session的读取和更新访问时间等操作，这样在集群部署session共享的情况下，数量级的加大了处理量负载。 // 所以我们这里将一些能忽略的请求忽略掉。 // 当然如果你的集群系统使用了动静分离处理，静态资料的请求不会到Filter这个层面，便可以忽略。 boolean flag = true; int idx = 0; if(( idx = str.indexOf(&quot;.&quot;)) &gt; 0){ str = str.substring(idx); if(ignoreExt.contains(str.toLowerCase())) flag = false; } if(flag){ super.doFilterInternal(servletRequest, servletResponse, chain); }else{ chain.doFilter(servletRequest, servletResponse); } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 其中的 ehcache-shiro.xml 在 src/main/resources 下面，内容为： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;ehcache updateCheck=&quot;false&quot; name=&quot;shiroCache&quot;&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; /&gt; &lt;/ehcache&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 4、继承 AuthorizingRealm 实现认证和授权2个方法MyShiroRealm.java package org.springboot.sample.security; import java.util.List; import org.apache.commons.lang3.builder.ReflectionToStringBuilder; import org.apache.commons.lang3.builder.ToStringStyle; import org.apache.shiro.authc.AuthenticationException; import org.apache.shiro.authc.AuthenticationInfo; import org.apache.shiro.authc.AuthenticationToken; import org.apache.shiro.authc.SimpleAuthenticationInfo; import org.apache.shiro.authc.UsernamePasswordToken; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springboot.sample.dao.IUserDao; import org.springboot.sample.entity.Role; import org.springboot.sample.entity.User; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; /** * MyShiroRealm * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月13日 */ public class MyShiroRealm extends AuthorizingRealm{ private static final Logger logger = LoggerFactory.getLogger(MyShiroRealm.class); @Autowired private IUserDao userDao; /** * 权限认证，为当前登录的Subject授予角色和权限 * @see 经测试：本例中该方法的调用时机为需授权资源被访问时 * @see 经测试：并且每次访问需授权资源时都会执行该方法中的逻辑，这表明本例中默认并未启用AuthorizationCache * @see 经测试：如果连续访问同一个URL（比如刷新），该方法不会被重复调用，Shiro有一个时间间隔（也就是cache时间，在ehcache-shiro.xml中配置），超过这个时间间隔再刷新页面，该方法会被执行 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { logger.info(&quot;##################执行Shiro权限认证##################&quot;); //获取当前登录输入的用户名，等价于(String) principalCollection.fromRealm(getName()).iterator().next(); String loginName = (String)super.getAvailablePrincipal(principalCollection); //到数据库查是否有此对象 User user=userDao.findByName(loginName);// 实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 if(user!=null){ //权限信息对象info,用来存放查出的用户的所有的角色（role）及权限（permission） SimpleAuthorizationInfo info=new SimpleAuthorizationInfo(); //用户的角色集合 info.setRoles(user.getRolesName()); //用户的角色对应的所有权限，如果只使用角色定义访问权限，下面的四行可以不要 List&lt;Role&gt; roleList=user.getRoleList(); for (Role role : roleList) { info.addStringPermissions(role.getPermissionsName()); } // 或者按下面这样添加 //添加一个角色,不是配置意义上的添加,而是证明该用户拥有admin角色 // simpleAuthorInfo.addRole(&quot;admin&quot;); //添加权限 // simpleAuthorInfo.addStringPermission(&quot;admin:manage&quot;); // logger.info(&quot;已为用户[mike]赋予了[admin]角色和[admin:manage]权限&quot;); return info; } // 返回null的话，就会导致任何用户访问被拦截的请求时，都会自动跳转到unauthorizedUrl指定的地址 return null; } /** * 登录认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo( AuthenticationToken authenticationToken) throws AuthenticationException { //UsernamePasswordToken对象用来存放提交的登录信息 UsernamePasswordToken token=(UsernamePasswordToken) authenticationToken; logger.info(&quot;验证当前Subject时获取到token为：&quot; + ReflectionToStringBuilder.toString(token, ToStringStyle.MULTI_LINE_STYLE)); //查出是否有此用户 User user=userDao.findByName(token.getUsername()); if(user!=null){ // 若存在，将此用户存放到登录认证info中，无需自己做密码对比，Shiro会为我们进行密码对比校验 return new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), getName()); } return null; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 注意：其中 userDao.findByName 这个代码就不贴上了，也没啥可贴的，根据姓名查询一个对象而已。 5、编写测试的 Controller 和测试 jsp 页面ShiroController.java package org.springboot.sample.controller; import java.util.Map; import javax.validation.Valid; import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.AuthenticationException; import org.apache.shiro.authc.ExcessiveAttemptsException; import org.apache.shiro.authc.IncorrectCredentialsException; import org.apache.shiro.authc.LockedAccountException; import org.apache.shiro.authc.UnknownAccountException; import org.apache.shiro.authc.UsernamePasswordToken; import org.apache.shiro.subject.Subject; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springboot.sample.dao.IUserDao; import org.springboot.sample.entity.User; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.validation.BindingResult; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.servlet.mvc.support.RedirectAttributes; /** * Shiro测试Controller * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月13日 */ @Controller public class ShiroController { private static final Logger logger = LoggerFactory.getLogger(ShiroController.class); @Autowired private IUserDao userDao; @RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET) public String loginForm(Model model){ model.addAttribute(&quot;user&quot;, new User()); return &quot;login&quot;; } @RequestMapping(value=&quot;/login&quot;,method=RequestMethod.POST) public String login(@Valid User user,BindingResult bindingResult,RedirectAttributes redirectAttributes){ if(bindingResult.hasErrors()){ return &quot;login&quot;; } String username = user.getUsername(); UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword()); //获取当前的Subject Subject currentUser = SecurityUtils.getSubject(); try { //在调用了login方法后,SecurityManager会收到AuthenticationToken,并将其发送给已配置的Realm执行必须的认证检查 //每个Realm都能在必要时对提交的AuthenticationTokens作出反应 //所以这一步在调用login(token)方法时,它会走到MyRealm.doGetAuthenticationInfo()方法中,具体验证方式详见此方法 logger.info(&quot;对用户[&quot; + username + &quot;]进行登录验证..验证开始&quot;); currentUser.login(token); logger.info(&quot;对用户[&quot; + username + &quot;]进行登录验证..验证通过&quot;); }catch(UnknownAccountException uae){ logger.info(&quot;对用户[&quot; + username + &quot;]进行登录验证..验证未通过,未知账户&quot;); redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;未知账户&quot;); }catch(IncorrectCredentialsException ice){ logger.info(&quot;对用户[&quot; + username + &quot;]进行登录验证..验证未通过,错误的凭证&quot;); redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;密码不正确&quot;); }catch(LockedAccountException lae){ logger.info(&quot;对用户[&quot; + username + &quot;]进行登录验证..验证未通过,账户已锁定&quot;); redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;账户已锁定&quot;); }catch(ExcessiveAttemptsException eae){ logger.info(&quot;对用户[&quot; + username + &quot;]进行登录验证..验证未通过,错误次数过多&quot;); redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;用户名或密码错误次数过多&quot;); }catch(AuthenticationException ae){ //通过处理Shiro的运行时AuthenticationException就可以控制用户登录失败或密码错误时的情景 logger.info(&quot;对用户[&quot; + username + &quot;]进行登录验证..验证未通过,堆栈轨迹如下&quot;); ae.printStackTrace(); redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;用户名或密码不正确&quot;); } //验证是否登录成功 if(currentUser.isAuthenticated()){ logger.info(&quot;用户[&quot; + username + &quot;]登录认证通过(这里可以进行一些认证通过后的一些系统参数初始化操作)&quot;); return &quot;redirect:/user&quot;; }else{ token.clear(); return &quot;redirect:/login&quot;; } } @RequestMapping(value=&quot;/logout&quot;,method=RequestMethod.GET) public String logout(RedirectAttributes redirectAttributes ){ //使用权限管理工具进行用户的退出，跳出登录，给出提示信息 SecurityUtils.getSubject().logout(); redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;您已安全退出&quot;); return &quot;redirect:/login&quot;; } @RequestMapping(&quot;/403&quot;) public String unauthorizedRole(){ logger.info(&quot;------没有权限-------&quot;); return &quot;403&quot;; } @RequestMapping(&quot;/user&quot;) public String getUserList(Map&lt;String, Object&gt; model){ model.put(&quot;userList&quot;, userDao.getList()); return &quot;user&quot;; } @RequestMapping(&quot;/user/edit/{userid}&quot;) public String getUserList(@PathVariable int userid){ logger.info(&quot;------进入用户信息修改-------&quot;); return &quot;user_edit&quot;; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 login.jsp &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;登录页面----${message }&lt;/h1&gt; &lt;img alt=&quot;&quot; src=&quot;${pageContext.request.contextPath }/pic.jpg&quot;&gt; &lt;form:form action=&quot;${pageContext.request.contextPath }/login&quot; commandName=&quot;user&quot; method=&quot;post&quot;&gt; 用户名：&lt;form:input path=&quot;username&quot; /&gt; &lt;form:errors path=&quot;username&quot; cssClass=&quot;error&quot; /&gt; &lt;br /&gt; 密码：&lt;form:password path=&quot;password&quot; /&gt; &lt;form:errors path=&quot;password&quot; cssClass=&quot;error&quot; /&gt; &lt;br /&gt; &lt;form:button name=&quot;button&quot;&gt;提交&lt;/form:button&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 user.jsp &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;用户列表&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;${message }&lt;/h1&gt; &lt;h1&gt;用户列表--&lt;a href=&quot;${pageContext.request.contextPath }/logout&quot;&gt;退出登录&lt;/a&gt; &lt;/h1&gt; &lt;h2&gt;权限列表&lt;/h2&gt; &lt;shiro:authenticated&gt;用户已经登录显示此内容&lt;br/&gt;&lt;/shiro:authenticated&gt;&lt;br/&gt; &lt;shiro:hasRole name=&quot;manager&quot;&gt;manager角色登录显示此内容&lt;br/&gt;&lt;/shiro:hasRole&gt; &lt;shiro:hasRole name=&quot;admin&quot;&gt;admin角色登录显示此内容&lt;br/&gt;&lt;/shiro:hasRole&gt; &lt;shiro:hasRole name=&quot;normal&quot;&gt;normal角色登录显示此内容&lt;br/&gt;&lt;/shiro:hasRole&gt;&lt;br/&gt; &lt;shiro:hasAnyRoles name=&quot;manager,admin&quot;&gt;manager or admin 角色用户登录显示此内容&lt;br/&gt;&lt;/shiro:hasAnyRoles&gt;&lt;br/&gt; &lt;shiro:principal/&gt;-显示当前登录用户名&lt;br/&gt;&lt;br/&gt; &lt;shiro:hasPermission name=&quot;add&quot;&gt;add权限用户显示此内容&lt;br/&gt;&lt;/shiro:hasPermission&gt; &lt;shiro:hasPermission name=&quot;user:query&quot;&gt;user:query权限用户显示此内容&lt;br/&gt;&lt;/shiro:hasPermission&gt; &lt;shiro:lacksPermission name=&quot;user:query&quot;&gt;不具有user:query权限的用户显示此内容 &lt;br/&gt;&lt;/shiro:lacksPermission&gt; &lt;br/&gt;所有用户列表：&lt;br/&gt; &lt;ul&gt; &lt;c:forEach items=&quot;${userList }&quot; var=&quot;user&quot;&gt; &lt;li&gt;用户名：${user.username }----密码：${user.password }----&lt;a href=&quot;${pageContext.request.contextPath }/user/edit/${user.id}&quot;&gt;修改用户（测试根据不同用户可访问权限不同，本例tom无权限，jack有权限）&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt; &lt;img alt=&quot;&quot; src=&quot;${pageContext.request.contextPath }/pic.jpg&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/webjarslocator/jquery/jquery.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 user_edit.jsp &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;用户信息 - 修改&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;修改用户信息页面&lt;/h2&gt;&lt;br/&gt; &lt;a href=&quot;${pageContext.request.contextPath }/user&quot;&gt;返回用户列表&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 403.jsp &lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;权限错误&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;对不起，您没有权限请求此连接！&lt;/h1&gt; &lt;img alt=&quot;&quot; src=&quot;${pageContext.request.contextPath }/pic.jpg&quot;&gt; &lt;/body&gt; &lt;/html&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 其中的pic.jpg 是测试代码遗留的，没有任何用处。关于 Controller 和 JSP 页面本文不做介绍，关于Spring Boot使用Controller 和 JSP ，前面已经有文章介绍。 启动服务后访问 http://localhost:8080/myspringboot/user 会自动跳到 login 页面。登录成功后，会打开 user 页面（关于默认登录页、成功成功URL、没有权限URL，在 ShiroConfiguration 中已经配置）。在 user 页面上，不同用户会根据权限不同显示不同的内容，下面的修改操作也已经有文字说明，更换账号测试便知。 然后我们在实际项目中：不但要在页面上控制不同权限隐藏或将某些操作设置为不可用状态，还要在实际上控制那个操作背后的请求是真的不可以使用的。（例如：页面上的修改按钮已经灰化了，而我知道了修改按钮正常情况下点击会触发的请求，此时我直接模拟这个修改请求，应当是没有权限的才对，这样才算是真正的控制了权限。） 附： Filter Chain定义说明 1、一个URL可以配置多个Filter，使用逗号分隔2、当设置多个过滤器时，全部验证通过，才视为通过3、部分过滤器可指定参数，如perms，roles Shiro内置的FilterChain Filter Name Class anon org.apache.shiro.web.filter.authc.AnonymousFilter authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter authcBasic org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter port org.apache.shiro.web.filter.authz.PortFilter rest org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter roles org.apache.shiro.web.filter.authz.RolesAuthorizationFilter ssl org.apache.shiro.web.filter.authz.SslFilter user org.apache.shiro.web.filter.authc.UserFilter","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"},{"name":"shiro","slug":"shiro","permalink":"https://www.itchina.top/tags/shiro/"}]},{"title":"Spring Boot Servlet","slug":"Spring Boot Servlet","date":"2018-04-19T16:34:21.432Z","updated":"2018-04-19T16:30:13.789Z","comments":true,"path":"2018/04/20/Spring Boot Servlet/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot Servlet/","excerpt":"","text":"上一篇我们对如何创建Controller 来响应JSON 以及如何显示数据到页面中，已经有了初步的了解。Web开发使用 Controller 基本上可以完成大部分需求，但是我们还可能会用到 Servlet、Filter、Listener、Interceptor等等。 当使用Spring-Boot时，嵌入式Servlet容器通过扫描注解的方式注册Servlet、Filter和Servlet规范的所有监听器（如HttpSessionListener监听器）。Spring boot 的主 Servlet 为 DispatcherServlet，其默认的url-pattern为“/”。也许我们在应用中还需要定义更多的Servlet，该如何使用SpringBoot来完成呢？ 在spring boot中添加自己的Servlet有两种方法，代码注册Servlet和注解自动注册（Filter和Listener也是如此）。一、代码注册通过ServletRegistrationBean、 FilterRegistrationBean 和ServletListenerRegistrationBean 获得控制。也可以通过实现 ServletContextInitializer 接口直接注册。 二、在 SpringBootApplication 上使用@ServletComponentScan 注解后，Servlet、Filter、Listener可以直接通过 @WebServlet、@WebFilter、@WebListener 注解自动注册，无需其他代码。 通过代码注册Servlet示例代码： SpringBootSampleApplication. Java package org.springboot.sample; import org.springboot.sample.servlet.MyServlet; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.embedded.ServletRegistrationBean; import org.springframework.boot.web.servlet.ServletComponentScan; import org.springframework.context.annotation.Bean; import org.springframework.web.servlet.DispatcherServlet; @SpringBootApplication public class SpringBootSampleApplication { /** * 使用代码注册Servlet（不需要@ServletComponentScan注解） * * @return * @author SHANHY * @create 2016年1月6日 */ @Bean public ServletRegistrationBean servletRegistrationBean() { return new ServletRegistrationBean(new MyServlet(), &quot;/xs/*&quot;);// ServletName默认值为首字母小写，即myServlet } public static void main(String[] args) { SpringApplication.run(SpringBootSampleApplication.class, args); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 MyServlet.java package org.springboot.sample.servlet; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * Servlet * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月6日 */ //@WebServlet(urlPatterns=&quot;/xs/*&quot;, description=&quot;Servlet的说明&quot;) public class MyServlet extends HttpServlet{ private static final long serialVersionUID = -8685285401859800066L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;doGet()&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;doPost()&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); resp.setContentType(&quot;text/html&quot;); PrintWriter out = resp.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;Hello World&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;大家好，我的名字叫Servlet&lt;/h1&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 使用注解注册Servlet示例代码 SpringBootSampleApplication.java package org.springboot.sample; import org.springboot.sample.servlet.MyServlet; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.embedded.ServletRegistrationBean; import org.springframework.boot.web.servlet.ServletComponentScan; import org.springframework.context.annotation.Bean; import org.springframework.web.servlet.DispatcherServlet; @SpringBootApplication @ServletComponentScan public class SpringBootSampleApplication { public static void main(String[] args) { SpringApplication.run(SpringBootSampleApplication.class, args); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 MyServlet2.java package org.springboot.sample.servlet; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * Servlet * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月6日 */ @WebServlet(urlPatterns=&quot;/xs/myservlet&quot;, description=&quot;Servlet的说明&quot;) // 不指定name的情况下，name默认值为类全路径，即org.springboot.sample.servlet.MyServlet2 public class MyServlet2 extends HttpServlet{ private static final long serialVersionUID = -8685285401859800066L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;doGet2()&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;doPost2()&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;); resp.setContentType(&quot;text/html&quot;); PrintWriter out = resp.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;Hello World&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;大家好，我的名字叫Servlet2&lt;/h1&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 使用 @WebServlet 注解，其中可以设置一些属性。 有个问题：DispatcherServlet 默认拦截“/”，MyServlet 拦截“/xs/*”，MyServlet2拦截“/xs/myservlet”，那么在我们访问 http://localhost:8080/xs/myservlet 的时候系统会怎么处理呢？如果访问 http://localhost:8080/xs/abc 的时候又是什么结果呢？这里就不给大家卖关子了，其结果是“匹配的优先级是从精确到模糊，复合条件的Servlet并不会都执行” 既然系统DispatcherServlet默认拦截“/”，那么我们是否能做修改呢，答案是肯定的，我们在SpringBootSampleApplication中添加代码： /** * 修改DispatcherServlet默认配置 * * @param dispatcherServlet * @return * @author SHANHY * @create 2016年1月6日 */ @Bean public ServletRegistrationBean dispatcherRegistration(DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean(dispatcherServlet); registration.getUrlMappings().clear(); registration.addUrlMappings(&quot;*.do&quot;); registration.addUrlMappings(&quot;*.json&quot;); return registration; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 当然，这里可以对DispatcherServlet做很多修改，并非只是UrlMappings。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Spring Boot MyBatis 连接数据库","slug":"Spring Boot MyBatis 连接数据库","date":"2018-04-19T16:34:21.432Z","updated":"2018-04-19T16:30:10.117Z","comments":true,"path":"2018/04/20/Spring Boot MyBatis 连接数据库/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot MyBatis 连接数据库/","excerpt":"","text":"最近比较忙，没来得及抽时间把MyBatis的集成发出来，其实mybatis官网在2015年11月底就已经发布了对SpringBoot集成的Release版本，Github上有代码： https://github.com/mybatis/mybatis-spring-boot 前面对JPA和JDBC连接 数据库 做了说明，本文也是参考官方的代码做个总结。 先说个题外话，SpringBoot默认使用 org.apache.tomcat.jdbc.pool.DataSource现在有个叫 HikariCP 的JDBC连接池组件，据说其性能比常用的 c3p0、tomcat、bone、vibur 这些要高很多。我打算把工程中的DataSource变更为HirakiDataSource，做法很简单：首先在application.properties配置文件中指定dataSourceType spring.datasource.type=com.zaxxer.hikari.HikariDataSource 1 1 然后在pom中添加Hikari的依赖 &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;!-- 版本号可以不用指定，Spring Boot会选用合适的版本 --&gt; &lt;/dependency&gt; 1 2 3 4 5 1 2 3 4 5 言归正传，下面说在Spring Boot中配置MyBatis。关于在Spring Boot中集成MyBatis，可以选用基于注解的方式，也可以选择xml文件配置的方式。通过对两者进行实际的使用，还是建议使用XML的方式（官方也建议使用XML）。 下面将介绍通过xml的方式来实现查询，其次会简单说一下注解方式，最后会附上分页插件（PageHelper）的集成。 一、通过xml配置文件方式1、添加pom依赖&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;!-- 请不要使用1.0.0版本，因为还不支持拦截器插件，1.0.1-SNAPSHOT 是博主写帖子时候的版本，大家使用最新版本即可 --&gt; &lt;version&gt;1.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 1 2 3 4 5 6 1 2 3 4 5 6 2、创建接口Mapper（不是类）和对应的Mapper.xml文件定义相关方法，注意方法名称要和Mapper.xml文件中的id一致，这样会自动对应上StudentMapper. Java package org.springboot.sample.mapper; import java.util.List; import org.springboot.sample.entity.Student; /** * StudentMapper，映射SQL语句的接口，无逻辑实现 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月20日 */ public interface StudentMapper extends MyMapper&lt;Student&gt; { List&lt;Student&gt; likeName(String name); Student getById(int id); String getNameById(int id); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 MyMapper.java package org.springboot.sample.config.mybatis; import tk.mybatis.mapper.common.Mapper; import tk.mybatis.mapper.common.MySqlMapper; /** * 被继承的Mapper，一般业务Mapper继承它 * */ public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; { //TODO //FIXME 特别注意，该接口不能被扫描到，否则会出错 } 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 StudentMapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;org.springboot.sample.mapper.StudentMapper&quot;&gt; &lt;!-- type为实体类Student，包名已经配置，可以直接写类名 --&gt; &lt;resultMap id=&quot;stuMap&quot; type=&quot;Student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;result property=&quot;sumScore&quot; column=&quot;score_sum&quot; /&gt; &lt;result property=&quot;avgScore&quot; column=&quot;score_avg&quot; /&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;getById&quot; resultMap=&quot;stuMap&quot; resultType=&quot;Student&quot;&gt; SELECT * FROM STUDENT WHERE ID = #{id} &lt;/select&gt; &lt;select id=&quot;likeName&quot; resultMap=&quot;stuMap&quot; parameterType=&quot;string&quot; resultType=&quot;list&quot;&gt; SELECT * FROM STUDENT WHERE NAME LIKE CONCAT(&apos;%&apos;,#{name},&apos;%&apos;) &lt;/select&gt; &lt;select id=&quot;getNameById&quot; resultType=&quot;string&quot;&gt; SELECT NAME FROM STUDENT WHERE ID = #{id} &lt;/select&gt; &lt;/mapper&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 3、实体类package org.springboot.sample.entity; import java.io.Serializable; /** * 学生实体 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月12日 */ public class Student implements Serializable{ private static final long serialVersionUID = 2120869894112984147L; private int id; private String name; private String sumScore; private String avgScore; private int age; // get set 方法省略 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 4、修改application.properties 配置文件mybatis.mapper-locations=classpath*:org/springboot/sample/mapper/sql/mysql/*Mapper.xml mybatis.type-aliases-package=org.springboot.sample.entity 1 2 1 2 5、在Controller或Service调用方法测试@Autowired private StudentMapper stuMapper; @RequestMapping(&quot;/likeName&quot;) public List&lt;Student&gt; likeName(@RequestParam String name){ return stuMapper.likeName(name); } 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 二、使用注解方式查看官方git上的代码使用注解方式，配置上很简单，使用上要对注解多做了解。至于xml和注解这两种哪种方法好，众口难调还是要看每个人吧。 1、启动类（我的）中添加@MapperScan注解@SpringBootApplication @MapperScan(&quot;sample.mybatis.mapper&quot;) public class SampleMybatisApplication implements CommandLineRunner { @Autowired private CityMapper cityMapper; public static void main(String[] args) { SpringApplication.run(SampleMybatisApplication.class, args); } @Override public void run(String... args) throws Exception { System.out.println(this.cityMapper.findByState(&quot;CA&quot;)); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 2、在接口上使用注解定义CRUD语句package sample.mybatis.mapper; import org.apache.ibatis.annotations.Param; import org.apache.ibatis.annotations.Select; import sample.mybatis.domain.City; /** * @author Eddú Meléndez */ public interface CityMapper { @Select(&quot;SELECT * FROM CITY WHERE state = #{state}&quot;) City findByState(@Param(&quot;state&quot;) String state); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 其中City就是一个普通Java类。关于MyBatis的注解，有篇文章讲的很清楚，可以参考： http://blog.csdn.net/luanlouis/article/details/35780175 三、集成分页插件这里与其说集成分页插件，不如说是介绍如何集成一个plugin。MyBatis提供了拦截器接口，我们可以实现自己的拦截器，将其作为一个plugin装入到SqlSessionFactory中。Github上有位开发者写了一个分页插件，我觉得使用起来还可以，挺方便的。Github项目地址： https://github.com/pagehelper/Mybatis-PageHelper 下面简单介绍下：首先要说的是，Spring在依赖注入bean的时候，会把所有实现MyBatis中Interceptor接口的所有类都注入到SqlSessionFactory中，作为plugin存在。既然如此，我们集成一个plugin便很简单了，只需要使用@Bean创建PageHelper对象即可。 1、添加pom依赖&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; 1 2 3 4 5 1 2 3 4 5 2、新增MyBatisConfiguration.javapackage org.springboot.sample.config; import java.util.Properties; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.github.pagehelper.PageHelper; /** * MyBatis 配置 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月21日 */ @Configuration public class MyBatisConfiguration { private static final Logger logger = LoggerFactory.getLogger(MyBatisConfiguration.class); @Bean public PageHelper pageHelper() { logger.info(&quot;注册MyBatis分页插件PageHelper&quot;); PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty(&quot;offsetAsPageNum&quot;, &quot;true&quot;); p.setProperty(&quot;rowBoundsWithCount&quot;, &quot;true&quot;); p.setProperty(&quot;reasonable&quot;, &quot;true&quot;); pageHelper.setProperties(p); return pageHelper; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 3、分页查询测试@RequestMapping(&quot;/likeName&quot;) public List&lt;Student&gt; likeName(@RequestParam String name){ PageHelper.startPage(1, 1); return stuMapper.likeName(name); } 1 2 3 4 5 1 2 3 4 5 更多参数使用方法，详见PageHelper说明文档（上面的Github地址）。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"},{"name":"mybatis","slug":"mybatis","permalink":"https://www.itchina.top/tags/mybatis/"}]},{"title":"Spring Boot JPA 连接数据库","slug":"Spring Boot JPA 连接数据库","date":"2018-04-19T16:34:21.431Z","updated":"2018-04-19T16:30:10.560Z","comments":true,"path":"2018/04/20/Spring Boot JPA 连接数据库/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot JPA 连接数据库/","excerpt":"","text":"本文将介绍如何在Spring Boot 工程中添加JPA作为持久化方式。 修改 pom.xml 依赖与上一篇介绍的 jdbc 不同的是 spring-boot-starter-jdbc 修改为 spring-boot-starter-data-jpa即可，当然 数据库 驱动包也是不可少的，如下： &lt;!-- MYSQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot JPA --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 注意：如果你想JDBC和JPA可以一起使用，Spring Boot 是支持的，你只需要把JDBC和JPA的依赖都添加在pom.xml中即可。无需其他特殊处理，有关JDBC的使用介绍请看上一篇 “ Spring-Boot JDBC 连接数据库 ”。 修改属性配置文件在属性配置文件中添加 JPA 相关属性，注意这些并非必须，我们如果只添加dataSource 的 url\\username\\password\\driver-class-name 也可以正常使用，有关JPA的其他配置都是可选的。 spring.jpa.database= spring.jpa.show-sql= spring.jpa.properties= spring.jpa.generate-ddl= spring.jpa.open-in-view= spring.jpa.database-platform= spring.jpa.hibernate.ddl-auto= spring.data.jpa.repositories.enabled= spring.jpa.hibernate.naming-strategy= 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 熟悉JPA的根据名字应基本知道这些分别的作用了。 传统上，JPA实体类在persistence.xml文件中指定的。使用Spring Boot，这个文件是没有必要的，因为它使用“实体扫描”，默认情况下主配置@EnableAutoConfiguration 或 @SpringBootApplication 下面的所有包都将会被扫描。任何使用注解 @Entity,@Embeddable 或 @MappedSuperclass 的类都将被管理。 Java代码实例 一个接口 一个Controller 我们创建一个接口 IScoreDao. Java ，然后我们继承框架为我们提供好的接口Repository 或 CrudRepository （CrudRepository 继承自Repository），其中为我们提供了对数据库的基本操作方法。 package org.springboot.sample.dao; import java.util.List; import javax.transaction.Transactional; import org.springboot.sample.entity.Score; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.CrudRepository; import org.springframework.data.repository.query.Param; public interface IScoreDao extends CrudRepository&lt;Score, Integer&gt; { @Transactional @Modifying @Query(&quot;update Score t set t.score = :score where t.id = :id&quot;) int updateScoreById(@Param(&quot;score&quot;) float score, @Param(&quot;id&quot;) int id); @Query(&quot;select t from Score t &quot;) List&lt;Score&gt; getList(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 注意，如果你其中使用了修改、新增、删除操作，则必须要在接口上面或者对应的方法上面添加 @Transactional 注解，否则会抛出异常。 实体类 Score.java package org.springboot.sample.entity; import java.io.Serializable; import java.util.Date; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.Table; /** * 成绩 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月12日 */ @Entity @Table(name = &quot;score&quot;) public class Score implements Serializable { private static final long serialVersionUID = 8127035730921338189L; @Id @GeneratedValue private int id; @Column(nullable = false, name=&quot;STUDENTID&quot;) // 这里说一下，我使用指定数据库列的时候，使用小写会不起作用，修改为大写便正常了。不知道为何，如果遇到一样问题的可以尝试下。 private int stuId; @Column(nullable = false, name=&quot;SUBJECTNAME&quot;) private String subjectName; @Column(nullable = false) private float score; @Column(nullable = false, name=&quot;EXAMTIME&quot;) private Date examTime; // 省去get、set 方法（占用文章空间） } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ScoreController.java package org.springboot.sample.controller; import java.util.List; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springboot.sample.dao.IScoreDao; import org.springboot.sample.entity.Score; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(&quot;/score&quot;) public class ScoreController { private static final Logger logger = LoggerFactory.getLogger(ScoreController.class); @Autowired private IScoreDao scoreService; @RequestMapping(&quot;/scoreList&quot;) public List&lt;Score&gt; getScoreList(){ logger.info(&quot;从数据库读取Score集合&quot;); // 测试更新数据库 logger.info(&quot;更新的行数：&quot; + scoreService.updateScoreById(88.8f, 2)); scoreService.delete(23); return scoreService.getList(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 然后在浏览器访问地址： http://localhost:8080/myspringboot/score/scoreList 测试。 最后要说明的是，Spring 会自动为我们继承CrudRepository接口的接口创建实现类。我们只需要在使用的时候直接使用注解 @Autowired注入即可（IScoreDao 接口上也没有必要增加 @Component 、 @Repository 等注解）。还有，我这里为了简单起见，直接将操作数据库的在Controller中使用，实际项目中，是不建议这样做的，IScoreDao的所属角色是数据库持久，我们还应当有 Service（如ScoreService） 来调用 IScoreDao 的方法，然后在Controller 中调用Service 中的方法。原因是因为，我们数据库访问层，都是接口定义方法，上面注解注入SQL和参数，没有具体的代码逻辑处理。如果我们想在执行SQL之前或之后执行逻辑处理，只能在 Service 中或者Controller（不建议）中。我们严格按照这种方式去做（持久层只与SQL有关，通过接口定义无逻辑处理），这样才是彻彻底底的持久层。越严格的规范制度，在某种程度上来说其实越有利于代码的管理和项目代码的迭代发展。 当然，如果你实在想要实现自己的 class 实现类，下面会附上一个实例代码，在此之前，我们先看一个图片： 这个图是Spring 使用动态代理创建的接口实例，可以看出，其使用的是 SimpleJpaRepository 类，所以如果我们实现自己的Repository ，可以扩展 SimpleJpaRepository 并 实现自己的 factory-class 入手，这里不做详解。注意凡事实现Repository 接口的实现类都不需要添加 @Repository 注解，否则你会遇到问题。 本文介绍JPA 相比上一篇关于JDBC 的介绍增加的文件工程截图为： 熟悉其中一种持久数据的方法后，其他类似的都大同小异。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"},{"name":"jpa","slug":"jpa","permalink":"https://www.itchina.top/tags/jpa/"}]},{"title":"Spring Boot JDBC 连接数据库","slug":"Spring Boot JDBC 连接数据库","date":"2018-04-19T16:34:21.430Z","updated":"2018-04-19T16:30:10.979Z","comments":true,"path":"2018/04/20/Spring Boot JDBC 连接数据库/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot JDBC 连接数据库/","excerpt":"","text":"文本将对在Spring Boot构建的Web应用中，基于 MySQL 数据库 的几种数据库连接方式进行介绍。包括JDBC、JPA、MyBatis、多数据源和事务。 JDBC 连接数据库1、属性配置文件（application.properties） spring.datasource.url=jdbc:mysql://localhost:3306/test spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.jdbc.Driver 1 2 3 4 1 2 3 4 如果使用JNDI，则可以替代 spring.datasource 的 url、username、password，如： spring.datasource.jndi-name=java:tomcat/datasources/example 1 1 值得一提的是，无论是Spring Boot默认的DataSource配置还是你自己的DataSourcebean，都会引用到外部属性文件中的属性配置。所以假设你自定义的DataSourcebean，你可以在定义bean时设置属性，也可以在属性文件中，以“spring.datasource.*”的方式使属性配置外部化。 2、pom.xml 配置maven依赖 &lt;!-- MYSQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot JDBC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 3、 Java 代码范例 StudentService.java package org.springboot.sample.service; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import org.springboot.sample.entity.Student; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import org.springframework.stereotype.Service; /** * Studeng Service * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月12日 */ @Service public class StudentService { @Autowired private JdbcTemplate jdbcTemplate; public List&lt;Student&gt; getList(){ String sql = &quot;SELECT ID,NAME,SCORE_SUM,SCORE_AVG, AGE FROM STUDENT&quot;; return (List&lt;Student&gt;) jdbcTemplate.query(sql, new RowMapper&lt;Student&gt;(){ @Override public Student mapRow(ResultSet rs, int rowNum) throws SQLException { Student stu = new Student(); stu.setId(rs.getInt(&quot;ID&quot;)); stu.setAge(rs.getInt(&quot;AGE&quot;)); stu.setName(rs.getString(&quot;NAME&quot;)); stu.setSumScore(rs.getString(&quot;SCORE_SUM&quot;)); stu.setAvgScore(rs.getString(&quot;SCORE_AVG&quot;)); return stu; } }); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 Student.java 实体类 package org.springboot.sample.entity; import java.io.Serializable; /** * 学生实体 * * @author 单红宇(365384722) * @myblog http://blog.csdn.net/catoop/ * @create 2016年1月12日 */ public class Student implements Serializable{ private static final long serialVersionUID = 2120869894112984147L; private int id; private String name; private String sumScore; private String avgScore; private int age; // 节省文章长度，get set 方法省略 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 StudentController.java package org.springboot.sample.controller; import java.util.List; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springboot.sample.entity.Student; import org.springboot.sample.service.StudentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(&quot;/stu&quot;) public class StudentController { private static final Logger logger = LoggerFactory.getLogger(StudentController.class); @Autowired private StudentService studentService; @RequestMapping(&quot;/list&quot;) public List&lt;Student&gt; getStus(){ logger.info(&quot;从数据库读取Student集合&quot;); return studentService.getList(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 本文对工程添加文件后工程结构图： 然后启动项目，访问地址： http://localhost:8080/myspringboot/stu/list 响应结果如下： [ { id: 1, name: &quot;小明&quot;, sumScore: &quot;252&quot;, avgScore: &quot;84&quot;, age: 1 }, { id: 2, name: &quot;小王&quot;, sumScore: &quot;187&quot;, avgScore: &quot;62.3&quot;, age: 1 }, { id: 3, name: &quot;莉莉&quot;, sumScore: &quot;&quot;, avgScore: &quot;&quot;, age: 0 }, { id: 4, name: &quot;柱子&quot;, sumScore: &quot;230&quot;, avgScore: &quot;76.7&quot;, age: 1 }, { id: 5, name: &quot;大毛&quot;, sumScore: &quot;&quot;, avgScore: &quot;&quot;, age: 0 }, { id: 6, name: &quot;亮子&quot;, sumScore: &quot;0&quot;, avgScore: &quot;0&quot;, age: 1 } ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 连接池说明Tomcat7之前，Tomcat本质应用了DBCP连接池技术来实现的JDBC数据源，但在Tomcat7之后，Tomcat提供了新的JDBC连接池方案，作为DBCP的替换或备选方案，解决了许多之前使用DBCP的不利之处，并提高了性能。详细请参考： http://wiki.jikexueyuan.com/project/tomcat/tomcat-jdbc-pool.html Spring Boot为我们准备了最佳的数据库连接池方案，只需要在属性文件（例如application.properties）中配置需要的连接池参数即可。我们使用Tomcat数据源连接池，需要依赖tomcat-jdbc，只要应用中添加了spring-boot-starter-jdbc 或 spring-boot-starter-data-jpa依赖，则无需担心这点，因为将会自动添加 tomcat-jdbc 依赖。假如我们想用其他方式的连接池技术，只要配置自己的DataSource bean，即可覆盖Spring Boot的自动配置。 请看我的数据源配置： spring.datasource.url=jdbc:mysql://localhost:3306/test spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.max-idle=10 spring.datasource.max-wait=10000 spring.datasource.min-idle=5 spring.datasource.initial-size=5 spring.datasource.validation-query=SELECT 1 spring.datasource.test-on-borrow=false spring.datasource.test-while-idle=true spring.datasource.time-between-eviction-runs-millis=18800 spring.datasource.jdbc-interceptors=ConnectionState;SlowQueryReport(threshold=0) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 配置过连接池的开发人员对这些属性的意义都有所认识。 我们打开DEBUG日志输出，logback.xml 中添加： &lt;logger name=&quot;org.springframework.boot&quot; level=&quot;DEBUG&quot;/&gt; 1 1 然后启动项目，注意观察日志输出，如下图中会显示自动启用了连接池：我在上面的数据源配置中添加了过滤器，并设置了延迟时间为0（故意设置很低，实际项目中请修改）： spring.datasource.jdbc-interceptors=ConnectionState;SlowQueryReport(threshold=0) 1 1 这个时候，我们访问 http://localhost:8080/myspringboot/stu/list 观察日志，会发现框架自动将大于该时间的数据查询进行警告输出，如下： 2016-01-12 23:27:06.710 WARN 17644 --- [nio-8080-exec-1] o.a.t.j.p.interceptor.SlowQueryReport : Slow Query Report SQL=SELECT ID,NAME,SCORE_SUM,SCORE_AVG, AGE FROM STUDENT; time=3 ms; 1 1","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[]},{"title":"SEO搜索引擎优化步骤建议","slug":"SEO搜索引擎优化步骤建议","date":"2018-04-19T16:34:21.429Z","updated":"2018-04-19T16:30:22.818Z","comments":true,"path":"2018/04/20/SEO搜索引擎优化步骤建议/","link":"","permalink":"https://www.itchina.top/2018/04/20/SEO搜索引擎优化步骤建议/","excerpt":"","text":"SEO搜索引擎优化怎么操作？SEO搜索引擎优化有哪些注意事项？这些在这篇文章里将介绍，不周之处请指正。 1：三大标签的优化 (1)标题title：简短精炼，高度概括，要含有关键词，关键词不要超过4个 (2)描述des cription：用简短的句子告诉搜索引擎和访问者关于本网页的主要内容。 重复Title关键词，描述要注意以下问题 A、描述中出现关键词 B、描述与正文内容相关,让人感兴趣,吸引用户点击 C、字符数不超过120个汉字 关键词keywords：每个词在内容中找到相应的匹配才有利于排名。重复Title关键词 2:文章标题的优化 (1)标题要独一无二 (2)标题中添加长尾关键词 (3)标题的关键词要和内容呼应 3: 站内的互相连接 (1)文章内容相互链接 (2)利用网站后台添加锚文本 4:广告创意 (A)设计有强大营销能力的标题 (1)标题中布局关键词 (2)标题中要有具体的数据，包含价格以及促销内容 (3)标题要体现企业的公信力 (4)使用富有号召力的词汇，推动用户点击。 (5)申请、注册、报名、咨询、拨打等行动色彩的动词 (6)立即马上现在等营造紧迫感的时间副词 (7) 疑问句更能引起好奇 (B) 推广的广告要让人点击，创意要做到 (1)创意形式多样创新 (2)根据客户搜索行为撰写，保证相关性 (3)B2B类创意：突出地域、产品质量和公信力 (4)C类创意推出价格、促销产品信息 5: 搜索引擎优化重点 一 ： 搜索引擎排名原理 1、提供搜索关键词匹配度高的内容 2、原创有特色的内容 3、经常更新的网页 4、受到其他有价值的网页推荐的网页 二： 站内优化执行 (1)： 关键词优化 1、关键词越靠前，作用越大 2、网站名称要含有关键词 3、网站的可以有4个左右关键词 4、关键词之间用_隔开 不占字符 5、关键词难度梯度设置 (2)：内部链接优化 1、添加文章内部链接 2、导出链接与网站主题相关联 3、站内不要出现死链接 (3)文字内容优化 1、网站内容经常更新 2、标题唯一，网上无大量重复 3、内页优化长尾关键词，标题中含有 4、文章原创或者伪原创处理 (4) 目标关键词站内优化 1、三个标签写法 2、首页关键词布局 E型 F型 3、目标词密度 2%-8% 4、确定首选域URL标准化，绝对和相对地址 5、nofollow标签 rel=”nofollow” 联系我们或者站外链页面（友链除外） 6、位置导航(面包屑导航) 7、站内定向锚文本 8、次导航 9、404页面 10、Robots.txt【爬虫协议、爬虫规则、机器人协议】 11、Sitemap【网站地图】 12、权重页 首页 核心产品内页 一般的文章页 13、站内站策略 14、网站收录量【解决内容难题】 15、外链建设 (5)长尾关键词站内优化 1、四处一词 2、长尾关键词记录单 三：站外优化 (1)：常用的外部优化6大门户 一、百度 1、百度百科，问答、文库、空间、经验、身边 2、用不同的ip注册不同的账号以及密码 3、发布文章信息用不同的ip地址发布 4、标题中需要有优化的关键词 二、行业门户网站优化 1、发布信息标题要做关键词优化 2、分区域进行注册，每天注册5个B2B网址+每个网址发布独立标题供应信息5条以上+90天 3、B2B信息要乱箭启发，以量取胜 标题写法：品牌+型号+用途+尺寸+颜色+特点+促销语 四、问答平台 1.百度知道 2.搜搜问问 3.好搜问答 4.新浪爱问 6.天涯问答 选择以上问答平台的热门及客户关心的关键词进行优化，账号的注册及管理，问答的设计多回答不同类型的问题等。 五、友情链接 1、寻找pr值&gt;自身的网站进行互链 2、网站的相关性 3、链接时用关键词链接 4、快照要新 5、更新要频繁 6、关键词排名","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.itchina.top/categories/web前端/"}],"tags":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://www.itchina.top/tags/搜索引擎/"},{"name":"优化","slug":"优化","permalink":"https://www.itchina.top/tags/优化/"},{"name":"seo","slug":"seo","permalink":"https://www.itchina.top/tags/seo/"}]},{"title":"Spring Boot Controller","slug":"Spring Boot Controller","date":"2018-04-19T16:34:21.429Z","updated":"2018-04-19T16:30:14.752Z","comments":true,"path":"2018/04/20/Spring Boot Controller/","link":"","permalink":"https://www.itchina.top/2018/04/20/Spring Boot Controller/","excerpt":"","text":"接上篇文章，HelloWorld程序中我们已经创建了一个HellController，里面包含了响应JSON的方法，本文针对Controller再做一下讲解。 回顾上篇文章，我们在Controller中使用 @RestController 注解，该注解是Spring 4.0引入的。查看源码可知其包含了@Controller 和 @ResponseBody 注解。我们可以理解为 @Controller的增强版。专门为响应内容式的 Controller而设计的，可以直接响应对象为JSON。而 @Controller 用来响应页面，spring-boot 支持多种模版引擎包括：1，FreeMarker2，Groovy3，Thymeleaf （Spring 官网使用这个）4，Velocity5，JSP （貌似Spring Boot官方不推荐，STS创建的项目会在src/main/resources 下有个templates目录，这里就是让我们放模版文件的，然后并没有生成诸如 SpringMVC 中的webapp目录）不过本文还是选择大家都熟悉的JSP来举例，因为使用JSP与默认支持的模版需要特殊处理，所以拿来举例更好。 关于Controller方法可以接收参数使用@RequestBody、@RequestParam、@ModelAttribute、JSONObject、HttpEntity等方式，皆与Spring的使用一样，这里不做赘述。 下面我们来说一下如何使用 @Controller 实现响应JSP页面（与SpringMVC也是一样使用）。创建PageController，编码如下： package org.springboot.sample.controller; import java.util.Date; import java.util.Map; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; @Controller public class PageController { // 从 application.properties 中读取配置，如取不到默认值为Hello Shanhy @Value(&quot;${application.hell:Hello Shanhy}&quot;) private String hello = &quot;Hello Shanhy&quot;; /** * 默认页&lt;br/&gt; * @RequestMapping(&quot;/&quot;) 和 @RequestMapping 是有区别的 * 如果不写参数，则为全局默认页，加入输入404页面，也会自动访问到这个页面。 * 如果加了参数“/”，则只认为是根页面。 * * @return * @author SHANHY * @create 2016年1月5日 */ @RequestMapping(value = {&quot;/&quot;,&quot;/index&quot;}) public String index(Map&lt;String, Object&gt; model){ // 直接返回字符串，框架默认会去 spring.view.prefix 目录下的 （index拼接spring.view.suffix）页面 // 本例为 /WEB-INF/jsp/index.jsp model.put(&quot;time&quot;, new Date()); model.put(&quot;message&quot;, this.hello); return &quot;index&quot;; } /** * 响应到JSP页面page1 * * @return * @author SHANHY * @create 2016年1月5日 */ @RequestMapping(&quot;/page1&quot;) public ModelAndView page1(){ // 页面位置 /WEB-INF/jsp/page/page.jsp ModelAndView mav = new ModelAndView(&quot;page/page1&quot;); mav.addObject(&quot;content&quot;, hello); return mav; } /** * 响应到JSP页面page1（可以直接使用Model封装内容，直接返回页面字符串） * * @return * @author SHANHY * @create 2016年1月5日 */ @RequestMapping(&quot;/page2&quot;) public String page2(Model model){ // 页面位置 /WEB-INF/jsp/page/page.jsp model.addAttribute(&quot;content&quot;, hello + &quot;（第二种）&quot;); return &quot;page/page1&quot;; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 pom.xml添加依赖： &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 上面说了spring-boot 不推荐JSP，想使用JSP需要配置application.properties。添加src/main/resources/application.properties内容： # 页面默认前缀目录 spring.mvc.view.prefix=/WEB-INF/jsp/ # 响应页面默认后缀 spring.mvc.view.suffix=.jsp # 自定义属性，可以在Controller中读取 application.hello=Hello Shanhy 1 2 3 4 5 6 1 2 3 4 5 6 在 src/main 下面创建 webapp/WEB-INF/jsp 目录用来存放我们的jsp页面。index.jsp &lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Spring Boot Sample&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Time: ${time} &lt;br&gt; Message: ${message} &lt;/body&gt; &lt;/html&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 page1.jsp &lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Spring Boot Sample&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;${content }&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 1 2 3 4 5 6 7 8 9 10 11 1 2 3 4 5 6 7 8 9 10 11 要想让spring-boot支持JSP，需要将项目打成war包。我们做最后一点修改，修改pom.xml文件，将 jar 中的 jar 修改为 war 然后启动spring-boot服务。访问页面查看结果： http://localhost:8080 http://localhost:8080/page1 http://localhost:8080/page2 最后附上工程结构： 如果需要使用 FreeMarker 的同学，请按下面的方法说明修改：1、去掉 application.properties 中的 spring.mvc.view.prefix 和 spring.mvc.view.suffix配置。2、将 .ftl 模版页面放到 resources/templates 中（如上面工程截图所示）其中 error.ftl 是系统默认的错误页，内容自定。3、修改 pom.xml ，如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.springboot.sample&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-sample&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- &lt;packaging&gt;war&lt;/packaging&gt; --&gt; &lt;name&gt;spring-boot-sample&lt;/name&gt; &lt;description&gt;Spring Boot Sample Web Application&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- &lt;dependency&gt; --&gt; &lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; --&gt; &lt;!-- &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; --&gt; &lt;!-- &lt;/dependency&gt; --&gt; &lt;!-- &lt;dependency&gt; --&gt; &lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; --&gt; &lt;!-- &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; --&gt; &lt;!-- &lt;/dependency&gt; --&gt; &lt;!-- &lt;dependency&gt; --&gt; &lt;!-- &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; --&gt; &lt;!-- &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; --&gt; &lt;!-- &lt;scope&gt;provided&lt;/scope&gt; --&gt; &lt;!-- &lt;/dependency&gt; --&gt; &lt;!-- &lt;dependency&gt; --&gt; &lt;!-- &lt;groupId&gt;javax.servlet&lt;/groupId&gt; --&gt; &lt;!-- &lt;artifactId&gt;jstl&lt;/artifactId&gt; --&gt; &lt;!-- &lt;/dependency&gt; --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.itchina.top/tags/spring/"}]},{"title":"Redis集群方案介绍","slug":"Redis集群方案介绍","date":"2018-04-19T16:34:21.428Z","updated":"2018-04-19T16:30:26.601Z","comments":true,"path":"2018/04/20/Redis集群方案介绍/","link":"","permalink":"https://www.itchina.top/2018/04/20/Redis集群方案介绍/","excerpt":"","text":"本文节选自《App 后台开发运维和架构实践》一书 由于Redis出众的性能，其在众多的移动互联网企业中得到广泛的应用。Redis在3.0版本前只支持单实例模式，虽然现在的服务器内存可以到100GB、200GB的规模，但是单实例模式限制了Redis没法满足业务的需求（例如新浪微博就曾经用Redis存储了超过1TB的数据）。Redis的开发者Antirez早在博客上就提出在Redis3.0版本中加入集群的功能，但3.0版本等到2015年才发布正式版。各大企业在3.0版本还没发布前为了解决Redis的存储瓶颈，纷纷推出了各自的Redis集群方案。这些方案的核心思想是把数据分片（sharding）存储在多个Redis实例中，每一片就是一个Redis实例。 下面介绍Redis的集群方案。 1.客户端分片 客户端分片是把分片的逻辑放在Redis客户端实现，通过Redis客户端预先定义好的路由规则，把对Key的访问转发到不同的Redis实例中，最后把返回结果汇集。这种方案的模式如图1所示。 _ 图1 客户端分片的模式 _ 客户端分片的好处是所有的逻辑都是可控的，不依赖于第三方分布式中间件。开发人员清楚怎么实现分片、路由的规则，不用担心踩坑。 客户端分片方案有下面这些缺点。 这是一种静态的分片方案，需要增加或者减少Redis实例的数量，需要手工调整分片的程序。 可运维性差，集群的数据出了任何问题都需要运维人员和开发人员一起合作，减缓了解决问题的速度，增加了跨部门沟通的成本。 在不同的客户端程序中，维护相同的分片逻辑成本巨大。例如，系统中有两套业务系统共用一套Redis集群，一套业务系统用Java实现， 另一套业务系统用PHP实现。为了保证分片逻辑的一致性，在Java客户端中实现的分片逻辑也需要在PHP客户端实现一次。相同的逻辑在不同的系统中分别 实现，这种设计本来就非常糟糕，而且需要耗费巨大的开发成本保证两套业务系统分片逻辑的一致性。 2.Twemproxy Twemproxy是由Twitter开源的Redis代理，其基本原理是：Redis客户端把请求发送到Twemproxy，Twemproxy根据路由规则发送到正确的Redis实例，最后Twemproxy把结果汇集返回给客户端。 Twemproxy通过引入一个代理层，将多个Redis实例进行统一管理，使Redis客户端只需要在Twemproxy上进行操作，而不需要关心后面有多少个Redis实例，从而实现了Redis集群。 Twemproxy集群架构如图2所示。 _ 图2Twemproxy集群架构 _ Twemproxy的优点如下。 客户端像连接Redis实例一样连接Twemproxy，不需要改任何的代码逻辑。 支持无效Redis实例的自动删除。 Twemproxy与Redis实例保持连接，减少了客户端与Redis实例的连接数。 Twemproxy有如下不足。 由于Redis客户端的每个请求都经过Twemproxy代理才能到达Redis服务器，这个过程中会产生性能损失。 没有友好的监控管理后台界面，不利于运维监控。 最大的问题是Twemproxy无法平滑地增加Redis实例。对于运维人员来说，当因为业务需要增加Redis实例时工作量非常大。 Twemproxy作为最被广泛使用、最久经考验、稳定性最高的Redis代理，在业界被广泛使用。 3.Codis Twemproxy不能平滑增加Redis实例的问题带来了很大的不便，于是豌豆荚自主研发了Codis，一个支持平滑增加Redis实例的Redis代理软件，其基于Go和C语言开发，并于2014年11月在GitHub上开源。 Codis包含下面4个部分。 Codis Proxy：Redis客户端连接到Redis实例的代理，实现了Redis的协议，Redis客户端连接到Codis Proxy进行各种操作。Codis Proxy是无状态的，可以用Keepalived等负载均衡软件部署多个Codis Proxy实现高可用。 CodisRedis：Codis项目维护的Redis分支，添加了slot和原子的数据迁移命令。Codis上层的 Codis Proxy和Codisconfig只有与这个版本的Redis通信才能正常运行。 Codisconfig：Codis管理工具。可以执行添加删除CodisRedis节点、添加删除Codis Proxy、数据迁移等操作。另外，Codisconfig自带了HTTP server，里面集成了一个管理界面，方便运维人员观察Codis集群的状态和进行相关的操作，极大提高了运维的方便性，弥补了Twemproxy的缺 点。 ZooKeeper：分布式的、开源的应用程序协调服务，是Hadoop和Hbase的重要组件，其为分布式应用提供一致性服务，提供的 功能包括：配置维护、名字服务、分布式同步、组服务等。Codis依赖于ZooKeeper存储数据路由表的信息和Codis Proxy节点的元信息。另外，Codisconfig发起的命令都会通过ZooKeeper同步到CodisProxy的节点。 Codis的架构如图3所示。 _ 图3Codis的架构图 _ 在图3的Codis的架构图中，Codis引入了Redis ServerGroup，其通过指定一个主CodisRedis和一个或多个从CodisRedis，实现了Redis集群的高可用。当一个主CodisRedis挂掉时，Codis不会自动把一个从CodisRedis提升为主CodisRedis，这涉及数据的一致性问题（Redis本身的数据同步是采用主从异步复制，当数据在主CodisRedis写入成功时，从CodisRedis是否已读入这个数据是没法保证的），需要管理员在管理界面上手动把从CodisRedis提升为主CodisRedis。 如果觉得麻烦，豌豆荚也提供了一个工具Codis-ha，这个工具会在检测到主CodisRedis挂掉的时候将其下线并提升一个从CodisRedis为主CodisRedis。 Codis中采用预分片的形式，启动的时候就创建了1024个slot，1个slot相当于1个箱子，每个箱子有固定的编号，范围是1~1024。slot这个箱子用作存放Key，至于Key存放到哪个箱子，可以通过算法“crc32(key)%1024”获得一个数字，这个数字的范围一定是1~1024之间，Key就放到这个数字对应的slot。例如，如果某个Key通过算法“crc32(key)%1024”得到的数字是5，就放到编码为5的slot（箱子）。1个slot只能放1个Redis Server Group，不能把1个slot放到多个Redis ServerGroup中。1个Redis ServerGroup最少可以存放1个slot，最大可以存放1024个slot。因此，Codis中最多可以指定1024个Redis Server Group。 Codis最大的优势在于支持平滑增加（减少）Redis Server Group（Redis实例），能安全、透明地迁移数据，这也是Codis有别于Twemproxy等静态分布式 Redis 解决方案的地方。Codis增加了Redis ServerGroup后，就牵涉到slot的迁移问题。例如，系统有两个Redis Server Group，Redis ServerGroup和slot的对应关系如下。 Redis Server Group slot 1 1~500 2 501~1024 当增加了一个Redis Server Group，slot就要重新分配了。Codis分配slot有两种方法。 第一种：通过Codis管理工具Codisconfig手动重新分配，指定每个Redis Server Group所对应的slot的范围，例如可以指定RedisServer Group和slot的新的对应关系如下。 Redis Server Group slot 1 1~500 2 501~700 3 701~1024 第二种：通过Codis管理工具Codisconfig的rebalance功能，会自动根据每个Redis ServerGroup的内存对slot进行迁移，以实现数据的均衡。 4.Redis 3.0集群 Redis 3.0集群采用了P2P的模式，完全去中心化。Redis把所有的Key分成了16384个slot，每个Redis实例负责其中一部分slot。集群中的所有信息（节点、端口、slot等），都通过节点之间定期的数据交换而更新。 Redis客户端在任意一个Redis实例发出请求，如果所需数据不在该实例中，通过重定向命令引导客户端访问所需的实例。 Redis 3.0集群的工作流程如图4所示。 _ 图4Redis 3.0集群的工作流程图 _ 如图4所示Redis集群内的机器定期交换数据，工作流程如下。 （1） Redis客户端在Redis2实例上访问某个数据。 （2） 在Redis2内发现这个数据是在Redis3这个实例中，给Redis客户端发送一个重定向的命令。 （3） Redis客户端收到重定向命令后，访问Redis3实例获取所需的数据。 Redis 3.0的集群方案有以下两个问题。 一个Redis实例具备了“数据存储”和“路由重定向”，完全去中心化的设计。这带来的好处是部署非常简单，直接部署Redis就行，不 像Codis有那么多的组件和依赖。但带来的问题是很难对业务进行无痛的升级，如果哪天Redis集群出了什么严重的Bug，就只能回滚整个Redis集 群。 对协议进行了较大的修改，对应的Redis客户端也需要升级。升级Redis客户端后谁能确保没有Bug？而且对于线上已经大规模运行的业务，升级代码中的Redis客户端也是一个很麻烦的事情。 综合上面所述的两个问题，Redis 3.0集群在业界并没有被大规模使用。 5.云服务器上的集群服务 国内的云服务器提供商阿里云、UCloud等均推出了基于Redis的云存储服务。 这个服务的特性如下。 （1）动态扩容 用户可以通过控制面板升级所需的Redis存储空间，扩容的过程中服务部不需要中断或停止，整个扩容过程对用户透明、无感知，这点是非常实用的，在前面介绍的方案中，解决Redis平滑扩容是个很烦琐的任务，现在按几下鼠标就能搞定，大大减少了运维的负担。 （2）数据多备 数据保存在一主一备两台机器中，其中一台机器宕机了，数据还在另外一台机器上有备份。 （3）自动容灾 主机宕机后系统能自动检测并切换到备机上，实现服务的高可用。 （4）实惠 很多情况下为了使Redis的性能更高，需要购买一台专门的服务器用于Redis的存储服务，但这样子CPU、内存等资源就浪费了，购买Redis云存储服务就很好地解决了这个问题。 有了Redis云存储服务，能使App后台开发人员从烦琐运维中解放出来。App后台要搭建一个高可用、高性能的Redis服务，需要投入相当的运维成本和精力。如果使用云存储服务，就没必要投入这些成本和精力，可以让App后台开发人员更专注于业务。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.itchina.top/categories/Redis/"}],"tags":[]},{"title":"nginx配置文件详解","slug":"nginx配置文件详解","date":"2018-04-19T16:34:21.427Z","updated":"2018-04-19T16:30:17.859Z","comments":true,"path":"2018/04/20/nginx配置文件详解/","link":"","permalink":"https://www.itchina.top/2018/04/20/nginx配置文件详解/","excerpt":"","text":"#运行用户 ** user www-data; #启动进程,通常设置成和cpu的数量相等worker_processes 1; #全局错误日志及PID文件error_log /var/log/nginx/error.log;pid /var/run/nginx.pid; #工作模式及连接数上限events {use epoll; #epoll是多路复用IO(I/OMultiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能worker_connections 1024;#单个后台worker process进程的最大并发链接数 multi_accept on;} #设定http服务器，利用它的反向代理功能提供负载均衡支持http { #设定mime类型,类型由mime.type文件定义include /etc/nginx/mime.types;default_type application/octet-stream; #设定日志格式access_log /var/log/nginx/access.log; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.sendfile on; #tcp_nopush on; #连接超时时间 #keepalive_timeout 0;keepalive_timeout 65;tcp_nodelay on; #开启gzip压缩gzip on;gzip_disable “MSIE [1-6]\\.(?!.SV1)”; #设定请求缓冲client_header_buffer_size 1k;large_client_header_buffers 4 4k; include /etc/nginx/conf.d/.conf;include /etc/nginx/sites-enabled/*; #设定负载均衡的服务器列表upstream mysvr { #weigth参数表示权值，权值越高被分配到的几率越大 #本机上的Squid开启3128端口server 192.168.8.1:3128 weight=5;server 192.168.8.2:80 weight=1;server 192.168.8.3:80 weight=6;} ** ** server { #侦听80端口listen 80; #定义使用 www.xx.com 访问server_name www.xx.com ; #设定本虚拟主机的访问日志access_log logs/ www.xx.com.access.log main; #默认请求location / {root /root; #定义服务器的默认网站根目录位置index index.php index.html index.htm; #定义首页索引文件的名称 fastcgi_pass www.xx.com ;fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;include /etc/nginx/fastcgi_params;} # 定义错误提示页面error_page 500 502 503 504 /50x.html;location = /50x.html {root /root;} #静态文件，nginx自己处理location ~ ^/(images|javascript|js|css|flash|media|static)/ {root /var/www/virtual/htdocs; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。expires 30d;} #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.location ~ \\.php$ {root /root;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name;include fastcgi_params;} #设定查看Nginx状态的地址location /NginxStatus {stub_status on;access_log on;auth_basic “NginxStatus”;auth_basic_user_file conf/htpasswd;} #禁止访问 .htxxx 文件location ~ /\\.ht {deny all;} } } **","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.itchina.top/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.itchina.top/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"https://www.itchina.top/tags/nginx/"}]},{"title":"python数据分析之numpy初始化（一）","slug":"python数据分析之numpy初始化（一）","date":"2018-04-19T16:34:21.427Z","updated":"2018-03-30T11:13:20.000Z","comments":true,"path":"2018/04/20/python数据分析之numpy初始化（一）/","link":"","permalink":"https://www.itchina.top/2018/04/20/python数据分析之numpy初始化（一）/","excerpt":"","text":"以下都用numpy的标准“import numpy as np”1.numpy是同构数据多维容器，同构即数据类型相同2.初始化： 2.1 np.arange([start,] end [, step]) #与list的range相似 &gt;&gt;&gt; np.arange(10) array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) &gt;&gt;&gt; np.arange(1, 10, 2) array([1, 3, 5, 7, 9]) 2.2 np.zeros(tupleA) #产生一个tupleA维度大小的矩阵，且初始全为0 &gt;&gt;&gt; np.zeros((4)) array([ 0., 0., 0., 0.]) &gt;&gt;&gt; np.zeros((4,2)) array([[ 0., 0.], [ 0., 0.], [ 0., 0.], [ 0., 0.]]) 2.3 np.ones(tupleA) #与上面类似，只是初始化全为1 &gt;&gt;&gt; np.ones((4)) array([ 1., 1., 1., 1.]) &gt;&gt;&gt; np.ones((4,2)) array([[ 1., 1.], [ 1., 1.], [ 1., 1.], [ 1., 1.]]) 2.4 np.empty(tupleA) #与上面类似，只是初始化值是不确定的（并不是你以为的0！！！！） &gt;&gt;&gt; np.empty((4)) array([ 1.73154357e-316, 4.71627160e-317, 0.00000000e+000, 4.94065646e-324]) &gt;&gt;&gt; np.empty((3,2)) array([[ 0.00000000e+000, 0.00000000e+000], [ 6.94647584e-310, 6.94647586e-310], [ 6.94647586e-310, 6.94647586e-310], 2.5 np.array(listA) #把listA转成np，listA只是一个统称，只要是序列化的都可以，还可以是其他np &gt;&gt;&gt; np.array([[1, 2, 3], [4, 3, 2]]) array([[1, 2, 3], [4, 3, 2]]) &gt;&gt;&gt; npA = np.array([[1, 2, 3], [4, 3, 2]]) &gt;&gt;&gt; npA array([[1, 2, 3], [4, 3, 2]]) &gt;&gt;&gt; npB = np.array([[1, 2, 3], [4, 3, 2.0]]) &gt;&gt;&gt; npB array([[ 1., 2., 3.], [ 4., 3., 2.]]) np.array会自动找到最适合listA数据类型转给np: &gt;&gt;&gt; npA.dtype dtype(&apos;int64&apos;) &gt;&gt;&gt; npB.dtype dtype(&apos;float64&apos;) 但其实， np初始化时没有特别说明都会被默认是float64 ，如前四种 2.6其他： ones_like(npA);zeros_like(npA);empty_like(npA) &gt;&gt;&gt; npB = np.array([[1, 2, 3], [4, 3, 2.0]]) &gt;&gt;&gt; np.ones_like(npB) array([[ 1., 1., 1.], [ 1., 1., 1.]]) &gt;&gt;&gt; np.zeros_like(npB) array([[ 0., 0., 0.], [ 0., 0., 0.]]) &gt;&gt;&gt; np.empty_like(npB) array([[ 0.00000000e+000, 0.00000000e+000, 1.56491143e-316], [ 6.94647850e-310, 6.94635322e-310, 1.72361006e-316]]) &gt;&gt;&gt; np.identity(3) array([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]]) &gt;&gt;&gt; np.eye(3, k = -1)#变化k的值试试看 array([[ 0., 0., 0.], [ 1., 0., 0.], [ 0., 1., 0.]])","categories":[{"name":"cnn图片数据处理、显示","slug":"cnn图片数据处理、显示","permalink":"https://www.itchina.top/categories/cnn图片数据处理、显示/"},{"name":"python数据分析","slug":"cnn图片数据处理、显示/python数据分析","permalink":"https://www.itchina.top/categories/cnn图片数据处理、显示/python数据分析/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://www.itchina.top/tags/numpy/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.itchina.top/tags/数据分析/"}]},{"title":"MySQL集群","slug":"MySQL集群","date":"2018-04-19T16:34:21.425Z","updated":"2018-04-19T16:30:19.126Z","comments":true,"path":"2018/04/20/MySQL集群/","link":"","permalink":"https://www.itchina.top/2018/04/20/MySQL集群/","excerpt":"","text":"Mysql Cluster7.4.6安装与配置 Mysql Cluster版本：mysql-cluster-gpl-7.4.6-linux-glibc2.5-x6_64.tar.gz 管理节点服务器1台 Sql服务器2台 Ndb服务器2台 首先修改所有服务器的hostname Vi /etc/hosts 将节点服务器名配置为：MGM1 将Sql服务器配置为：SQL1，SQL2 将NDB服务器配置为：NDB1，NDB2 一、Sql节点以及Ndb节点安装步骤： 1.首先在节点服务器上安装Centos6.5，不要安装内置Mysql 2. 从官方网站上下载Mysql Cluster，这里使用到的版本为Mysql Cluster7.4.6 3. 创建用户群,groupadd mysql 4. 创建用户,useradd -g mysql mysql 5. 解压缩Mysql Cluster包，输入tar -zxvf mysql-cluster-gpl-7.4.6-linux-glibc2.5-x6_64.tar.gz 6. 将解压缩后的包移入/usr/local内，输入cp mysql-cluster-gpl-7.4.6-linux-glibc2.5-x6_64/usr/local/mysql 7. 进入mysql文件夹,输入cd /usr/local/mysql 8. 输入chown -R root * 9. 输入chown -R mysql data 10. 输入chgrp -R mysql * 11. 安装mysql-cluster，输入scripts/mysql_install_db –user=mysql 12. 注册mysql的service，输入cp support-files/mysql.server /etc/rc.d/init.d/mysqld 13. chmod +x /etc/rc.d/init.d/mysqld 14. chkconfig –add mysqld 15. 运行service mysqld start启动mysql 二、管理节点安装步骤： 1.在管理节点服务器完成上述sql节点和ndb节点安装步骤后，输入cd /usr/local/mysql进入目录 2.cp bin/ndb_mgm*/usr/local/bin 3.cd /usr/local/bin 4.chmod +x ndb_mgm* 三、 配置sql节点和ndb节点 mysql服务启动时会默认加载/etc/my.cnf作为其配置文件，要将一个mysql服务器配置成一个数据节点和SQL节点也非常的简单，这是配置前的my.cnf的内容： 1.[client] port=3306 socket=/tmp/mysql.sock [mysqld] basedir=/usr/local/mysql/ datadir=/usr/local/mysql/data user= mysql log-error=/var/lib/mysql/mysqld.err 2. 在此基础上在最下方分别加入以下语句： a) 如果是NDB服务器的情况下输入： ndbcluster ndb-connectstring= MGM1 b) 如果是SQL节点服务器的情况下输入 [mysql_cluster] ndb-connectstring= MGM1 注意所有服务器必须具有相同的配置 四、 管理节点服务器的配置 1. cd /var/lib 2. mkdir mysql-cluster 3. vi config.ini，创建配置文件 4. 在config.ini文件中添加以下内容： [NDBD DEFAULT] NoOfReplicas=1 #每个数据节点的镜像数量 DataMemory=500M #每个数据节点中给数据分配的内存 IndexMemory=300M #每个数据节点中给索引分配的内存 [TCP DEFAULT] portnumber=2202 #数据节点的默认连接端口 [NDB_MGMD] #配置管理节点 hostname=MGM1 datadir=/var/lib/mysql-cluster/ #管理节点数据(日志)目录 [NDBD] #数据节点配置 hostname=NDB1 datadir=/usr/local/mysql/data/ #数据节点目录 [NDBD] hostname=NDB2 datadir=/usr/local/mysql/data/ [MYSQLD] #SQL节点目录 hostname=SQL1 [MYSQLD] hostname=SQL2 注释： [NDBD DEFAULT]：表示每个数据节点的默认配置在每个节点的[NDBD]中不用再写这些选项，只能有一个。 [NDB_MGMD]：表示管理节点的配置，只有一个。 [NDBD]：表示每个数据节点的配置，可以有多个。 [MYSQLD]：表示SQL节点的配置，可以有多个，分别写上不同SQL节点的IP地址，也可以什么都不写，只保留一个空节点，表示任意一个IP地址都可以进行访问，此节点的个数表明了可以用来连接数据节点的SQL节点总数。 五、 启动 1. 管理节点的启动： a) Mysql cluster需要各个节点进行启动后方能够工作，节点的启动顺序为：管理节点——》NDB数据节点——》Sql节点。因此首先启管理节点 b) cd /usr/local/bin c) ndb_mgmd -f /var/lib/mysql-cluster/config.ini d) 注意以上为第一次配置的情况下，如果新增节点，使用./ ndb_mgmd -f /var/lib/mysql-cluster/config.ini–initial进行加载，不然添加的节点不会出现在集群中 e) 启动时可能会报个WARNING,如WARNING – at line 7: [TCP] portnumber isdeprecated，这个不用管。可以正常工作的。 f) 启动后可以使用ndb_mgm -e show查看运行状态 2. NDB节点的启动 a) cd /usr/local/bin b) ./ndbd –initial c) 如果出现类似以下信息则表明成功连接到管理节点服务器： 2015-06-25 12:48:03 [ndbd] INFO – Angel connected to ‘MGM1:1186’ 2015-06-25 12:48:03 [ndbd] INFO – Angel allocated nodeid: 3 3. SQL节点的启动： a) service mysqld start 4. 客户端管理 a) 在管理服务器中输入cd /usr/local/bin/ b) ./ndb_mgm c) 在ndb_mgm&gt; 提示符下输入show： ndb_mgm&gt; show ClusterConfiguration -——————– [ndbd(NDB)] 2 node(s) id=2 @NDB1 (mysql- 5.6.24 ndb- 7.4.6 ,Nodegroup:0,Master) id=3 @NDB2 (mysql- 5.6.24 ndb- 7.4.6 ,Nodegroup:1) [ndb_mgmd(MGM)]1 node(s) id=1 @MGM1 (mysql- 5.6.24 ndb- 7.4.6 ) [mysqld(API)] 2 node(s) id=4 @SQL1 (mysql- 5.6.24 ndb- 7.4.6 ) id=5 @SQL2 (mysql- 5.6.24 ndb- 7.4.6 ) 5. 关闭mysql cluster a) cd /usr/local/bin b) ./ndb_mgm -e shutdown c) 虽然mysql cluster 关闭了，但是SQL节点的mysql服务并不会停止的。接下来就可以做各种试验了。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itchina.top/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.itchina.top/tags/mysql/"}]},{"title":"MySQL+Heartbeat+DRBD构建高可用MySQL环境","slug":"MySQL+Heartbeat+DRBD构建高可用MySQL环境","date":"2018-04-19T16:34:21.425Z","updated":"2018-04-19T16:30:05.246Z","comments":true,"path":"2018/04/20/MySQL+Heartbeat+DRBD构建高可用MySQL环境/","link":"","permalink":"https://www.itchina.top/2018/04/20/MySQL+Heartbeat+DRBD构建高可用MySQL环境/","excerpt":"","text":"Distributed Replicated Block Device(DRBD)是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。数据镜像：实时、透明、同步（所有服务器都成功后返回）、异步（本地服务器成功后返回） DBRD的核心功能通过Linux的内核实现，最接近系统的IO栈，但它不能神奇地添加上层的功能比如检测到EXT3文件系统的崩溃。 DBRD的位置处于文件系统以下，比文件系统更加靠近操作系统内核及IO栈。 ——《百度百科》 实验环境： 主 192.168.43.128 drbd-M CentOS 5.4 64bit 从 192.168.43.129 drbd-S CentOS5.4 64bit 准备工作： Vim /etc/hosts 192.168.43.129 drbd-M 192.168.43.130 drbd-S 修改hostname名， 主：hostname drbd-M 从：hostname drbd-S 确保与uname -n输出一致。PS：很重要，后面的drbd和heartbeat都要依赖于主机名来通信。 搭建环境，采用yum安装： 1. # yum install -y drbd83 kmod-drbd83 2. 3. # yum search heartbeat* 4. 5. heartbeat所需的安装包主要有以下几个： 6. 7. heartbeat-devel-2.1.3-3.el5.centos 8. 9. heartbeat-stonith-2.1.3-3.el5.centos 10. 11. heartbeat-gui-2.1.3-3.el5.centos 12. 13. heartbeat-ldirectord-2.1.3-3.el5.centos 14. 15. heartbeat-pils-2.1.3-3.el5.centos 16. 17. heartbeat-2.1.3-3.el5.centos 一 DRBD的安装使用 加载安装drbd模块： 1. # modprobe drbd 检查是否加载成功： 1. # modprobe drbd 2. drbd 277272 2 PS：一般使用yum安装的话系统会自动加载的，此步可以跳过，如果使用源码包编译就一定要记得这一步。 添加一块硬盘，存放数据，主从服务器的硬盘大小可以不一致，但是如果数据超过小的硬盘，后果自己考虑吧！这里添加的是一块2G的硬盘，设备名称为/dev/sdb2，注意先别急着格式化。 开始drbd的配置： drbd主配置文件，很重要： 1. global { 2. } 3. common { 4. syncer { rate 100M; } //设置两个节点间的同步速率； 5. } 6. 7. resource db { 8. protocol C; //定义当数据被写入块设备时候的一致性级别（数据同步协议），A、B、C三个级别，C为数据被确认写到本地磁盘和远程磁盘后返回，确认成功 9. startup { wfc-timeout 0; degr-wfc-timeout 120; } 10. disk { on-io-error detach; } 11. syncer { rate 100M; } 12. 13. on drbd-M { //节点名称一定要与hostname保持一致； 14. device /dev/drbd0; //创建的虚拟磁盘 15. disk /dev/sdb2; //物理分区 16. address 192.168.43.129:7788; //监听端口 17. meta-disk internal; //局域网类型 18. 19. } 20. 21. on drbd-S { 22. device /dev/drbd0; 23. disk /dev/sdb2; 24. address 192.168.43.130:7788; 25. meta-disk internal; 26. } 27. } 检测配置文件： 1. #drbdadm ajust db 至此drbd已经配置完毕，以上步骤在主从服务器上都要做，而且drbd的配置文件要保持一致。 主服务器和从服务器上创建matadata： 1. # drbdadm create-md all 主从服务器启动drbd： 1. # /etc/init.d/drbd start 此时主从服务器之间开始同步数据，第一次的话时间会稍微长一些。 将drbd-M 设为主节点 第一次的话要使用： 1. # drbdsetup /dev/drbd0 primary -o 以后可以使用drbdadm primary all命令。 将新创建的设备格式化并且挂载： 1. # mkfs.ext3 /dev/drbd0 //破坏文件系统：dd if=/dev/zero bs=1M of=/dev/sdb2;sync 2. # mount /dev/drbd0 /data/ 3. # df –H 在/data目录下创建文件进行测试： 1. # cd /data/ 2. # mkdir linna 3. # touch database 4. # ls 5. database linna lost+found 下面进行测试： drbd-M： 将主服务器降为从： 先卸载设备： 1. # umount /data/ 2. # drbdadm secondary all PS:临时切断节点之间的连接可以使用：#drbdadm connect all 查看系统日志/var/log/message: Drbd-S： 我们再将从服务器提升为主服务器看下数据能否同步过来： 1. # drbdadm primary all 1. # mount /dev/drbd0 /data 2. # cd /data/ 看，数据已经同步过来了！ 我们可以通过查看/proc/drbd来监控主从节点间之间数据同步的过程： 1. #Watch -n 10 ‘cat /proc/drbd’ 二 MySQL+Heartbeat+DRBD构建高可用环境 图 MySQL+Heartbeat+DRBD构建高可用MySQL 1 Heartbeat主配置文件/etc/ha.d/ha.cf： 1. # cat /etc/ha.d/ha.cf 2. logfacility local0 //定义日志，使用syslog； 3. keepalive 2 //定义心跳频率； 4. deadtime 15 //如果其他节点15S内没有回应，则确认其死 亡； 5. warntime 5 //确认一个节点连接不上5S之后将警告信息写入日志； 6. initdead 120 //在其他节点死掉之后，系统启动前需要等待的时间，一般为deadtime的两倍； 7. udpport 694 // 用来通信的端口； 8. bcast eth0 // 在eth0上进行心跳测试 9. watchdog /dev/watchdog //可选项 10. auto_failback off // 设置当死亡节点恢复正常之后是否重新启用；容易发生数据不一致的情况，必须项，不然后面hb_standby命令无法使用； 11. node drbd-M 12. node drbd-S 13. respawn hacluster /usr/lib64/heartbeat/ipfail 2 设置两个节点之间的通信密钥： 1. #cat authkeys 2. auth 3 3. 3 md5 Hello! 3 定义资源： 1. # cat haresources 2. drbd-M drbddisk Filesystem::/dev/drbd0::/data::ext3 mysqld 192.168.43.20 drbd-M //主节点； drbddisk Filesystem::/dev/drbd0::/data::ext3 mysqld //定义Heartbeat需要管理的资源，并且每一部分在/etc/ha.d/haresources.d下有对应的脚本；如果主节点失效，备节点将通过执行这些脚本来启用资源；如果脚本有参数可以使用“：：”来进行分割； drbddisk 管理drbd资源的脚本； filesystem 管理文件系统资源的脚本，后面参数定义drbd设备，挂载点，文件系统类型 mysqld 管理mysql的脚本，需要从/etc/init.d/mysqld 拷贝 192.168.43.20 //VIP,用来连接MySQL的IP，当Heartbeat启用之后会自动分配； 图 Resource.d 下的内容 在主从节点上启动Heartbeat 1. # /etc/init.d/heartbeat start 查看下资源启动情况： 先看下主节点drbd-M的日志： 再看下drbd-S的日志，已经处在监听等待状态： 虚拟IP已经启动： Drbd和MySQL的端口已经在监听： 主节点/data目录下： 我们切换到drbd-S来试一下，看资源能不能切换过来： 使用/usr/lib64/heartbeat/hb_standby命令可以来模拟主节点死掉的情况。 1. 2011/07/18_20:49:53 Going standby [all]. 从服务器drbd-S日志： 再看下资源是否已经抢占过来： /data目录下的文件： PS:Heartbeat启动之前必须保证drbd服务已经启动，并且主服务器已经设置为primary并成功挂载/dev/drbd0.不然主服务器Heartbeat在启动的时候会提示找不到/dev/drbd0设备，并造成其他的资源也无法启动的情况。 PS：心跳探测和数据复制不建议在同一个网卡上进行，本实验只是为了方便采取了这样的方式。 dopd进程：当主从节点之间的失去连接，那么主从节点之间的数据就无法同步，就会发生从节点的数据过期的情况（数据不一致的情况）。如果此时主服务器发生宕机的情况，那么dopd进程会阻止从服务器提升为主服务器。具体实现： 1 修改/etc/ha.d/ha.cf 文件： 1. respawn hacluster /usr/lib64/heartbeat/dopd 2. apiauth dopd gid=haclient uid=hacluster 2 修改/etc/drbd.conf 文件： 1. common { 2. handlers { 3. outdate-peer “/usr/lib64/heartbeat/drbd-peer-outdater”; 4. } 5. } 6. resource db { 7. disk { 8. Fencing resource-only; 9. } 10. } 3 重新加载配置文件： 1. # /etc/init.d/heartbeat reload 2. #/drbdadm adjust all MySQL+Heartbeat+DRBD方案可以单独使用，也可以在构建MySQL主从架构时实现主服务器的高可用，在此不再详细实现，有兴趣的朋友可以尝试一下（完）！ 参考文章：MySQL and DRBD Guide 本文出自 “ 諸葛草廬 ” 博客，请务必保留此出处 http://lyp0909.blog.51cto.com/508999/691435","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itchina.top/categories/数据库/"},{"name":"集群","slug":"数据库/集群","permalink":"https://www.itchina.top/categories/数据库/集群/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.itchina.top/tags/mysql/"}]},{"title":"lombok的使用和原理","slug":"lombok的使用和原理","date":"2018-04-19T16:34:21.424Z","updated":"2018-04-19T16:29:53.116Z","comments":true,"path":"2018/04/20/lombok的使用和原理/","link":"","permalink":"https://www.itchina.top/2018/04/20/lombok的使用和原理/","excerpt":"","text":"一、项目背景在写Java程序的时候经常会遇到如下情形：新建了一个Class类，然后在其中设置了几个字段，最后还需要花费很多时间来建立getter和setter方法lombok项目的产生就是为了省去我们手动创建getter和setter方法的麻烦，它能够在我们编译源码的时候自动帮我们生成getter和setter方法。即它最终能够达到的效果是：在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法比如源码文件： import java.io.Serializable; import lombok.Data; @Data public class BasicClusterInfo implements Serializable { private static final long serialVersionUID = 3478135817352393604L; private String hbaseKey; private int receiverCount; } 以下是编译上述源码文件得到的字节码文件，对其反编译得到的结果 public class BasicClusterInfo extends java.lang.Object implements java.io.Serializable{ public BasicClusterInfo(); public java.lang.String getHbaseKey(); public int getReceiverCount(); public void setHbaseKey(java.lang.String); public void setReceiverCount(int); public boolean equals(java.lang.Object); public boolean canEqual(java.lang.Object); public int hashCode(); public java.lang.String toString(); } 二、使用方法lombok网址： https://projectlombok.org/download.html Eclipse支持需要点击运行下载的jar包Maven依赖： &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;/dependency&gt; 使用lombok项目的方法很简单，分为四个步骤：1. 在需要自动生成getter和setter方法的类上，加上@Data注解2. 在编译类路径中加入lombok.jar包3. 使用支持lombok的编译工具编译源代码（关于支持lombok的编译工具，见“四、支持lombok的编译工具”）4. 编译得到的字节码文件中自动生成了getter和setter方法 三、原理分析接下来进行lombok能够工作的原理分析，以Oracle的javac编译工具为例。自从Java 6起，javac就支持“JSR 269 Pluggable Annotation ProcessingAPI”规范，只要程序实现了该API，就能在javac运行的时候得到调用。举例来说，现在有一个实现了”JSR 269 API”的程序A,那么使用javac编译源码的时候具体流程如下：1) javac对源代码进行分析，生成一棵抽象语法树(AST)2) 运行过程中调用实现了”JSR 269 API”的A程序3) 此时A程序就可以完成它自己的逻辑，包括修改第一步骤得到的抽象语法树(AST)4) javac使用修改后的抽象语法树(AST)生成字节码文件详细的流程图如下： lombok本质上就是这样的一个实现了”JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下：1)javac对源代码进行分析，生成一棵抽象语法树(AST)2)运行过程中调用实现了”JSR 269 API”的lombok程序3)此时lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树(AST)，然后修改该语法树(AST)，增加getter和setter方法定义的相应树节点4)javac使用修改后的抽象语法树(AST)生成字节码文件 四、支持lombok的编译工具 由“三、原理分析”可知，Oracle javac直接支持lombok 常用的项目管理工具Maven所使用的java编译工具来源于配置的第三方工具，如果我们配置这个第三方工具为Oracle javac的话，那么Maven也就直接支持lombok了 Intellij Idea配置的编译工具为Oracle javac的话，也就直接支持lombok了。 Eclipse中使用的不是Oracle javac这个编译工具，而是自己实现的Eclipse Compiler for Java (ECJ).要想使ECJ支持lombok，得进行设置，具体是在Eclipse程序目录中的eclipse.ini文件中添加如下两行设置：-javaagent:[lombok.jar所在路径]-Xbootclasspath/a:[lombok.jar所在路径] 五、其他问题现在使用Intellij Idea作为Java项目的IDE，配置Oracle javac作为编译工具。现在有一个A类，其中有一些字段，没有创建它们的setter和getter方法，使用了lombok的@Data注解，另外有一个B类，它调用了A类实例的相应字段的setter和getter方法 。编译A类和B类所在的项目，并不会报错，因为最终生成的A类字节码文件中存在相应字段的setter和getter方法 。但是，IDE发现B类源代码中所使用的A类实例的setter和getter方法在A类源代码中找不到定义，IDE会认为这是错误 。要解决以上这个不是真正错误的错误，可以下载安装Intellij Idea中的”Lombok plugin”。 六、lombok的罪恶使用lombok虽然能够省去手动创建setter和getter方法的麻烦，但是却大大降低了源代码文件的可读性和完整性，降低了阅读源代码的舒适度。 参考文献 http://stackoverflow.com/questions/6107197/how-does-lombok-work https://projectlombok.org/download.html http://stackoverflow.com/questions/3061654/what-is-the-difference-between-javac-and-the-eclipse-compiler http://www.ibm.com/developerworks/library/j-lombok/ http://notatube.blogspot.com/2010/12/project-lombok-creating-custom.html","categories":[{"name":"IDE","slug":"IDE","permalink":"https://www.itchina.top/categories/IDE/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.itchina.top/tags/java/"},{"name":"lombok","slug":"lombok","permalink":"https://www.itchina.top/tags/lombok/"}]},{"title":"Linux命令之find","slug":"Linux命令之find","date":"2018-04-19T16:34:21.424Z","updated":"2018-04-19T16:30:19.667Z","comments":true,"path":"2018/04/20/Linux命令之find/","link":"","permalink":"https://www.itchina.top/2018/04/20/Linux命令之find/","excerpt":"","text":"Linux下的find命令用来在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件，功能很强大。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效。 需要注意的是在运行一个非常消耗资源的find命令时，我们都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 1. 想查看当前文件夹及子文件夹里文件名含有“log”字样的的文件 find . -name “*.log”. ：表示当前目录 -name：表示要根据名称查找 2. 想查看当前文件夹及子文件夹里有没有”xinsz”目录 find . -type d -name xinsz-type：表示设定类型，d表示文件夹类型，可以替换为f(普通文件)、l(链接文件) 3. 想找出当前文件夹及子文件夹里所有后缀是”.txt”的文件 find . -name “*.txt”4. 想查找当前目录及其子文件夹中“roc”用户自己的文件有哪些 find . -user roc-user：用于设定所属用户的名称，此处可替换为-group，即所属用户组的名称 5. 想查找当前文件夹及子文件夹里权限设定为777的所有文件 find . -perm 777-perm：用于设定权限 6. 想查找当前文件夹及子文件夹里的同时含有b字符和3字符的文件：用到正则表达式技术 find . -regex ‘.b.3’-regex：表示使用正则表达式进行匹配。请注意， 此命令会和“全路径”进行匹配，也就是说前面要加.*，因为输出结果中会有“./”符号。 7. 如果想全部输出用find命令查找出的”*.abc”文件的内容 find . -type f -name “*.abc” -exec cat {} \\;-exec 表示由find找到的匹配项会作为“-exec后面设定的命令”的参数 可以使用-ok代替-exec，这样对每个匹配项进行操作，都会要求用户确认（y为是，n为否） 命令最后的{} \\; 别忘了写，其中{}代表用find查找到的结果中的每一个查找项。 8. 查找当前目录下在10分钟内被修改过的文件 find . -mmin -10访问过用amin，修改过用mmin，文件状态改变过用cmin 精确到分钟的用amin,mmin,cmin，精确到天的用atime,mtime,ctime 在10分钟之内的用-10，在5分钟以上的用＋10 9. 想查找当前目录及子目录下文件大小大于10M的所有文件 find . -size +10000000c-size：表示文件大小，＋表示大于某个数，－表示小于某个数。c表示单位是字节，你可以将c换成k,M,G。 10. 上述所有的find命令都是查找当前目录及其子目录。如果不想深入到子目录中，而是只查找当前一层目录，则可以： find . -maxdepth 1 -name “*.c”11. ** 查找当前所有目录并排序 ** find . -type d | sort几个混合应用： 1.查找磁盘中大于3M的文件： #find . -size +3000k -exec ls -ld {} ; 2.将find出来的东西拷到另一个地方 find *.c -exec cp ‘{}’ /tmp ‘;’3. 避开多个文件夹 find test \\( -path test/test4 -o -path test/test3 \\) -prune -o -print\\ 表示引用 shell不会对\\后面的字符做特殊解释，而留给find命令去解释其意义。不查找test4 和 test3","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.itchina.top/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.itchina.top/tags/linux/"},{"name":"find","slug":"find","permalink":"https://www.itchina.top/tags/find/"}]},{"title":"JBoss 配置windows服务","slug":"JBoss 配置windows服务","date":"2018-04-19T16:34:21.423Z","updated":"2018-04-19T16:30:15.909Z","comments":true,"path":"2018/04/20/JBoss 配置windows服务/","link":"","permalink":"https://www.itchina.top/2018/04/20/JBoss 配置windows服务/","excerpt":"","text":"将Jboss server 配置成一个windows启动服务的两个文件，部署步骤如下： 先检查是否配置java_home和jboss_home的环境变量，如没配置上先配置，如我的是JBOSS_HOME=D:\\jboss-as-7.1.1.Final。 将jbosssvc.exe和service.bat文件拷贝到%JBOSS_HOME%\\bin 目录下，如我的D:\\jboss-as-7.1.1.Final\\bin。 开始－〉运行－〉输入”cmd”，进入命令行，调整目录到%JBOSS_HOME%\\bin,如”cd D:\\jboss-as-7.1.1.Final\\bin” 在命令行中输入 “service.bat install ”，对服务进行安装。提示” Service JBoss7 installed”表示安装成功。可在开始－〉运行－〉输入services.msc，进入服务列表中，查看到名称是Jboss7的服务。右键Jboss7服务－〉属性－〉常规选项卡－〉启动类型改成自动。自此，每次重新计算机时，jboss7服务随机器自动启动。 注销jboss服务的方法同上，使用命令” service.bat uninstall ”。 6．上面提到的两个文件，是从 http://www.jboss.org/jbossweb/downloads/jboss-native-2-0-10.html 中，下载binaries 2.0.10-windows x86得到。jboss配置成service.zip 修改service.bat的启动内容，修改内容如下： a. 第21-23行修改服务的名称、显示名称、描述内容 set SVCNAME=JBoss7server set SVCDISP=JBoss7 set SVCDESC=JBoss AS 7.1.1.Final - Windows x86 b. 第27行注释掉，在set JAVA_OPTS=-Xrs 的前面加REM，该行改为REM set JAVA_OPTS=-Xrx 注释setJAVA_OPTS=-Xrs的原因是，原本加这一行的作用是防止机算机用户注销时使jboss服务器停止，现注释掉就是指用户注销时jboss就停掉。 c.全文替换掉 run.bat为standalone.bat，run.log为standalone.log。此替换是为了重定向到手工启动jboss服务器的单机模式。 7. 64位的服务器需重新下载支持64位的jbosssvc.exe，下载地址如下： http://www.jboss.org/jbossweb/downloads/jboss-native-2-0-10.html 中，下载binaries 2.0.10-windows x64。","categories":[{"name":"集群","slug":"集群","permalink":"https://www.itchina.top/categories/集群/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://www.itchina.top/tags/windows/"},{"name":"jboss","slug":"jboss","permalink":"https://www.itchina.top/tags/jboss/"},{"name":"server","slug":"server","permalink":"https://www.itchina.top/tags/server/"}]},{"title":"Java 异常处理的误区和经验总结","slug":"Java 异常处理的误区和经验总结","date":"2018-04-19T16:34:21.422Z","updated":"2018-04-19T16:29:58.739Z","comments":true,"path":"2018/04/20/Java 异常处理的误区和经验总结/","link":"","permalink":"https://www.itchina.top/2018/04/20/Java 异常处理的误区和经验总结/","excerpt":"","text":"本文着重介绍了 Java 异常选择和使用中的一些误区，希望各位读者能够熟练掌握异常处理的一些注意点和原则，注意总结和归纳。只有处理好了异常，才能提升开发人员的基本素养，提高系统的健壮性，提升用户体验，提高产品的价值。 误区一、异常的选择图 1. 异常分类 图 1 描述了异常的结构，其实我们都知道异常分检测异常和非检测异常，但是在实际中又混淆了这两种异常的应用。由于非检测异常使用方便，很多开发人员就认为检测异常没什么用处。其实异常的应用情景可以概括为以下： 一、调用代码不能继续执行，需要立即终止。出现这种情况的可能性太多太多，例如服务器连接不上、参数不正确等。这些时候都适用非检测异常，不需要调用代码的显式捕捉和处理，而且代码简洁明了。 二、调用代码需要进一步处理和恢复。假如将 SQLException 定义为非检测异常，这样操作数据时开发人员理所当然的认为 SQLException不需要调用代码的显式捕捉和处理，进而会导致严重的 Connection 不关闭、Transaction 不回滚、DB 中出现脏数据等情况，正因为SQLException 定义为检测异常，才会驱使开发人员去显式捕捉，并且在代码产生异常后清理资源。当然清理资源后，可以继续抛出非检测异常，阻止程序的执行。根据观察和理解，检测异常大多可以应用于工具类中。 误区二、将异常直接显示在页面或客户端。将异常直接打印在客户端的例子屡见不鲜，以 JSP 为例，一旦代码运行出现异常，默认情况下容器将异常堆栈信息直接打印在页面上。其实从客户角度来说，任何异常都没有实际意义，绝大多数的客户也根本看不懂异常信息，软件开发也要尽量避免将异常直接呈现给用户。 清单 1package com.yctech.org.sample.exception; /** * 自定义 RuntimeException * 添加错误代码属性 */ public class RuntimeException extends java.lang.RuntimeException { //默认错误代码 public static final Integer GENERIC = 1000000; //错误代码 private Integer errorCode; public RuntimeException(Integer errorCode, Throwable cause) { this(errorCode, null, cause); } public RuntimeException(String message, Throwable cause) { //利用通用错误代码 this(GENERIC, message, cause); } public RuntimeException(Integer errorCode, String message, Throwable cause) { super(message, cause); this.errorCode = errorCode; } public Integer getErrorCode() { return errorCode; } } 正如示例代码所示，在异常中引入错误代码，一旦出现异常，我们只要将异常的错误代码呈现给用户，或者将错误代码转换成更通俗易懂的提示。其实这里的错误代码还包含另外一个功能，开发人员亦可以根据错误代码准确的知道了发生了什么类型异常。 误区三、对代码层次结构的污染我们经常将代码分 Service、Business Logic、DAO 等不同的层次结构，DAO 层中会包含抛出异常的方法，如清单 2 所示： 清单 2public Customer retrieveCustomerById(Long id) throw SQLException { //根据 ID 查询数据库 } 上面这段代码咋一看没什么问题，但是从设计耦合角度仔细考虑一下，这里的 SQLException 污染到了上层调用代码，调用层需要显式的利用 try-catch 捕捉，或者向更上层次进一步抛出。根据设计隔离原则，我们可以适当修改成： 清单 3public Customer retrieveCustomerById(Long id) { try{ //根据 ID 查询数据库 }catch(SQLException e){ //利用非检测异常封装检测异常，降低层次耦合 throw new RuntimeException(SQLErrorCode, e); }finally{ //关闭连接，清理资源 } } 误区四、忽略异常如下异常处理只是将异常输出到控制台，没有任何意义。而且这里出现了异常并没有中断程序，进而调用代码继续执行，导致更多的异常。 清单 4 public void retrieveObjectById(Long id){ try{ //..some code that throws SQLException }catch(SQLException ex){ /** *了解的人都知道，这里的异常打印毫无意义，仅仅是将错误堆栈输出到控制台。 * 而在 Production 环境中，需要将错误堆栈输出到日志。 * 而且这里 catch 处理之后程序继续执行，会导致进一步的问题*/ ex.printStacktrace(); } } 可以重构成： 清单 5public void retrieveObjectById(Long id){ try{ //..some code that throws SQLException } catch(SQLException ex){ throw new RuntimeException(“Exception in retieveObjectById”, ex); } finally{ //clean up resultset, statement, connection etc } } 这个误区比较基本，一般情况下都不会犯此低级错误。 误区五、将异常包含在循环语句块中如下代码所示，异常包含在 for 循环语句块中。 清单 6for(int i=0; i&lt;100; i++){ try{ }catch(XXXException e){ //…. } } 我们都知道异常处理占用系统资源。一看，大家都认为不会犯这样的错误。换个角度，类 A 中执行了一段循环，循环中调用了 B 类的方法，B类中被调用的方法却又包含 try-catch 这样的语句块。褪去类的层次结构，代码和上面如出一辙。 误区六、利用 Exception 捕捉所有潜在的异常一段方法执行过程中抛出了几个不同类型的异常，为了代码简洁，利用基类 Exception 捕捉所有潜在的异常，如下例所示： 清单 7public void retrieveObjectById(Long id){ try{ //…抛出 IOException 的代码调用 //…抛出 SQLException 的代码调用 }catch(Exception e){ //这里利用基类 Exception 捕捉的所有潜在的异常，如果多个层次这样捕捉，会丢失原始异常的有效信息 throw new RuntimeException(“Exception in retieveObjectById”, e); } } 可以重构成 清单 8public void retrieveObjectById(Long id){ try{ //..some code that throws RuntimeException, IOException, SQLException }catch(IOException e){ //仅仅捕捉 IOException throw new RuntimeException(/*指定这里 IOException 对应的错误代码*/code,“Exception in retieveObjectById”, e); }catch(SQLException e){ //仅仅捕捉 SQLException throw new RuntimeException(/*指定这里 SQLException 对应的错误代码*/code,“Exception in retieveObjectById”, e); } } 误区七、多层次封装抛出非检测异常如果我们一直坚持不同类型的异常一定用不同的捕捉语句，那大部分例子可以绕过这一节了。但是如果仅仅一段代码调用会抛出一种以上的异常时，很多时候没有必要每个不同类型的 Exception 写一段 catch 语句，对于开发来说，任何一种异常都足够说明了程序的具体问题。 清单 9try{ //可能抛出 RuntimeException、IOExeption 或者其它； //注意这里和误区六的区别，这里是一段代码抛出多种异常。以上是多段代码，各自抛出不同的异常 }catch(Exception e){ //一如既往的将 Exception 转换成 RuntimeException，但是这里的 e 其实是 RuntimeException 的实例，已经在前段代码中封装过 throw new RuntimeException(/**/code, /**/, e); } 如果我们如上例所示，将所有的 Exception 再转换成 RuntimeException，那么当 Exception 的类型已经是RuntimeException 时，我们又做了一次封装。将 RuntimeException 又重新封装了一次，进而丢失了原有的RuntimeException 携带的有效信息。 解决办法是我们可以在 RuntimeException 类中添加相关的检查，确认参数 Throwable 不是 RuntimeException的实例。如果是，将拷贝相应的属性到新建的实例上。或者用不同的 catch 语句块捕捉 RuntimeException 和其它的Exception。个人偏好方式一，好处不言而喻。 误区八、多层次打印异常我们先看一下下面的例子，定义了 2 个类 A 和 B。其中 A 类中调用了 B 类的代码，并且 A 类和 B 类中都捕捉打印了异常。 清单 10 public class A { private static Logger logger = LoggerFactory.getLogger(A.class); public void process(){ try{ //实例化 B 类，可以换成其它注入等方式 B b = new B(); b.process(); //other code might cause exception } catch(XXXException e){ //如果 B 类 process 方法抛出异常，异常会在 B 类中被打印，在这里也会被打印，从而会打印 2 次 logger.error(e); throw new RuntimeException(/* 错误代码 */ errorCode, /*异常信息*/msg, e); } } } public class B{ private static Logger logger = LoggerFactory.getLogger(B.class); public void process(){ try{ //可能抛出异常的代码 } catch(XXXException e){ logger.error(e); throw new RuntimeException(/* 错误代码 */ errorCode, /*异常信息*/msg, e); } } } 同一段异常会被打印 2 次。如果层次再复杂一点，不去考虑打印日志消耗的系统性能，仅仅在异常日志中去定位异常具体的问题已经够头疼的了。 其实打印日志只需要在代码的最外层捕捉打印就可以了，异常打印也可以写成 AOP，织入到框架的最外层。 误区九、异常包含的信息不能充分定位问题异常不仅要能够让开发人员知道哪里出了问题，更多时候开发人员还需要知道是什么原因导致的问题，我们知道 java .lang.Exception有字符串类型参数的构造方法，这个字符串可以自定义成通俗易懂的提示信息。 简单的自定义信息开发人员只能知道哪里出现了异常，但是很多的情况下，开发人员更需要知道是什么参数导致了这样的异常。这个时候我们就需要将方法调用的参数信息追加到自定义信息中。下例只列举了一个参数的情况，多个参数的情况下，可以单独写一个工具类组织这样的字符串。 清单 11public void retieveObjectById(Long id){ try{ //..some code that throws SQLException }catch(SQLException ex){ //将参数信息添加到异常信息中 throw new RuntimeException(“Exception in retieveObjectById with Object Id :”+ id, ex); } } 误区十、不能预知潜在的异常在写代码的过程中，由于对调用代码缺乏深层次的了解，不能准确判断是否调用的代码会产生异常，因而忽略处理。在产生了 Production Bug 之后才想起来应该在某段代码处添加异常补捉，甚至不能准确指出出现异常的原因。这就需要开发人员不仅知道自己在做什么，而且要去尽可能的知道别人做了什么，可能会导致什么结果，从全局去考虑整个应用程序的处理过程。这些思想会影响我们对代码的编写和处理 ## ## 误区十一、混用多种第三方日志库现如今 Java 第三方日志库的种类越来越多，一个大项目中会引入各种各样的框架，而这些框架又会依赖不同的日志库的实现。最麻烦的问题倒不是引入所有需要的这些日志库，问题在于引入的这些日志库之间本身不兼容。如果在项目初期可能还好解决，可以把所有代码中的日志库根据需要重新引入一遍，或者换一套框架。但这样的成本不是每个项目都承受的起的，而且越是随着项目的进行，这种风险就越大。 怎么样才能有效的避免类似的问题发生呢，现在的大多数框架已经考虑到了类似的问题，可以通过配置 Properties 或 xml 文件、参数或者运行时扫描Lib 库中的日志实现类，真正在应用程序运行时才确定具体应用哪个特定的日志库。 其实根据不需要多层次打印日志那条原则，我们就可以简化很多原本调用日志打印代码的类。很多情况下，我们可以利用拦截器或者过滤器实现日志的打印，降低代码维护、迁移的成本。 _ _ 结束语以上纯属个人的经验和总结，事物都是辩证的，没有绝对的原则，适合自己的才是最有效的原则。希望以上的讲解和分析可以对您有所帮助。","categories":[{"name":"J2EE","slug":"J2EE","permalink":"https://www.itchina.top/categories/J2EE/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.itchina.top/tags/java/"},{"name":"exception","slug":"exception","permalink":"https://www.itchina.top/tags/exception/"},{"name":"异常处理","slug":"异常处理","permalink":"https://www.itchina.top/tags/异常处理/"},{"name":"异常","slug":"异常","permalink":"https://www.itchina.top/tags/异常/"}]},{"title":"idea插件推荐","slug":"idea插件推荐","date":"2018-04-19T16:34:21.421Z","updated":"2018-04-19T16:29:52.629Z","comments":true,"path":"2018/04/20/idea插件推荐/","link":"","permalink":"https://www.itchina.top/2018/04/20/idea插件推荐/","excerpt":"","text":"推荐一些好(zhuang)用(bi)的IDEA插件 1、Alibaba Java Coding Guidelines 用于扫描代码是否符合阿里巴巴开发规范 该插件由阿里巴巴 P3C 项目组研发。 代码已经开源，GitHub： https://github.com/alibaba/p3c 阿里介绍文章： https://mp.weixin.qq.com/s/IbibsXlWHlM59kfXJqRvZA#rd 插件支持了IDEA、Eclipse，在扫描代码后，将不符合规约的代码显示出来，甚至在 IDEA 上，还基于 Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在，还实现了批量一键修复的功能。 解释下 Blocker/Critical/Major 三个等级， 在 Snoar 中对代码规则有五个级别，这是前三个：崩溃/严重/重要，也就是说前两级别是必须要处理掉的。 版权印为您的作品印上版权87546940","categories":[{"name":"IDE","slug":"IDE","permalink":"https://www.itchina.top/categories/IDE/"}],"tags":[]},{"title":"IntelliJ Idea 常用快捷键","slug":"IntelliJ Idea 常用快捷键","date":"2018-04-19T16:34:21.421Z","updated":"2018-04-19T16:30:21.921Z","comments":true,"path":"2018/04/20/IntelliJ Idea 常用快捷键/","link":"","permalink":"https://www.itchina.top/2018/04/20/IntelliJ Idea 常用快捷键/","excerpt":"","text":"最常用快捷键1.Ctrl＋E，可以显示最近编辑的文件列表2.Shift＋Click可以关闭文件3.Ctrl＋[或]可以跳到大括号的开头结尾4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方5.Ctrl＋F12，可以显示当前文件的结构6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择7.Ctrl＋N，可以快速打开类8.Ctrl＋Shift＋N，可以快速打开文件9.Alt＋Q可以看到当前方法的声明10.Ctrl＋W可以选择单词继而语句继而行继而函数11.Alt＋F1可以将正在编辑的元素在各个面板中定位12.Ctrl＋P，可以显示参数信息13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入14.Alt＋Insert可以生成构造器/Getter/Setter等15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch17.Alt＋Up and Alt＋Down可在方法间快速移动下面的不是很有用18.在一些地方按Alt＋Enter可以得到一些Intention Action，例如将”==”改为”equals()”19.Ctrl＋Shift＋Alt＋N可以快速打开符号20.Ctrl＋Shift＋Space在很多时候都能够给出Smart提示21.Alt＋F3可以快速寻找22.Ctrl＋/和Ctrl＋Shift＋/可以注释代码23.Ctrl＋Alt＋B可以跳转到抽象方法的实现24.Ctrl＋O可以选择父类的方法进行重写25.Ctrl＋Q可以看JavaDoc26.Ctrl＋Alt＋Space是类名自动完成27.快速打开类/文件/符号时，可以使用通配符，也可以使用缩写28.Live Templates! Ctrl＋J29.Ctrl＋Shift＋F7可以高亮当前元素在当前文件中的使用30.Ctrl＋Alt＋Up /Ctrl＋Alt＋Down可以快速跳转搜索结果31.Ctrl＋Shift＋J可以整合两行32.Alt＋F8是计算变量值 IntelliJ IDEA使用技巧一览表在使用 InelliJ IDEA 的过程中，通过查找资料以及一些自己的摸索，发现这个众多Java程序员喜欢的IDE里有许多值得一提的小窍门，如果能熟练的将它们应用于实际开发过程中，相信它会大大节省你的开发时间，而且随之而来的还会有那么一点点成就感：） Try it ！ 1、写代码时用 Alt-Insert （ Code|Generate… ）可以创建类里面任何字段的 getter 与 setter 方法。&lt;?xml:namespace prefix = v ns = “urn:schemas-microsoft-com:vml” /&gt; 2、右键点击断点标记（在文本的左边栏里）激活速查菜单，你可以快速设置 enable/disable 断点或者条件它的属性。 3、 CodeCompletion （代码完成）属性里的一个特殊的变量是，激活 Ctrl-Alt-Space可以完成在或不在当前文件里的类名。如果类没有引入则 import 标志会自动创建。 4、使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。 5、利用CodeCompletion（代码完成）属性可以快速地在代码中完成各种不同地语句，方法是先键入一个类名地前几个字母然后再用 Ctrl-Space完成全称。如果有多个选项，它们会列在速查列表里。 6 、用 Ctrl-/ 与 Ctrl-Shift-/ 来注释 / 反注释代码行与代码块。 -/ 用单行注释标记（“ //… ”）来注释 / 反注释当前行或者选择地代码块。而 Ctrl-Shift-/ 则可以用块注释标记（“ /…/ ”）把所选块包围起来。要反注释一个代码块就在块中任何一个地方按 Ctrl-Shift-/ 即可。 7 、按 Alt-Q （ View|Context Info ）可以不需要移动代码就能查看当前方法地声明。连续按两次会显示当前所编辑的类名。 8 、使用 Refactor|Copy Class…可以创建一个所选择的类的“副本”。这一点很有用，比如，在你想要创建一个大部分内容都和已存在类相同的类时。 9 、在编辑器里 Ctrl-D 可以复制选择的块或者没有所选块是的当前行。 10 、 Ctrl-W （选择字）在编辑器里的功能是先选择脱字符处的单词，然后选择源代码的扩展区域。举例来说，先选择一个方法名，然后是调用这个方法的表达式，然后是整个语句，然后包容块，等等。 11 、如果你不想让指示事件细节的“亮球”图标在编辑器上显示，通过按 Alt-Enter组合键打开所有事件列表然后用鼠标点击它就可以把这个事件文本附件的亮球置成非活动状态。 这样以后就不会有指示特殊事件的亮球出现了，但是你仍然可以用 Alt-Enter 快捷键使用它。 12 、在使用 CodeCompletion 时，可以用逗点（ .）字符，逗号（，）分号（；），空格和其它字符输入弹出列表里的当前高亮部分。选择的名字会随着输入的字符自动输入到编辑器里。 13 、在任何工具窗口里使用 Escape 键都可以把焦点移到编辑器上。 Shift-Escape 不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口。 F12 键把焦点从编辑器移到最近使用的工具窗口。 14 、在调试程序时查看任何表达式值的一个容易的方法就是在编辑器中选择文本（可以按几次 Ctrl-W 组合键更有效地执行这个操作）然后按 Alt-F8 。 15 、要打开编辑器脱字符处使用的类或者方法 Java 文档的浏览器，就按 Shift-F1 （右键菜单的 External JavaDoc ）。 要使用这个功能须要把加入浏览器的路径，在“ General ”选项中设置（ Options | IDE Settings ），另外还要把创建的 Java文档加入到工程中（ File | Project Properties ）。 16 、用 Ctrl-F12 （ View | File Structure Popup ）键你可以在当前编辑的文件中快速导航。 这时它会显示当前类的成员列表。选中一个要导航的元素然后按 Enter 键或 F4 键。要轻松地定位到列表中的一个条目，只需键入它的名字即可。 17 、在代码中把光标置于标记符或者它的检查点上再按 Alt-F7 （右键菜单中的 Find Usages…）会很快地查找到在整个工程中使用地某一个类、方法或者变量的位置。 18 、按 Ctrl-N （ Go to | Class… ）再键入类的名字可以快速地在编辑器里打开任何一个类。从显示出来的下拉列表里选择类。同样的方法你可以通过使用 Ctrl-Shift-N （ Go to | File… ）打开工程中的非 Java 文件。 19 、要导航代码中一些地方使用到的类、方法或者变量的声明，把光标放在查看项上再按 Ctrl-B 即可。也可以通过按 Ctrl键的同时在查看点上单击鼠标键调转到声明处。 20 、把光标放到查看点上再按 Ctrl-Alt-B 可以导航到一个抽象方法的实现代码。 21 、要看一个所选择的类的继承层次，按 Ctrl-H （ Browse Type Hierarchy）即可。也可以激活编辑器中的继承关系视图查看当前编辑类的继承关系。22 、使用 Ctrl-Shift-F7 （ Search | HighlightUsages in File ）可以快速高亮显示当前文件中某一变量的使用地方。按 Escape 清除高亮显示。 23 、用 Alt-F3 （ Search | Incremental Search ）在编辑器中实现快速查查找功能。 在“ Search for: ”提示工具里输入字符，使用箭头键朝前和朝后搜索。按 Escape 退出。 24 、按 Ctrl-J 组合键来执行一些你记不起来的 Live Template 缩写。比如，键“ it ”然后按 Ctrl-J 看看有什么发生。 25 、 Introduce Variable 整合帮助你简化代码中复杂的声明。举个例子，在下面的代码片断里，在代码中选择一个表达式：然后按 Ctrl-Alt-V 。 26 、 Ctrl-Shift-J 快捷键把两行合成一行并把不必要的空格去掉以匹配你的代码格式。 27 、 Ctrl-Shift-Backspace （ Go to | Last Edit Location ）让你调转到代码中所做改变的最后一个地方。 多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。 28 、用 Tools | Reformat Code… 根据你的代码样式参考（查看 Options | IDE Setting | Code Style）格式化代码。 使用 Tools | Optimize Imports… 可以根据设置（查看 Options | IDE Setting | Code Style |Imports ）自动“优化” imports （清除无用的 imports 等）。 29 、使用 IDEA 的 Live Templates | Live Templates 让你在眨眼间创建许多典型代码。比如，在一个方法里键入 再按 Tab 键看有什么事情发生了。用 Tab 键在不同的模板域内移动。查看 Options | Live Templates 获取更多的细节。 30 、要查看一个文件中修改的本地历史，激活右键菜单里的 Local VCS | Show History…。也许你可以导航不同的文件版本，看看它们的不同之处再回滚到以前的任何一个版本吧。 使用同样的右键菜单条目还可以看到一个目录里修改的历史。有了这个特性你就不会丢失任何代码了。 31 、如果要了解主菜单里每一个条目的用途，把鼠标指针移到菜单条目上再应用程序框架的底部的状态栏里就会显示它们的一些简短描述，也许会对你有帮助。 32 、要在编辑器里显示方法间的分隔线，打开 Options | IDE Settings | Editor ，选中“ Show methodseparators ”检查盒（ checkbox ）。 33 、用 Alt-Up 和 Alt-Down 键可以在编辑器里不同的方法之间快速移动。 34 、用 F2/Shift-F2 键在高亮显示的语法错误间跳转。 用 Ctrl-Alt-Down/Ctrl-Alt-Up 快捷键则可以在编译器错误信息或者查找操作结果间跳转。 35 、通过按 Ctrl-O （ Code | Override Methods… ）可以很容易地重载基本类地方法。 要完成当前类 implements 的（或者抽象基本类的）接口的方法，就使用 Ctrl-I （ Code | Implement Methods… ）。 36 、如果光标置于一个方法调用的括号间，按 Ctrl-P 会显示一个可用参数的列表。 37 、要快速查看编辑器脱字符处使用的类或方法的 Java 文档，按 Ctrl-Q （在弹出菜单的 Show Quick JavaDoc 里）即可。 38 、像 Ctrl-Q （ Show Quick JavaDoc 显示简洁 Java 文档）， Ctrl-P （ Show Parameter Info显示参数信息）， Ctrl-B （ Go to Declaration 跳转到声明）， Shift-F1 （ External JavaDoc 外部Java 文档）以及其它一些快捷键不仅可以在编辑器里使用，也可以应用在代码完成右键列表里。 39 、 Ctrl-E （ View | Recent Files ）弹出最近访问的文件右键列表。选中文件按 Enter 键打开。 40 、在 IDEA 中可以很容易地对你的类，方法以及变量进行重命名并在所有使用到它们的地方自动更正。 试一下，把编辑器脱字符置于任何一个变量名字上然后按 Shift-F6 （ Refactor | Rename… ）。在对话框里键入要显示地新名字再按Enter 。你会浏览到使用这个变量地所有地方然后按“ Do Refactor ”按钮结束重命名操作。 41 、要在任何视图（ Project View 工程视图， Structure View 结构视图或者其它视图）里快速 选择当前编辑地部分（类，文件，方法或者字段），按 Alt-F1 （ View | Select in… ）。 42 、在“ new ”字符后实例化一个已知类型对象时也许你会用到 SmartType 代码完成这个特性。比如，键入 再按 Ctrl-Shift-Space ： 43 、通过使用 SmartType 代码完成，在 IDEA 中创建接口的整个匿名 implementation 也是非常容易的，比如，对于一些listener （监听器），可以键入 Component component; component.addMouseListener( new ); 然后再按 Ctrl-Shift-Space 看看有什么发生了。 44 、在你需要设置一个已知类型的表达式的值时用 SmartType 代码完成也很有帮助。比如，键入 String s = ( 再按 Ctrl-Shift-Space 看看会有什么出现。 45 、在所有视图里都提供了速查功能：在树里只需键入字符就可以快速定位到一个条目。 46 、当你想用代码片断捕捉异常时，在编辑器里选中这个片断，按 Ctrl-Alt-T （ Code | Surround with… ）然后选择“try/catch ”。它会自动产生代码片断中抛出的所有异常的捕捉块。在 Options | File Templates | Code tab中你还可以自己定制产生捕捉块的模板。 用列表中的其它项可以包围别的一些结构。 47 、在使用代码完成时，用 Tab 键可以输入弹出列表里的高亮显示部分。 不像用 Enter 键接受输入，这个选中的名字会覆盖掉脱字符右边名字的其它部分。这一点在用一个方法或者变量名替换另一个时特别有用。 48 、在声明一个变量时代码完成特性会给你显示一个建议名。比如，开始键入“ private FileOutputStream ”然后按 Ctrl-Space 在 Options | IDE Setting | Code Style 中还可以为本地变量，参数，实例及静态字段定制名字。","categories":[{"name":"IDE","slug":"IDE","permalink":"https://www.itchina.top/categories/IDE/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://www.itchina.top/tags/idea/"}]},{"title":"HTTP 请求","slug":"HTTP 请求","date":"2018-04-19T16:34:21.420Z","updated":"2018-04-19T16:30:01.006Z","comments":true,"path":"2018/04/20/HTTP 请求/","link":"","permalink":"https://www.itchina.top/2018/04/20/HTTP 请求/","excerpt":"","text":"Maven配置： &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.3&lt;/version&gt; &lt;/dependency&gt; HttpUtils： package com.lerry.http; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.List; import java.util.Map; import net.sf.json.JSONObject; import org.apache.http.HttpEntity; import org.apache.http.HttpStatus; import org.apache.http.NameValuePair; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.client.utils.URIBuilder; import org.apache.http.entity.ContentType; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class HttpUtils { private transient static Logger log = LoggerFactory.getLogger(HttpUtils.class); public static String doGet(String url, Map&lt;String,String&gt; param){ //创建HttpClient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); String resultString = &quot;&quot;; CloseableHttpResponse httpResponse = null; try { //创建uri URIBuilder builder = new URIBuilder(url); if(param!=null &amp;&amp; !param.isEmpty()){ for(String key :param.keySet()){ builder.addParameter(key, param.get(key)); } } URI uri = builder.build(); // 创建httpGet请求 HttpGet httpGet = new HttpGet(uri); // 开始执行http请求 long startTime = System.currentTimeMillis(); httpResponse = httpclient.execute(httpGet); long endTime = System.currentTimeMillis(); // 获得响应状态码 int statusCode = httpResponse.getStatusLine().getStatusCode(); log.info(&quot;statusCode:&quot; + statusCode); log.info(&quot;调用API花费时间(单位：毫秒)：&quot; + (endTime - startTime)); // 取出应答字符串 HttpEntity httpEntity = httpResponse.getEntity(); resultString = EntityUtils.toString(httpEntity,Charset.forName(&quot;UTF-8&quot;)); // 去掉返回结果中的&quot;\\r&quot;字符，否则会在结果字符串后面显示一个小方格 resultString.replaceAll(&quot;\\r&quot;, &quot;&quot;); // 判断返回状态是否为200 if (statusCode != HttpStatus.SC_OK) { throw new RuntimeException(String.format(&quot;\\n\\tStatus:%s\\n\\tError Message:%s&quot;, statusCode,resultString)); } } catch (ClientProtocolException e) { log.error(e.getMessage(), e); } catch (IOException e) { log.error(e.getMessage(), e); } catch (URISyntaxException e) { log.error(e.getMessage(), e); } finally{ try { if(httpResponse != null){ httpResponse.close(); } httpclient.close(); } catch (IOException e) { log.error(e.getMessage(), e); } } return resultString; } public static String doGet(String url){ return doGet(url,null); } public static String doPost(String url, Map&lt;String,String&gt; param){ //创建HttpClient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); String resultString = &quot;&quot;; CloseableHttpResponse httpResponse = null; try { // 创建HttpPost对象 HttpPost httpPost = new HttpPost(url); if(param!=null &amp;&amp; !param.isEmpty()){ List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;(); for(String key :param.keySet()){ params.add(new BasicNameValuePair(key, param.get(key))); } httpPost.setEntity(new UrlEncodedFormEntity(params, Charset.forName(&quot;UTF-8&quot;))); } // 开始执行http请求 long startTime = System.currentTimeMillis(); httpResponse = httpclient.execute(httpPost); long endTime = System.currentTimeMillis(); // 获得响应状态码 int statusCode = httpResponse.getStatusLine().getStatusCode(); log.info(&quot;statusCode:&quot; + statusCode); log.info(&quot;调用API花费时间(单位：毫秒)：&quot; + (endTime - startTime)); // 取出应答字符串 HttpEntity httpEntity = httpResponse.getEntity(); resultString = EntityUtils.toString(httpEntity,Charset.forName(&quot;UTF-8&quot;)); // 判断返回状态是否为200 if (statusCode != HttpStatus.SC_OK) { throw new RuntimeException(String.format(&quot;\\n\\tStatus:%s\\n\\tError Message:%s&quot;, statusCode,resultString)); } } catch (ClientProtocolException e) { log.error(e.getMessage(), e); } catch (IOException e) { log.error(e.getMessage(), e); } finally{ try { if(httpResponse != null){ httpResponse.close(); } httpclient.close(); } catch (IOException e) { log.error(e.getMessage(), e); } } return resultString; } public static String doJsonPost(String url, Map&lt;String,String&gt; param){ String resultString = &quot;&quot;; if(param!=null &amp;&amp; !param.isEmpty()){ JSONObject jsonObject = new JSONObject(); for(String key :param.keySet()){ jsonObject.put(key, param.get(key)); } String json = jsonObject.toString(); resultString = doJsonPost(url,json); } else{ resultString = doJsonPost(url,&quot;&quot;); } return resultString; } public static String doJsonPost(String url, String json){ //创建HttpClient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); String resultString = &quot;&quot;; CloseableHttpResponse httpResponse = null; try { // 创建HttpPost对象 HttpPost httpPost = new HttpPost(url); httpPost.setEntity(new StringEntity(json,ContentType.APPLICATION_JSON)); // 开始执行http请求 long startTime = System.currentTimeMillis(); httpResponse = httpclient.execute(httpPost); long endTime = System.currentTimeMillis(); // 获得响应状态码 int statusCode = httpResponse.getStatusLine().getStatusCode(); log.info(&quot;statusCode:&quot; + statusCode); log.info(&quot;调用API 花费时间(单位：毫秒)：&quot; + (endTime - startTime)); // 取出应答字符串 HttpEntity httpEntity = httpResponse.getEntity(); resultString = EntityUtils.toString(httpEntity,Charset.forName(&quot;UTF-8&quot;)); // 判断返回状态是否为200 if (statusCode != HttpStatus.SC_OK) { throw new RuntimeException(String.format(&quot;\\n\\tStatus:%s\\n\\tError Message:%s&quot;, statusCode,resultString)); } } catch (ClientProtocolException e) { log.error(e.getMessage(), e); } catch (IOException e) { log.error(e.getMessage(), e); } finally{ try { if(httpResponse != null){ httpResponse.close(); } httpclient.close(); } catch (IOException e) { log.error(e.getMessage(), e); } } return resultString; } }","categories":[{"name":"J2EE","slug":"J2EE","permalink":"https://www.itchina.top/categories/J2EE/"}],"tags":[]},{"title":"Git命令“从入门到放弃”","slug":"Git命令“从入门到放弃”","date":"2018-04-19T16:34:21.419Z","updated":"2018-04-19T16:30:04.378Z","comments":true,"path":"2018/04/20/Git命令“从入门到放弃”/","link":"","permalink":"https://www.itchina.top/2018/04/20/Git命令“从入门到放弃”/","excerpt":"","text":"git 现在的火爆程度非同一般，它被广泛地用在大型开源项目中，但是初学者非常容易“从入门到放弃”，各种命令各种参数，天哪，宝宝要吓哭了。实际上新手并不需要了解所有命令的用途 ，学习是需要一个循序渐进的过程，你可以从强大的命令开始。这个是给新手或熟悉图形工具的老鸟们看的教程，“从入门到放弃” 一、基本了解 git命令是一些命令行工具的集合，它可以用来跟踪，记录文件的变动。比如你可以进行保存，比对，分析，合并等等。这个过程被称之为版本控制。已经有一系列的版本控制系统，比如SVN, Mercurial, Perforce, CVS, Bitkeepe等等。 Git是分布式的，这意味着它并不依赖于中心服务器，任何一台机器都可以有一个本地版本的控制系统，我们称之为仓库。如果是多人协作的话，你需要还需要一个线上仓库，用来同步信息，这就是GitHub, BitBucket的工作。 1.安装Git 安装git非常直接,Linux - 打开控制台，然后通过包管理安装，在Ubuntu上命令是： sudo apt-get install git-all Windows - 推荐使用git for windows，它包括了图形工具以及命令行模拟器。 OS X - 最简单的方式是使用homebrew安装，命令行执行 &gt;brew install git 如果你是在是先用图形工具的话，那么推荐你使用Github desktop,Sourcetree。但我还是推荐你使用命令行，下面的内容就都是命令行的。 2.配置Git 安装完git,首要任务是配置我们的信息，最重要的是用户名及邮箱，打开终端，执行以下命令。 $ git config --global user.name &quot;My Name&quot; $ git config --global user.email myEmail@example.com 配置好这两项，用户就能知道谁做了什么，并且一切都更有组织性了不是吗? 3.创建一个新仓库 - git init git 会把所有文件以及历史记录保存在你的项目中，创建一个新的仓库，首先要去到项目路径，执行 gitinit。然后git会创建一个隐藏的文件夹.git，所有的信息都储存在其中。 在桌面创建一个联系文件夹 git_exercise, 打开终端： $ cd Desktop/git_exercise/ $ git init OK，现在项目还什么都没有，新建一个 hello.txt 文件试试~ 4.检查状态 - git status git status 是另一个非常重要的命令，它会告诉我们创库的当前状态：是否为最新代码，有什么更新等等执行git status: $ git status On branch master Initial commit Untracked files: (use &quot;git add ...&quot; to include in what will be committed) hello.txt git告诉我们，hello.txt尚未跟踪，这是因为这个文件是新的，git不知道是应该跟踪它的变动呢，还是直接忽略不管呢。为了跟踪我们的新文件，我们需要暂存它。 5.暂存 - git add git 有个概念叫 暂存区，你可以把它看成一块空白帆布，包裹着所有你可能会提交的变动。它一开始为空，你可以通过 git add 命令添加内容，并使用 gitcommit 提交。 这个例子中只有一个文件： $ git add hello.txt 如果需要提交目录下的所有内容，可以这样： $ git add -A 再次使用git status查看： $ git status On branch master Initial commit Changes to be committed: (use &quot;git rm --cached ...&quot; to unstage) new file: hello.txt&lt;br&gt;&lt;/span&gt; 我们的文件已经提交了。状态信息还会告诉我们暂存区文件发生了什么变动，不过这里我们提交的是一个全新文件。 6.提交 - git commit 一次提交代表着我们的仓库到了一个交付状态，通常是完成了某一块小功能。它就像是一个快照，允许我们像使用时光机一样回到旧时光。 创建提交，需要我们提交东西到暂存区(git add)，然后： $ git commit -m &quot;Initial commit.&quot; 这就创建了一次提交，-m “Initial commit.”表示对这次提交的描述，建议使用有意义的描述性信息。 二、远端仓库 到目前为止，我们的操作都是在本地的，它存在于.git文件中。为了能够协同开发，我们需要把代码发布到远端仓库上。 1.链接远端仓库 - git remote add 为了能够上传到远端仓库，我们需要先建立起链接，这篇教程中，远端仓库的地址为：https://github.com/tutorialzine/awesome-project,但你应该自己在Github, BitBucket上搭建仓库，自己一步一步尝试。 添加测试用的远端仓库 $ git remote add origin https://github.com/tutorialzine/awesome-project.git 一个项目可以同时拥有好几个远端仓库为了能够区分，通常会起不同的名字，通常主远端仓库被称为origin。 2.上传到服务器 - git push 每次我们要提交代码到服务器上时，都会使用到git push。 git push命令会有两个参数，远端仓库的名字，以及分支的名字： $ git push origin master Counting objects: done. Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0)To * [new branch] master -&gt; master 取决于你使用的服务器，push过程你可能需要验证身份。如果没有出差错，现在使用浏览器去你的远端分支上看，hello.txt已经在那里等着你了。 3.克隆仓库 - git clone 放在Github上的开源项目，人们可以看到你的代码。可以使用 git clone进行下载到本地。 $ git clone https://github.com/tutorialzine/awesome-project.git 本地也会创建一个新的仓库，并自动将github上的分支设为远端分支。 4.从服务器上拉取代码 - git pull 如果你更新了代码到仓库上，其他人可以通过git pull命令拉取你的变动： $ git pull origin master From * branch master -&gt; FETCH_HEAD Already up-to-date. 因为暂时没有其他人提交，所有没有任何变动 三、分支 当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是： 稳定版本的代码不会被破坏 不同的功能可以由不同开发者同时开发。 开发者可以专注于自己的分支，不用担心被其他人破坏了环境 在不确定之前，同一个特性可以拥有几个版本，便于比较 1.创建新分支 - git branch 每一个仓库的默认分支都叫master, 创建新分支可以这样： $ git branch amazing_new_feature 创建了一个名为amazing_new_feature的新分支，它跟当前分支同一起点 2.切换分支 - git checkout 单独使用git branch，可以查看分支状态： $ git branch amazing_new_feature * master 号表示当前活跃分支为master，使用git checkout切换分支。 $ git checkout amazing_new_feature 3.合并分支 - git merge 我们的 amazing_new_feature 分支的任务是增加一个featuer.txt。我们来创建，添加到暂存区，提交。 $ git add feature.txt $ git commit -m &quot;New feature complete.&quot; 新分支任务完成了，回到master分支 $ git checkout master 现在去查看文件，你会发现，之前创建的feature.txt文件不见了，因为master分支上并没有feature.txt。使用git merge 把amazing_new_feature 分支合并到master上。 $ git merge amazing_new_feature ok!然后再把amazing_new_feature 分支删掉吧。 $ git branch -d amazing_new_feature 四、高级 下面我们来说些比较高级并且使用的技巧。 1.比对两个不同提交之间的差别 每次提交都有一个唯一id，查看所有提交和他们的id，可以使用 git log: $ git log commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7 Author: Tutorialzine Date: Mon May 30 17:15:28 2016 +0300 New feature complete commit b10cc1238e355c02a044ef9f9860811ff605c9b4 Author: Tutorialzine Date: Mon May 30 16:30:04 2016 +0300 Added content to hello.txt commit 09bd8cc171d7084e78e4d118a2346b7487dca059 Author: Tutorialzine&lt;br&gt;Date: Sat May 28 17:52:14 2016 +0300 Initial commit id 很长，但是你并不需要复制整个字符串，前一小部分就够了。 查看某一次提交更新了什么，使用 git show： $ git show b10cc123 \\\\commit b10cc1238e355c02a044ef9f9860811ff605c9b4 Author: Tutorialzine Date: Mon May 30 16:30:04 2016 +0300 Added content to hello.txt diff --git a/hello.txt b/hello.txt index e69de29..b546a21 100644 --- a/hello.txt +++ b/hello.txt @@ -0,0 +1@@ +Nice weather today, isn&apos;t it? 查看两次提交的不同，可以使用git diff [commit-from]..[commit-to] 语法： $ git diff 09bd8cc..ba25c0ff diff --git a/feature.txt b/feature.txt new file mode 100644 index 0000000..e69de29 diff --git a/hello.txt b/hello.txt index e69de29..b546a21 100644 --- a/hello.txt +++ b/hello.txt @@-0,0 +1@@&lt;br&gt;+Nice weather today, isn&apos;t it? 比较首次提交和最后一次提交，我们可以看到所有的更改。当然使用git difftool命令更加方便。 2.回滚某个文件到之前的版本 git 允许我们将某个特定的文件回滚到特定的提交，使用的也是 git checkout。 下面的例子，我们将hello.txt回滚到最初的状态，需要指定回滚到哪个提交，以及文件的全路径。 $ git checkout 09bd8cc1 hello.txt 3.回滚提交 如果你发现最新的一次提交完了加某个文件，你可以通过 git commit —amend来修复，它会把最新的提交打回暂存区，并尝试重新提交。 如果是更复杂的情况，比如不是最新的提交了。那你可以使用git revert。 最新的一次提交别名也叫HEAD。 $ git revert HEAD 其他提交可以使用id： $ git revert b10cc123 混滚提交时，发生冲突是非常频繁的。当文件被后面的提交修改了以后，git不能正确回滚。 4.解决合并冲突 冲突经常出现在合并分支或者是拉去别人的代码。有些时候git能自动处理冲突，但大部分需要我们手动处理。 比如John 和 Tim 分别在各自的分支上写了两部分代码。 John 喜欢 for: // Use a for loop to console.log contents. for(var i=0; i&lt;arr.length; i++) { console.log(arr[i]); } Tim 喜欢 forEach: // Use forEach to console.log contents. arr.forEach(function(item) { console.log(item); }); 假设John 现在去拉取 Tim的代码： $ git merge tim_branch Auto-merging print_array.js CONFLICT (content): Merge conflict in print_array.js Automatic merge failed; fix conflicts and then commit the result. 这时候git并不知道如何解决冲突，因为他不知道John和Tim谁写得更好。 于是它就在代码中插入标记。 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD // Use a for loop to console.log contents. for(var i=0; i&lt;arr.length; i++) { console.log(arr[i]); } ======= // Use forEach to console.log contents. arr.forEach(function(item) { console.log(item); }); &gt;&gt;&gt;&gt;&gt;&gt;&gt;; Tim s commit. ==== 号上方是当前最新一次提交，下方是冲突的代码。我们需要解决这样的冲突，经过组委会成员讨论，一致认定，在座的各位都是垃圾!两个都不要。改成下面的代码。 // Not using for loop or forEach. // Use Array.toString() to console.log contents.console.log(arr.toString()); 好了，再提交一下： $ git add -A $ git commit -m &quot;Array printing conflict resolved.&quot; 如果在大型项目中，这个过程可能容易出问题。你可以使用GUI 工具来帮助你。使用 git mergetool。 5.配置 .gitignore 大部分项目中，会有写文件，文件夹是我们不想提交的。为了防止一不小心提交，我们需要gitignore文件： 在项目根目录创建.gitignore文件 在文件中列出不需要提交的文件名，文件夹名，每个一行 .gitignore文件需要提交，就像普通文件一样 通常会被ignore的文件有： log文件 task runner builds node_modules等文件夹 IDEs生成的文件 个人笔记 例如： *.log build/ node_modules/ .idea/ my_notes.txt","categories":[{"name":"Git","slug":"Git","permalink":"https://www.itchina.top/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.itchina.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://www.itchina.top/tags/github/"},{"name":"版本控制系统","slug":"版本控制系统","permalink":"https://www.itchina.top/tags/版本控制系统/"}]},{"title":"Ext JS 6学习文档-第3章-基础组件","slug":"Ext JS 6学习文档-第3章-基础组件","date":"2018-04-19T16:34:21.418Z","updated":"2018-04-19T16:29:57.019Z","comments":true,"path":"2018/04/20/Ext JS 6学习文档-第3章-基础组件/","link":"","permalink":"https://www.itchina.top/2018/04/20/Ext JS 6学习文档-第3章-基础组件/","excerpt":"","text":"基础组件 在本章中，你将学习到一些 Ext JS 基础组件的使用。同时我们会结合所学创建一个小项目。这一章我们将学习以下知识点： 熟悉基本的组件 – 按钮，文本框，日期选择器等等 表单字段的校验 菜单和工具栏 设计一个表单 计算器程序– 本章的示例项目 本章的主要目的是创建一个表单设计和一个计算器示例项目。以下图分别展示了表单设计和计算器设计。 首先，你观察下列表单设计，你会发现我们使用了大量的控件，例如 label 和文本框。 以下图展示了表单的设计： 继续，设计计算器程序大量的使用了按钮控件。所以你首要学习的是按钮和 handler 。随后在本章最后我们将会构建一个计算器程序。在这个过程中，你会知道如何使 view(视图) 和 controller(控制器)进行交互并协同工作。我们还将看到如何绑定 viewmodel(视图模型) 的属性到一个 view(视图) 的字段上。 下图为计算机的设计展示： 熟悉基本组件Ext JS 有大量的优秀的控件，现在让我们开始认识这些基础的组件吧。 Ext.Button这是一个很常用的控件；handler 是用于处理单击事件，如以下代码所示： Ext.create(&apos;Ext.Button&apos;, { text: &apos;My Button&apos;, renderTo: Ext.getBody(), handler: function() { alert(&apos;click&apos;); } }); 前面代码的输出： 我在第二章已经介绍过如何运行样例代码，但这里我还想再次重申这一点，此文档中的大部分样例代码都是可以直接运行的。你可以选择在你本地设备上或者在 SenchaFiddle 上执行这些示例代码。你可以访问 Sencha Fiddle 并将上面的代码键入到 launch 函数中，运行并查看结果。如果你访问了 https://fiddle.sencha.com 将会看到下列代码： Ext.application({ name : &apos;Fiddle&apos;, launch : function() { Ext.Msg.alert(&apos;Fiddle&apos;, &apos;Welcome to Sencha Fiddle!&apos;); } }) ; 现在粘贴下列的创建按钮的样例代码，运行并查看结果： Ext.application({ name : &apos;Fiddle&apos;, launch : function() { Ext.create(&apos;Ext.Button&apos;, { text: &apos;My Button&apos;, renderTo: Ext.getBody(), handler: function() { alert(&apos;click&apos;); } }); } }); 不是所有的代码都可以这样运行，此外并非所有的示例代码都会有视觉呈现。 你还可以使用 listeners 配置添加更多的事件处理器，如以下代码所示： Ext.create(&apos;Ext.Button&apos;, { text: &apos;My Button&apos;, renderTo: Ext.getBody(), listeners: { click: { fn: function(){ //Handle click event alert(&apos;click&apos;); } }, mouseout: { fn: function(){ //Handle double click event alert(&apos;Mouse out&apos;); } } } }); 以上代码只是创建了一个简单的按钮，你还可以创建很多不同的按钮，有 link button(连接按钮)，menu button(菜单按钮)，togglebutton(开关按钮) 等等； 来创建一个链接按钮，设置 href 属性，如以下代码所示： Ext.create(&apos;Ext.Button&apos;, { renderTo: Ext.getBody(), text: &apos;Link Button&apos;, href: &apos;http://www.sencha.com/&apos; }); 上面创建的链接按钮输出如图。当点击它则打开链接： 通过设置 menu 属性，创建一个菜单按钮，如以下代码所示： Ext.create(&apos;Ext.Button&apos;, { text: &apos;My Button&apos;, renderTo: Ext.getBody(), menu: [{ text: &apos;Item 1&apos; }, { text: &apos;Item 2&apos; }, { text: &apos;Item 3&apos; }] }); 输出如下，当点击时出现下拉菜单： Ext.Button 还有许多属性，例如 bind ， cls ， disabled ， html ， tooltip ， tpl等等，你可以根据自己需求使用。 Ext.MessageBoxExt.window.MessageBox 类提供了 message box 实现。 Ext. MessageBox 是一个单例对象。你可以使用MessageBox 弹出一个警告，信息确认，提示输入等等。 下列代码将弹出一个简单的提示信息。这里解释一下 Ext.Msg 是 Ext. Messagebox 类的别名： Ext.Msg.alert(&apos;Info&apos;, &apos;Document saved!&apos;); 下列代码将弹出一个消息确认框，button 为选择的值，取 yes 或 no ： Ext.Msg.confirm(&apos;Confirm&apos;, &apos;Are you want to cancel the updates?&apos;, function(button){ if(&apos;yes&apos;==button) { } else { } }); 你也可以自定义这个 message box 如下： Ext.MessageBox.show({ title:&apos;Save Changes?&apos;, msg: &apos;Do you want to save the file?&apos;, buttons: Ext.MessageBox.YESNO, fn: function(button){ if(&apos;yes&apos;==button){ }else if(&apos;no&apos;==button){ } }, icon: Ext.MessageBox.QUESTION }) ; 上面代码输出如下： 表单和表单字段 现在我们看一下都有哪些表单相关的组件。 Ext.form.Panel这个 form panel (表单面板)继承自 panel 并添加了表单相关的功能，例如字段管理，校验，提交等等。form panel 的默认布局是anchor layout ，但是如果需要你可以改变这个配置。 form panel 有一个很方便的配置为 fieldDefaults ，它可以用于指定表单内所有字段的默认类型。 fields (字段/表单域)Ext JS 提供了很多内置的表单字段。比较常用的一些字段： Ext.form.field.Checkbox Ext.form.field.ComboBox Ext.form.field.Date Ext.form.field.File Ext.form.field.Hidden Ext.form.field.HtmlEditor Ext.form.field.Number Ext.form.field.Radio Ext.form.field.Text Ext.form.field.TextArea Ext.form.field.Time 我们看一下其中的一些字段的应用。 Ext.form.field.Text这是一个基本的文本框，它具有很多有用的属性和配置。其中有一个很有用的属性是 vtype 它是用于校验的。 例如以下代码，这个 vtype 属性为email 用于验证输入内容是否是有效的电子邮箱： Ext.create(&apos;Ext.form.field.Text&apos;, { renderTo: Ext.getBody(), name: &apos;email&apos;, fieldLabel: &apos;Email&apos;, allowBlank: false, vtype: &apos;email&apos; }); 这里 allowBlank 也是一个校验属性。通过设置 allowBlank 属性为 false ，如果这个字段为空白，将会提示校验不通过。 Ext.form.field.Numbernumber 字段继承自 spinner 字段，spinner 字段则继承自 text 字段，进而的 number 等于是继承了两者。这个 number字段提供了几个选项来处理数值。下列代码创建了一个数值文本框： Ext.create(&apos;Ext.form.field.Number&apos;, { renderTo: Ext.getBody(), name: &apos;Count&apos;, fieldLabel: &apos;Count&apos;, value: 0, maxValue: 10, minValue: 0 }); 你可以移除下拉按钮，方向键，鼠标滚轮监听，用配置： hideTrigger ， keyNavEnabled ，和mouseWheelEnabled 。 Ext.form.field.ComboBox下列代码创建了一个月份下拉菜单。这个 combobox 有一个配置为 store 。 这个 store 是数据源，为此下拉菜单提供数据。store 是属于 ExtJS 中数据包部分， 在接下来的章节中我们会详细介绍的。 combobox 中另一个重要的配置是 queryMode 。这个属性取值可以是 ‘local’ 或者 ‘remote’。如果你设置为 remote了，那么这个数据源 store 将在运行加载数据时发送请求从远程服务器获取数据： var months = Ext.create(&apos;Ext.data.Store&apos;, { fields: [&apos;abbr&apos;, &apos;name&apos;], data: [{&quot;abbr&quot;:&quot;JAN&quot;, &quot;name&quot;:&quot;January&quot;}, {&quot;abbr&quot;:&quot;FEB&quot;, &quot;name&quot;:&quot;February&quot;}, {&quot;abbr&quot;:&quot;MAR&quot;, &quot;name&quot;:&quot;March&quot;}, {&quot;abbr&quot;:&quot;APR&quot;, &quot;name&quot;:&quot;April&quot;}, {&quot;abbr&quot;:&quot;MAY&quot;, &quot;name&quot;:&quot;May&quot;}, {&quot;abbr&quot;:&quot;JUN&quot;, &quot;name&quot;:&quot;June&quot;}, {&quot;abbr&quot;:&quot;JUL&quot;, &quot;name&quot;:&quot;July&quot;}, {&quot;abbr&quot;:&quot;AUG&quot;, &quot;name&quot;:&quot;August&quot;}, {&quot;abbr&quot;:&quot;SEP&quot;, &quot;name&quot;:&quot;September&quot;}, {&quot;abbr&quot;:&quot;OCT&quot;, &quot;name&quot;:&quot;October&quot;}, {&quot;abbr&quot;:&quot;NOV&quot;, &quot;name&quot;:&quot;November&quot;}, {&quot;abbr&quot;:&quot;DEC&quot;, &quot;name&quot;:&quot;December&quot;}] }) ; Ext.create(&apos;Ext.form.ComboBox&apos;, { fieldLabel: &apos;Choose Month&apos;, store: months, queryMode: &apos;local&apos;, displayField: &apos;name&apos;, valueField: &apos;abbr&apos;, renderTo: Ext.getBody() }); 以上代码的输出如下： Ext.form.field.HtmlEditorExt JS 也有一个非常优秀的 HTML 编辑器，它提供直接在 web 页面上处理文字的能力，如以下代码所示： Ext.create(&apos;Ext.form.HtmlEditor&apos;, { width: 800, height: 200, renderTo: Ext.getBody() }); 以上代码输出如下： 表单字段的校验大多数表单都有自己的校验规则，例如你键入了一个非数值的内容到 number 字段，它将显示一个验证无效的提示。再有这个 text 字段(文本框) 校验属性有allowBlank ， minLength ，和 maxLength 。 更进一步的，还有 regex 属性可以使用正则表达式自定义校验。 form panel 的事件form panel 支持的部分事件： beforeaction : 任意动作执行前触发，例如 submit，load，doAction 这些动作执行时 actionfailed : 执行一个动作失败时触发 actioncomplete : 在一个动作执行完成之后触发This event will be fired after an action is completed validitychange : 表单键入的内容有效性发生变化时触发 dirtychange : 表单的dirty状态改变时触发 表单字段容器以下是一些 from panel 里很有用的容器。 Ext.form.CheckboxGroupCheckboxGroup 继承自 FieldContainer 用于组织复选框。下列示例中，复选框组的 items 中所有的项都有相同的 name；这有助于将得到的值作为一个单一的参数传递给服务器。 Ext.create(&apos;Ext.form.CheckboxGroup&apos;, { renderTo: Ext.getBody(), fieldLabel: &apos;Skills &apos;, vertical: true, columns: 1, items: [{ boxLabel: &apos;C++&apos;, name: &apos;rb&apos;, inputValue: &apos;1&apos; }, { boxLabel: &apos;.Net Framework&apos;, name: &apos;rb&apos;, inputValue: &apos;2&apos;, checked: true }, { boxLabel: &apos;C#&apos;, name: &apos;rb&apos;, inputValue: &apos;3&apos; }, { boxLabel: &apos;SQL Server&apos;, name: &apos;rb&apos;, inputValue: &apos;4&apos; }] }) ; 以上代码输出如下： Ext.form.FieldContainerFieldContainer 是很有用的，当你想将一组相关字段附加到一个标签时。 以下代码的输出你会发现一个 label 后面绑定了两个文本框： Ext.create(&apos;Ext.form.FieldContainer&apos;, { renderTo: Ext.getBody(), fieldLabel: &apos;Name&apos;, layout: &apos;hbox&apos;, combineErrors: true, defaultType: &apos;textfield&apos;, defaults: { hideLabel: &apos;true&apos; }, items: [{ name: &apos;firstName&apos;, fieldLabel: &apos;First Name&apos;, flex: 2, emptyText: &apos;First&apos;, allowBlank: false }, { name: &apos;lastName&apos;, fieldLabel: &apos;Last Name&apos;, flex: 3, margin: &apos;0 0 0 6&apos;, emptyText: &apos;Last&apos;, allowBlank: false }] }); Ext.form.RadioGroupRadioGroup 继承自 CheckboxGroup 用于组织单选按钮。items 中的项都有相同的 name，另外这是单选的，如以下代码所示： Ext.create(&apos;Ext.form.RadioGroup&apos;, { renderTo: Ext.getBody(), fieldLabel: &apos;Sex &apos;, vertical: true, columns: 1, items: [{ boxLabel: &apos;Male&apos;, name: &apos;rb&apos;, inputValue: &apos;1&apos; },{ boxLabel: &apos;Female&apos;, name: &apos;rb&apos;, inputValue: &apos;2&apos; }] }); 代码输出： 提交表单使用 form 的 submit 方法提交表单。使用 getForm 方法获取表单并 isValid 方法进行提交前的表单内容校验。如以下代码所示： var form = this.up(&apos;form&apos;).getForm(); if (form.isValid()) { form.submit({ url: &apos;someurl&apos;, success: function () { }, failure: function () { } }); } else { Ext.Msg.alert(&apos;Error&apos;, &apos;Fix the errors in the form&apos;) } 菜单和工具栏对于你能想到的任何的菜单和工具栏 Ext JS 提供了最完整的支持。 Ext.toolbar.Toolbar 用于构建一个工具栏。默认情况下任何子项在Ext.toolbar.Toolbar 都是按钮，但是你可以添加任意控件进去，例如一个文本框，一个数值框，一个图标，一个下拉菜单等等。 规范整理你的工具栏中的项，你可以使用 空格( Ext.toolbar.Spacer )， 分隔符( Ext.toolbar. Separator)，和 使控件右对齐( Ext.toolbar.Fill ) 。这里也可以使用快捷方式 ‘ ‘ (空格)，’-‘ 和 ‘|’(都是分隔符，只有很小的差别)，和 ‘ -&gt; ‘ (右对齐)。 Ext.menu.Menu 用于构建一个菜单，items 属性中为 Ext.menu.Item 一个个菜单项。 一个简单的代码示例和以下截图的输出： Ext . create ( ‘Ext.toolbar.Toolbar’ , { renderTo : Ext . getBody ( ) , width : 800 , items : [ { text : ‘My Button’ } , { text : ‘My Button’ , menu : [ { text : ‘Item 1’ } , { text : ‘Item 2’ } , { text : ‘Item 3’ } ] } , { text : ‘Menu with divider’ , tooltip : { text : ‘Tooltip info’ , title : ‘Tip Title’ } , menu : { items : [ { text : ‘Task 1’ , // handler: onItemClick } , ‘-‘ , { text : ‘Task 2’ , // handler: onItemClick } , { text : ‘Task 3’ , // handler: onItemClick } ] } } , ‘-&gt;’ , { xtype : ‘textfield’ , name : ‘field1’ , emptyText : ‘search web site’ } , ‘-‘ , ‘Some Info’ , { xtype : ‘tbspacer’ } , { name : ‘Count’ , xtype : ‘numberfield’ , value : 0 , maxValue : 10 , minValue : 0 , width : 60 } ] } ) ; 设计一个(客户反馈)表单现在根据之前所学，我们来设计一个表单。 我们将设计如图所示的表单： 以下是这个表单的代码。这里我维护着一个这个例子的完整的源码 https://github.com/ananddayalan/extjs-by-example-customer-feedback-form 这里我们所有的组件都在 Viewport 中。 这是一个专用的容器，它代表浏览器里应用的视图区域。 在 Viewport 中我们设置 scrollable 选项将子组件设为滚动的，使用 true 或 false 。也可以取值为 x 或 y表示只允许水平或垂直滚动： Ext.create(&apos;Ext.container.Viewport&apos;, { scrollable: true, items: [{ xtype: &apos;container&apos;, layout: { type: &apos;hbox&apos;, align: &apos;center&apos;, pack: &apos;center&apos; }, items: [ { xtype: &apos;form&apos;, bodyPadding: 20, maxWidth: 700, flex: 1, title: &apos;Custom Feedback&apos;, items:[{ xtype: &apos;fieldcontainer&apos;, layout: &apos;hbox&apos;, fieldLabel: &apos;Name&apos;, defaultType: &apos;textfield&apos;, defaults: { allowBlank: false, flex: 1 }, items: [{ name: &apos;firstName&apos;, emptyText: &apos;First Name }, { name: &apos;lastName&apos;, margin: &apos;0 0 0 5&apos;, emptyText: &apos;Last Name&apos; }] },{ xtype: &apos;datefield&apos;, fieldLabel: &apos;Date of Birth&apos;, name: &apos;dob&apos;, maxValue: new Date() /* Prevent entering the future date.*/ }, { fieldLabel: &apos;Email Address&apos;, name: &apos;email&apos;, vtype: &apos;email&apos;, allowBlank: false }, { fieldLabel: &apos;Phone Number&apos;, labelWidth: 100, name: &apos;phone&apos;, width: 200, emptyText: &apos;xxx-xxx-xxxx&apos;, maskRe: /[\\d\\-]/, regex: /^\\d{3}-\\d{3}-\\d{4}$/, regexText: &apos;The format must be xxx-xxx-xxxx&apos; },{ xtype: &apos;radiogroup&apos;, fieldLabel: &apos;How satisfied with our service?&apos;, vertical: true, columns: 1, items: [ { boxLabel: &apos;Very satisfied&apos;, name: &apos;rb&apos;, inputValue: &apos;1&apos; }, { boxLabel: &apos;Satisfied&apos;, name: &apos;rb&apos;, inputValue: &apos;2&apos; }] },{ xtype: &apos;checkboxgroup&apos;, fieldLabel: &apos;Which of these words would you use to describe our products? Select all that apply&apos;, vertical: true, columns: 1, items: [{ boxLabel: &apos;Reliable&apos;, name: &apos;ch&apos;, inputValue: &apos;1&apos; }] },{ xtype: &apos;radiogroup&apos;, fieldLabel: &apos;How likely is it that you would recommend this company to a friend or colleague?&apos;, vertical: false, defaults: { padding: 20 }, items: [ { boxLabel: &apos;1&apos;, name: &apos;recommend&apos;, inputValue: &apos;1&apos; }], buttons: [{ text: &apos;Submit&apos;, handler: function () { var form = this.up(&apos;form&apos;).getForm(); if (form.isValid()) { form.submit({ url: &apos;cutomer/feedback&apos;, success: function () {}, failure: function () {} }); } else { Ext.Msg.alert(&apos;Error&apos;, &apos;Fix the errors in the form&apos;) } } }] }] }] }] }); 在以上代码中通过在容器级设置 defaultType 属性，这样我们就可以不必在容器的每个子组件里重复的指定 xtype属性了。这样默认情况下，所有子组件在没有显式指定 xtype 时默认的类型都是 textfield 。 form panel 上有一个 flex 配置用于填补父容器的宽度，同时通过设置 maxWidth 为 700 限制 form panel 的最大宽度。 字段容器使用 hbox 布局将 first name 和 last name 文本框放在一个 label 标签下。 写一个计算器应用现在我们结合目前所学构建一个完整的小项目。这是我们将要构建的计算器的设计： 文件夹结构这是我们创建的计算器工程的目录结构。这里我不是用 sencha Cmd 生成的项目，只是从 Ext JS 复制了一些必须的文件到项目文件夹中： 完整可用的项目在这里： https://github.com/ananddayalan/extjs-by-example-calculator . App – app.js在 app.js 文件里我们简单的创建了 Main 视图，作为可移动窗体浮动在浏览器： Ext.application({ name: &apos;Calc&apos;, launch: function () { Ext.create(&apos;Calc.view.main.Main&apos;).show(); } }); 再谈 MVC 和 MVVM第一章的时候，我们已经介绍过 MVC ( Model View Controller ) 和 MVVM ( Model ViewViewModel )。 这个示例项目的代码很好的展示了 视图，控制器，和视图模型之间的区别。 Model (模型)这代表着数据层。model 保存的数据可以包含数据验证和逻辑。 View (视图)这一层是用户界面。包含有 button，form，和 message box 等等组件。在我们这次写的计算器应用中 main.js就是一个很好的视图例子。 Controller (控制器)控制器处理 view(视图)相关的逻辑，例如 view 的 event(事件)处理，还有任何程序相关逻辑都可以写在这里。 ViewController (视图控制器) 和 Controller (控制器)在 Ext JS 5 和 6 中，有两种类型的控制器： ViewController 和 Controller 。 这个ViewController 自 Ext JS 5 开始引进的。 ViewController是为一个指定的视图创建的控制器，但是这个控制器也可以交叉其他视图的逻辑。 ViewController 带来了一些新的概念，例如 引用和监听，简化视图与控制之间的关系。同时 View 销毁时 ViewController也会被销毁，他们具有相同的生命周期，在这个例子中我们没有使用 引用和监听，但是在下一个例子中我们会使用的。 你可以使用 listeners 代替 handler 处理事件 View modelview model 封装了 view(视图)所需要的展示逻辑，绑定数据到 view 并且每当数据改变时处理更新。 它有别于 model ， view model 主要是为一个指定的视图而创建的。一个 model 是一个纯粹的数据类并可用于整个应用中，但一个view model 是起到一个 view 和 model 之间的数据粘合剂的作用。看一下 main.js 的 视图模型绑定。 视图 — Main.js这里我为这个计算器应用创建一个视图为 Main 。这个视图里包含所有的按钮，显示字段等等。相关的事件用 controller的方法。这个视图的控制器已经使用 controller 配置指定了。 这个视图使用 table 布局，配置为 4 列。CSS 类使用 cls 属性指定。 代码里有附加的注释： Ext.define(&apos;Calc.view.main.Main&apos;, { extend: &apos;Ext.window.Window&apos;, /* 表示在当前视图加载之前先加载这些所需的类*/ requires: [ &apos;Calc.view.main.MainController&apos;, &apos;Calc.view.main.MainModel&apos;], xtype: &apos;app-main&apos;, controller: &apos;main&apos;, /* 视图的 view model (视图模型)*/ viewModel: { type: &apos;main&apos; }, resizable: false, layout: { type: &apos;table&apos;, columns: 4 }, /* defaultType 和 defaults 属性是用于 items 内的子组件的，任何子组件都可以覆盖这些配置 */ defaultType: &apos;button&apos;, defaults: { width: 50, height: 50, cls: &apos;btn&apos;, handler: &apos;onClickNumber&apos; }, /* 这里我用 Ext.window.Window 的 header 显示计算器的结果。使用 header 你可以在浏览器里移动这个计算器。*/ header: { items: [{ xtype: &apos;displayfield&apos;, colspan: 4, width: 200, cls: &apos;display&apos;, bind: { value: &apos;{display}&apos; }, height: 60, padding: 0 }] }, items: [{ text: &apos;C&apos;, colspan: 2, width: 100, cls: &apos;btn-green&apos;, handler: &apos;onClickClear&apos; }, { text: &apos;+/-&apos;, cls: &apos;btn-green&apos;, handler: &apos;onClickChangeSign&apos; }, { text: &apos;÷&apos;, cls: &apos;btn-orange&apos;, handler: &apos;onClickOp&apos; },{ text: &apos;7&apos; },{ text: &apos;8&apos; },{ text: &apos;9&apos; },{ text: &apos;×&apos;, cls: &apos;btn-orange&apos;, handler: &apos;onClickOp&apos; },{ text: &apos;4&apos; },{ text: &apos;5&apos; },{ text: &apos;6&apos; },{ text: &apos;-&apos;, cls: &apos;btn-orange&apos;, handler: &apos;onClickOp&apos; },{ text: &apos;1&apos; },{ text: &apos;2&apos; },{ text: &apos;3&apos; },{ text: &apos;+&apos;, cls: &apos;btn-orange&apos;, handler: &apos;onClickOp&apos; },{ text: &apos;0&apos;, width: 100, colspan: 2 },{ text: &apos;.&apos;, handler: &apos;onClickDot&apos; },{ text: &apos;=&apos;, cls: &apos;btn-orange&apos;, handler: &apos;onClickOp&apos; }] }); 控制器 — MainController.js虽然这个控制器的代码有点长，这是一个非常简单的代码。控制器中有很多方法处理按钮的点击事件，例如运算符和操作数的点击处理。控制器使用了一个 model 为Main ： Ext.define(&apos;Calc.view.main.MainController&apos;, { extend: &apos;Ext.app.ViewController&apos;, alias: &apos;controller.main&apos;, views: [&apos;Calc.view.main.Main&apos;], models: [&apos;Main&apos;], //这个 state 是一个自定义属性，用来跟踪计算器的状态。 state: { operatorClicked: false, selectedOperator: null, dotClicked: false, op1: 0, numberClicked: false, sign: true, decimal: false }, onClickClear: function () { var vm = this.getViewModel(); vm.set(&apos;display&apos;,&apos;0&apos;); this.state.selectedOperator=null; this.state.op1=0; this.state.isPositive = true; this.state.decimal = false; this.state.sign = true; }, onClickChangeSign: function (btn) { var vm = this.getViewModel(); var cur = vm.get(&apos;display&apos;); if(cur!=&apos;0&apos;) { if(this.state.sign===true ) { vm.set(&apos;display&apos;, &apos;-&apos; + cur); }else { vm.set(&apos;display&apos;, cur.toString().substring(1)); } } this.state.sign=!this.state.sign; }, onClickOp: function (btn) { if(this.state.selectedOperator!=null &amp;&amp; this.state.numberClicked===true){ var vm = this.getViewModel(); var op2 = parseFloat(vm.get(&apos;display&apos;)); var op1 = parseFloat(this.state.op1); var result = 0; switch(this.state.selectedOperator){ case &apos;+&apos;: result = op1 + op2; break; case &apos;-&apos;: result = op1 - op2; break; case &apos;×&apos;: result = op1 * op2; break; case &apos;÷&apos;: result = op1 / op2; break; } vm.set(&apos;display&apos;, Math.round(result * 100) / 100); this.state.selectedOperator=null; } if(btn.text!=&apos;=&apos;) { this.state.operatorClicked = true; } this.state.selectedOperator = btn.text; this.state.numberClicked = false; }, onClickDot: function (btn) { if(this.state.decimal===false) { var vm = this.getViewModel(); vm.set(&apos;display&apos;, vm.get(&apos;display&apos;) + &apos;.&apos;); } }, onClickNumber: function (btn) { this.state.numberClicked = true; if(this.state.selectedOperator ===&apos;=&apos;){ this.onClickClear(); } var vm = this.getViewModel(); if(this.state.operatorClicked===true) { this.state.op1= vm.get(&apos;display&apos;); vm.set(&apos;display&apos;, btn.text); this.state.operatorClicked=false; }else{ var cur = vm.get(&apos;display&apos;); if(cur == &apos;0&apos;) { cur = &apos;&apos;; } vm.set(&apos;display&apos;, cur + btn.text); } } }); 视图模型 — MainViewModel.js这个 ViewModel 只有一个属性为 display。这个用来绑定到计算器显示的值上。这里我们不会分别用一组字段创建模型，此外我们还将会硬编码数据。 Ext.define(&apos;Calc.view.main.MainModel&apos;, { extend: &apos;Ext.app.ViewModel&apos;, alias: &apos;viewmodel.main&apos;, data: { display: 0.0 } }); 在即将到来的章节中你将学习更多关于 模型，视图模型，字段，字段类型，校验 等等。 总结在本章中，你了解了不同的基本组件，例如 文本框，数字框，按钮，菜单等等。你已经学会如何使用表单字段设计一个表单和我们之前创建了一个简单的计算器项目。 在下一章中，你将学习关于数据包的内容，例如 数据源 ，模型 ，代理等等。store ，model ，这将是有益于处理数据的。","categories":[{"name":"ExtJs","slug":"ExtJs","permalink":"https://www.itchina.top/categories/ExtJs/"}],"tags":[{"name":"ext","slug":"ext","permalink":"https://www.itchina.top/tags/ext/"},{"name":"extjs","slug":"extjs","permalink":"https://www.itchina.top/tags/extjs/"},{"name":"java","slug":"java","permalink":"https://www.itchina.top/tags/java/"}]},{"title":"Ext JS 6学习文档–第2章–核心概念","slug":"Ext JS 6学习文档–第2章–核心概念","date":"2018-04-19T16:34:21.418Z","updated":"2018-04-19T16:29:57.510Z","comments":true,"path":"2018/04/20/Ext JS 6学习文档–第2章–核心概念/","link":"","permalink":"https://www.itchina.top/2018/04/20/Ext JS 6学习文档–第2章–核心概念/","excerpt":"","text":"# 核心概念在下一章我们会构建一个示例项目，而在这之前，你需要学习一些在 Ext JS 中的核心概念，这有助于你更容易理解示例项目。这一章我们将学习以下知识点： 类系统，创建和扩展类 事件 Ext JS 对象的查询 容器 布局 class system(类系统) Ext JS 提供了很多功能，使得它创建和处理类变得简单。以下是在 Ext JS 6 的类系统中的几大组成类： Ext Base Class ClassManager Loader ##### Ext 类Ext 是一个全局单例的对象，在 Sencha library 中它封装了所有的类和许多实用的方法。许多常用的函数都定义在 Ext对象里。它还提供了像其他类中一些频繁使用的方法的快速调用。 我们看一下在 Ext 类中定义的方法和属性： application 方法这里应用是用 Ext.application 方法初始化的。这个方法的参数是一个 Ext.app.Application 对象，这个方法会加载Ext.app.Application 类，并在页面加载完成后开始应用给定的配置。 Ext.app.Application 这个类代表我们的整个应用，这在第1章(入门指南)讲过，讲过的吧？是吧？下面是Ext.app.Application 的使用例子： Ext.application({ name: &apos;MyApp&apos;, extend:&apos;MyApp.Application&apos;, launch: function() { } }) ; 上面代码创建一个名为 MyApp 的全局变量。我们的应用里所有的类都将归属于在这样一个命名空间下面。这将降低全局变量产生冲突的可能。 define 方法你可以用这个方法定义或者重写一个类。 这个方法有三个参数，如以下代码所示。 在这里 name 参数是你要定义的类名， data参数是应用于这个类的属性， callback 是可选参数，这个函数将会在这个类被创建后调用： Ext.define(name,data, callback) 下列代码创建一个名为 Car 的类： Ext.define(&apos;Car&apos;, { name: null, constructor: function(name) { if (name) { this.name = name; } }, start: function() { alert(&apos;Car started&apos;); } }) ; 你还可以使用 define 继承扩展一个类： Ext.define(&apos;ElectricCar&apos;, { extend: &apos;Car&apos;, start: function() { alert(&quot;Electric car started&quot;); } }) ; 如果你想替换一个父类方法的实现，你可以使用 Ext.define 来重写这个方法，如以下代码所示： # Ext.define(&apos;My.ux.field.Text&apos;, { override: &apos;Ext.form.field.Text&apos;, setValue: function(val) { this.callParent([&apos;In override&apos;]); return this; } }); 细心的同学可能发现了当我们继承和重写时使用的属性是不同的，继承我们使用 extend 而重写使用 override，这两者之间有什么区别呢？你一定感到疑惑，这里我非常有必要给你解释清楚，听我慢慢道来。 首先说继承并扩展一个类，这等同于是一个新的类，仍然可以在这个新的类里增加自己独有的方法和属性或者重写父类的方法。 Ext.define(&apos;MyApp.view.main.Test&apos;, { extend: &apos;Ext.grid.Panel&apos;, xtype: &apos;maintest&apos;, title: &apos;Personnel&apos;, say:function(){ alert(123); } }); 这里我继承了 gridpanel 类，并增加了一个 say方法，以下是输出调用 say 方法的运行结果。 这应该很好理解，Test 继承了 grid panel 之后是一个新的类了，而这里如果创建 Ext.grid.Panel 对象是调用不了 say 方法的。 那么现在我把 extend 改为 override 我们再看一下： Ext.define(&apos;MyApp.view.main.Test&apos;, { override: &apos;Ext.grid.Panel&apos;,//改为 override 了 xtype: &apos;maintest&apos;, title: &apos;Personnel&apos;, say:function(){ alert(123); } }); Ext.define(&apos;MyApp.Application&apos;, { extend: &apos;Ext.app.Application&apos;, name: &apos;MyApp&apos;, requires: [ &apos;MyApp.view.main.Main&apos;, &apos;MyApp.view.main.Test&apos;//我这里引入了 Test ], stores: [ // TODO: add global / shared stores here ], launch: function () { var test = Ext.create(&quot;MyApp.view.main.Test&quot;,{ title: &apos;Personnel&apos; }); test.say(); }, onAppUpdate: function () { Ext.Msg.confirm(&apos;Application Update&apos;, &apos;This application has an update, reload?&apos;, function (choice) { if (choice === &apos;yes&apos;) { window.location.reload(); } } ); } }); 运行结果： 我们可以看到我只是简单的把 extend 替换成 override 就报错说不能识别的类名。但是上面我也是引入了它的引用的(requires)，可见extend 和 override 还是有区别的，我们不是重写(override)的是 grid panel 吗？那我们试试创建一个Ext.grid.Panel 对象试试。 Ext.define(&apos;MyApp.Application&apos;, { extend: &apos;Ext.app.Application&apos;, name: &apos;MyApp&apos;, requires: [ &apos;MyApp.view.main.Main&apos;, &apos;MyApp.view.main.Test&apos; ], stores: [ // TODO: add global / shared stores here ], launch: function () { //这里改成了 grid panel var test = Ext.create(&quot;Ext.grid.Panel&quot;,{ title: &apos;Personnel&apos; }); test.say(); }, onAppUpdate: function () { Ext.Msg.confirm(&apos;Application Update&apos;, &apos;This application has an update, reload?&apos;, function (choice) { if (choice === &apos;yes&apos;) { window.location.reload(); } } ); } }); 再次运行结果： 这次正常了，我们使用 Ext.define 定义的类，使用了 override 重写组件，发现并不能新建我们定义的类，而是被重写的父类被新增了 say方法。 所以总结一下，extend 会创建一个新的类，并继承父类的属性和方法，你也可以重写父类的方法。而 override并不会创建一个新的类，而是修改这个被重写的父类。 注意：例如上面的例子，Test 重写了 grid panel，我在其他类中创建 grid panel 时如果不引用 Test 那么重写仍然是不生效的。只有引用了 Test 重写才会生效 grid panel 才会具有 say 方法。不要问我为什么。 如果你想创建一个单例类，那么你在定义类时用 singleton 属性，如以下代码所示： Ext.define(&apos;Logger&apos;, { singleton: true, log: function(msg) { console.log(msg); } }) ; create 对象你可以使用下列代码来创建一个类的实例： Ext.create(Class,Options); 下列代码创建了一个 ElectricCar 类的实例，并传递一个值(name)： var myCar = Ext.create(&apos;ElectricCar&apos;,{ name: &apos;MyElectricCar&apos; }) ; 如果 Ext.Loader 是开启的， Ext.create 执行时如果 ElectricCar 类不存在将会自动的下载对应的 JS 文件。默认Ext.Loader 是开启的；你可以通过以下方式来关闭它。 Ext.Loader.setConfig({ enabled: true }); 这里你也可以使用 new 关键字来创建一个实例，如以下代码所示；可是如果这个类不存在，使用 new 关键字创建实例并不会自动下载对应的 JS 文件： var myCar = new ElectricCar(&apos;MyElectricCar&apos;); ps：你只需要掌握使用 Ext.create 创建实例就行了，new 关键字可能是兼容 Ext 3.x 的使用方式而继续支持的。new 关键字官方是不推荐用的。 onReady这个函数在页面加载完成后调用： Ext.onReady(function(){ new Ext.Component({ renderTo: document.body, html: &apos;DOM ready!&apos; }); }) ; 大多时候，在你的代码里不会用到 onReady 这个方法，因为 Ext 建议你一个应用就是一个页面(单页式应用)，只有一个页面的话自然没有那么多场景会需要用到。只有在极少数的一些特殊情况，你可能需要用它。这里要强调一点，如果你具有使用 jQuery 的基础，不要把 onReady 方法像 jQuery中的 $( document ).ready() 那样频繁使用。 widget (部件)当定义一个类时，你可以为这个类增加一个便于记忆的别名。例如： Ext.panel.Panel 的别名为 widget.panel。定义别名时，如以下代码所示指定 alias 属性： Ext . define ( ‘Ext.panel.Panel’ , { extend : ‘Ext.container.Container’ , alias : ‘widget.panel’ //这里是定义的别名， } ) ; 你也可以使用 xtype 为这个类给定一个别名。这个 xtype 是非常有用的，当你以指定 xtype的方式应用部件时，并不会创建实例，而是在真正调用展示的时候才会创建这个类的实例。在本章后面介绍 容器和布局 时你将会学到更多关于 xtype 的使用。 Ext.widget 方法是通过类的 xtype 快速创建部件的。 例如，不使用 widget 方法，你可以通过下列代码创建 Ext.panel.Panel 的实例： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo: Ext.getBody(), title: &apos;Panel&apos; }); 反之，通过以下方式快速创建 panel 的实例： Ext.widget(&apos;panel&apos;, { renderTo: Ext.getBody(), title: &apos;Panel&apos; }); 这里 panel 是一个容器，关于 panel 会在后面详细讲解。下面代码的作用相当于与上面： Ext.create(&apos;widget.panel&apos;, { renderTo: Ext.getBody(), title: &apos;Panel&apos; }); 注意： 你阅读此文档的同时，这里面的大部分代码都是可以运行的，你可以选择在你本地设备上或者在 Sencha Fiddle 上执行这些示例代码。你可以访问Sencha Fiddle 并将上面的代码键入到 launch 函数中，运行并查看结果。如果你访问了 https://fiddle.sencha.com 将会看到下列代码： Ext.application({ name : &apos;Fiddle&apos;, launch : function() { Ext.Msg.alert(&apos;Fiddle&apos;, &apos;Welcome to Sencha Fiddle!&apos;); } }) ; 现在，粘贴创建 panel 部件的代码如以下示例，运行并查看结果。复制粘贴时，注意单引号不要写成中文标点单引号： Ext.application({ name : &apos;Fiddle&apos;, launch : function() { Ext.create(&apos;widget.panel&apos;, { renderTo: Ext.getBody(), title: &apos;Panel&apos; }); } }) ; 不是所有的代码都可以这样运行，此外并非所有的示例代码都会有视觉呈现。 getClass如果创建的实例是用 Ext.define 定义的，那么返回这个给定对象的类，否则返回 null： var button = new Ext.Button(); Ext.getClass(button); // returns Ext.Button getClassName通过它的引用或实例返回类名称： Ext.getClassName(Ext.Button); //returns &quot;Ext.Button&quot; Ext.Base这是所有 Ext 类的基础。所有的 Ext 类都继承自 Ext.Base。该类所有的原型和静态成员都会传递给继承它的类。 Ext.Class这是一个低级别的工厂类，用于通过 Ext.ClassManager 定义一个类。所以不应该在你的代码中直接访问；你应该使用 Ext.define 。 Ext.ClassManager它管理所有的类同时处理类反射。通常通过下面几个方法访问： define create widget getClass getClassName 在本章我们已经讨论使用过这些方法。 Ext.Loader用于动态的加载依赖。通常使用 Ext.require 来指定依赖。当你定义一个类时，这样指定组件的依赖列表是一个很好的做法，如以下代码所示： Ext.require([&apos;widget.window&apos;, &apos;layout.border&apos;,&apos;Ext.data.Connection&apos;]); 如果你需要引入一个指定命名空间下所有的 组件/类 时，使用通配符，如以下代码所示： Ext.require([&apos;widget.*&apos;, &apos;layout.*&apos;, &apos;Ext.data.*&apos;); 使用以下语法排除掉不需要的类： Ext.exclude(&apos;Ext.data.*&apos;).require(&apos;*&apos;); 用这种方式，依赖的类是异步加载的。如果在你定义的类中没有指定依赖的类，那么当使用 Ext.Create创建实例时，如果它是未加载的，这时将会同步加载这些类文件。这对性能有一定的影响，所以当你定义类时，使用 Ext.require 指定所需的类总是更好的。 requires 属性加载需要的类时，当前类初始化之前被加载。 uses 属性加载需要的类时，当前类初始化之后被加载。 singleton:true 属性当前类初始化时,该实例是一个单例对象。 注意：定位类的文件路径是基于类名的。例如： MyApp.view.About 类的路径应该是 \\myapp\\view\\ about.js 。 Events(事件) 一个事件可以是一个用户操作，一个 Ajax 调用的响应等等。 Adding listeners(为类添加监听)当你创建对象或者创建以后都可以为这个对象添加监听器。下列示例代码为这个对象添加了一个 单击事件 的监听： Ext.create(&apos;Ext.Button&apos;, { renderTo: Ext.getBody(), listeners: { click: function() { Ext.Msg.alert(&apos;Button clicked!&apos;); } } }) ; 你可以添加多个事件监听，如以下代码示例： Ext.create(&apos;Ext.Button&apos;, { renderTo: Ext.getBody(), listeners: { mouseout: function() { //Do something }, click: function() { // Do something } } }); 你也可以在对象创建之后，使用 on 方法为对象添加事件监听： var button = Ext.create(&apos;Ext.Button&apos;); button.on(&apos;click&apos;, function() { //Do something }) ; 同样的，你也可以使用 on 方法一次添加多个事件的监听，如以下代码示例： var button = Ext.create(&apos;Ext.Button&apos;); button.on({ mouseover: function() { //Do something }, mouseover: function() { //Do something } }) ; Removing listeners (删除事件监听)You can also remove the listeners, but you need the reference to the function;you can’t use the anonymous function. var HandleClick= function() { Ext.Msg.alert(&apos;My button clicked!&apos;); } Ext.create(&apos;Ext.Button&apos;, { listeners: { click: HandleClick } }) ; button.un(&apos;click&apos;, HandleClick); 页面 DOM 元素的事件处理你可以将监听器添加到 DOM 元素，如下所示。 假设在你的 HTML 代码中，有一个 div 元素 id=mydiv ，如以下代码所示： &lt; div id=&quot;mydiv&quot;&gt;&lt;/div &gt; 用下列代码为它添加事件监听： var div = Ext.get(&apos;mydiv&apos;); div.on(&apos;click&apos;, function(e, t, eOpts) { // Do something }); 访问 DOM 有三种方法来访问 DOM 元素： get ， query ，和 select 。 Ext.getget 方法是根据这个 DOM 元素的 ID 检索获取并封装为 Ext.dom.Element 对象： var mydiv = Ext.get(&apos;myDivId&apos;); Ext.query这种方式基于传入的 CSS 选择器 从给定的根节点开始查找。它返回一个匹配选择器的元素( HTMLElement[]/Ext.dom.Element[])数组。如果没有匹配的，返回一个空值的数组对象。 在下面示例中， myCustomComponent.getEl().dom 是传递的根节点。 Ext.query将检索这个节点内的子元素，并返回一个数组包含 CSS class 为 ‘ oddRow ‘ 的的元素： var someNodes = Ext.query(&apos;.oddRow&apos;, myCustomComponent.getEl().dom); Ext.select给出一些 CSS/XPath 选择器，Ext.select 方法返回一个 CompositeElement 类型的对象，代表一个元素的集合。 这个 CompositeElement 对象可以进行过滤，迭代，和对整个集合执行整体操作等等： var rows = Ext.select(&apos;div.row&apos;); ////Matches all divs with class row rows.setWidth(100); // 这是设置所有元素的宽度为 100 你也可以用一行代码，如下所示： Ext.select(&apos;div.row&apos;).setWidth(100); 多重选择器在方法调用时通过指定多个搜索条件可以用来匹配多个元素： Ext.select(&apos;div.row, span.title&apos;); //匹配所有的 class 用 .row 的 div 元素，和匹配所有 class 用 .title 的 span 元素 选择器 根当你使用 select ，它默认取 HTML body 作为根并从默认的 body 开始检索整个 DOM树。你可以通过制定一个根元素来避免这种情况，这样它将只搜索给定的根的子节点。 Ext.get(&apos;myEl&apos;).select(&apos;div.row&apos;); 这儿使用了 ‘myEl’ 作为根节点。这将首先找到 id 为 ‘myEl’ 的元素，然后将在根元素(myEl)下面搜索出 class 为 ‘row’ 的div 标签。 Ext.select(&apos;div.row&apos;, true, &apos;myEl&apos;);// This is equivalent to the previous line. 链式选择器下列的查询方式会匹配 class 为 row 并且 title 属性值为 bar 的 div ，这个 div 属于其父元素的首个子元素： Ext.select(&apos;div.row[title=bar]:first&apos;) Ext.ComponentQuery这允许你用 ID，xtype，和 属性查找一个组件。你可以全局搜索或者指定一个根组件。 下列查询将返回所有的 xtype 为 button 的组件： Ext.ComponentQuery.query(&apos;button&apos;); 得到一个 id 为 foo 的组件，用以下代码： Ext.ComponentQuery.query(&apos;#foo&apos;); 下列代码将返回所有的 xtype 为 button 并且 title 属性值为 my button 的组件： Ext.ComponentQuery.query(&quot;button[title=&apos;my button&apos;]&quot;);; //or parent.query(&apos;textfield[title=my button]&apos;); 你也可以使用嵌套选择器如下：You can also use nested selectors as follows: Ext.ComponentQuery.query(&apos;formpanel numberfield&apos;); // 这里获取 xtype 为 frompanel 下面的 xtype 为 numberfield 的组件 下列代码返回这个 parent 容器内匹配传递进来的选择器的第一个直接子组件，如果没有匹配上，返回 null 。 parent.child(&apos;button[itemId=save]&apos;); 同样的，你也可以使用其他的方法，例如 nextNode , up , down , previousSibling 等等。 组件，容器，和布局Ext JS 提供了一组丰富的组件和布局，这使在 Ext JS 中开发 UI 变得超级简单，甚至非专业 UI 开发人员也能够轻易的使用。 组件从简单的组件说起，例如 button 和 label ，到复杂的组件，例如 Tree Panel，Grids 等等，Ext JS有大量的内置组件。所有的组件都派生自 Ext.Component 类，它提供支持创建，重绘，渲染和处理组件。 所有的组件都有一个属性叫做 xtype。它是非常有用的，它用在当你不想马上实例化这个组件时，而是想让这个组件在实际被应用时才创建，就是我们俗称的懒加载。 容器 容器是一个特殊的组件类型，它能够持有其他组件。在 Ext JS 中 Ext.container.Container 类是所有的容器的基础类。 Ext.toolbar.Toolbar , Ext.panel.Panel , 和 Ext.Editor是一些内置组件。这些组件都是可以包含其他组件。而像 Ext.button.Button 类就不是派生自 Ext.container.Container，所以它不能够包含其他组件。 一个典型的 Ext JS 应用包含一组嵌套的组件。看下面这个例子并思考： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo:Ext.getBody(), width:700, height:400, items:[{ xtype: &apos;panel&apos;, title: &apos;Panel 1&apos;, },{ xtype: &apos;panel&apos;, title: &apos;Panel 2&apos;, height: 200, items: [{ xtype: &apos;button&apos;, text: &apos;Click Me&apos; }] },{ xtype: &apos;panel&apos;, title: &apos;Panel 3&apos;, width: 150, height: 100 }] }); 在前面的代码中，这是嵌套的组件，结构如下图所示： 上面的代码运行后将输出类似以下截图： 布局布局定义了包含的组件是如何定位的以及设定组件的尺寸大小。每一个容器都有一个布局。默认布局是 auto 。这将不会为子组件指定任何关于位置和大小的规则。 在上面的图中，你可能已经注意到这些子组件只是一个接一个嵌套在父级容器中。这是在代码中因为我们还没有为这些组件制定任何布局，默认情况下使用的是 auto布局。 现在，让我们在相同的代码里使用一些布局。下列示例中，我们将使用 column 布局和 center 布局。 当你使用 column 布局，你可以指定 columnWidth 。所有的列的 columnWidth 的值的总和必须等于 1。你也可以为一些列指定固定宽度，如以下代码所示。这里，Panel3 取了一个 150 的固定宽度，然后剩下的两列按照 columnWidth的值分配剩下的宽度： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo:Ext.getBody(), width:700, height:400, layout:&apos;column&apos;, items: [{ xtype: &apos;panel&apos;, title: &apos;Panel 1&apos;, columnWidth: 0.4, height: 400, },{ xtype: &apos;panel&apos;, title: &apos;Panel 2&apos;, columnWidth: 0.6, layout: &apos;center&apos;, height: 400, items: [{ xtype: &apos;button&apos;, text: &apos;Click Me&apos; }] },{ xtype: &apos;panel&apos;, title: &apos;Panel 3&apos;, width: 150, height: 400 }] }); 以上代码输出为： updateLayoutupdateLayout 是 Ext.container.Container对象里的一个方法。这可以用来根据布局规则重新定位子组件。例如你修改了布局方式，需要动态的更新布局时。 suspendLayout大多数时候你不会用到这个 updateLayout 方法，然而有些时候你必须调用它。 这个 updateLayout 方法是在你重绘和当你添加或删除了一个组件时自动调用。有时候你可能需要它暂停一下，不是马上就调用，特别是当你添加或删除多个子组件时。所以在这种情况下，你可以设置 suspendLayout 属性为 true ，一旦你完成添加或删除组件的操作，你可以设置suspendLayout 为 false 并在你的代码中手动调用 updateLayout 方法。 同样的如果你想对整个框架停止更新布局，你可以调用 Ext.suspendLayouts() ，然后在你的操作完成后你可以通过调用Ext.resumeLayouts(true) 恢复它。 以下是 Ext JS 中可用的布局： absolute accordion anchor border card center column fit hbox table vbox absolute 绝对布局这个布局使用 x 和 y 属性来指定组件的绝对定位： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo:Ext.getBody(), width:700, height:400, layout:&apos;absolute&apos;, items: [{ xtype: &apos;panel&apos;, title: &apos;Panel 1&apos;, x: 12, y: 20, height: 250 },{ xtype: &apos;panel&apos;, title: &apos;Panel 2&apos;, x: 200, y: 150, height: 200 },{ xtype: &apos;panel&apos;, title: &apos;Panel 3&apos;, x: 400, y: 250, width: 150, height: 100 }] }); 这里所示的输出，你可以重叠组件因为他们用绝对位置定位的： accordion 手风琴(可折叠)布局这个布局展示了在一个时间里只有一个内置的可支持折叠和展开的子级 panel 。瞧一下以下示例： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo: Ext.getBody(), width: 700, height: 400, layout: &apos;accordion&apos;, items: [{ title: &apos;Item 1&apos;, html: &apos;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum&apos; },{ title: &apos;Item 2&apos;, html: &apos;some content here&apos; },{ title: &apos;Item 3&apos;, html: &apos;empty&apos; }] }); 这里显示的输出，这个 Item 1 是展开的，而其他的 panel 是折叠的： anchor 锚点布局这个布局使你能够指定子级组件的大小，而这是相对于布局容器的。首先容器根据指定的锚点规则调整然后所有的子级组件再作调整： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo: Ext.getBody(), width: 700, height: 400, layout: &apos;anchor&apos;, items: [{ title: &apos;Item 1&apos;, html: &apos;Item 1&apos;, anchor: &apos;50%&apos; },{ title: &apos;Item 2&apos;, html: &apos;Item 2&apos;, anchor: &apos;-20 -200&apos; },{ title: &apos;Item 3&apos;, html: &apos;Item 3&apos;, anchor: &apos;-200&apos; }] }); 输入如以下截图： #### border 布局这个布局允许你为子组件指定一个区域位置，例如 center，north，south，west 和 east。当你使用 border布局时，在其内的组件必须有一个指定区域为 center，如下列代码所示： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo: Ext.getBody(), width: 700, height: 400, layout: &apos;border&apos;, items: [{ title: &apos;Item 1&apos;, html: &apos;Item 1&apos;, region: &apos;center&apos; },{ title: &apos;Item 2&apos;, html: &apos;Item 2&apos;, region: &apos;east&apos;, width: 200 },{ title: &apos;Item 3&apos;, html: &apos;Item 3&apos;, region: &apos;south&apos;, height: 100 }] }) ; 以上代码输出类似下列视图： card 卡片布局在此布局中，只有一个子组件是可见的，这个组件基本上充满整个容器。卡片布局一般应用在向导或者 tabs： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo: Ext.getBody(), width: 700, height: 400, layout: &apos;card&apos;, defaultListenerScope: true, bbar: [&apos;-&gt;&apos;,{ itemId: &apos;btn-prev&apos;, text: &apos;Previous&apos;, handler: &apos;showPrevious&apos;, disabled: true },{ itemId: &apos;btn-next&apos;, text: &apos;Next&apos;, handler: &apos;showNext&apos; }], items: [{ index: 0, title: &apos;Item 1&apos;, html: &apos;Item 1&apos; },{ index: 1, title: &apos;Item 2&apos;, html: &apos;Item 2&apos; },{ index:2, title: &apos;Item 3&apos;, html: &apos;Item 3&apos; }], showNext: function () { this.navigate(1); }, showPrevious: function () { this.navigate(-1); }, navigate: function (incr) { var layout = this.getLayout(); var index = layout.activeItem.index + incr; layout.setActiveItem(index); this.down(&apos;#btn-prev&apos;).setDisabled(index===0); this.down(&apos;#btn-next&apos;).setDisabled(index===2); } }); 卡片布局的输出。当你点击 next 按钮，将会显示 Item 2 面板： center 中心布局这种布局，容器的子组件在中间。在本章中开始介绍布局的部分，我们已经有一个例子了。 column 列布局用此布局，你可以将容器划分为指定数量的列并指定每列所占的大小。这个例子也在本章开始介绍布局的部分中可以找到。 fit 适配布局在此布局中，子组件将会自适应容器的尺寸。如下： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo: Ext.getBody(), width: 700, height: 400, layout: &apos;fit&apos;, bodyPadding: 20, items: [{ title: &apos;Item 1&apos;, html: &apos;Fills the container&apos;, }] }); 下列截图展示以上代码的输出。注意：Item 1 组件与父级容器之间的空隙是我们指定了 bodyPadding 属性： hbox 布局这种布局与 column 布局几乎是一样的，但是这种布局允许你拉伸列的高度。这里使用 flex 选项为子组件设置水平的相对值： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo: Ext.getBody(), width: 700, height: 400, layout:{ type: &apos;hbox&apos;, pack: &apos;start&apos;, align: &apos;stretch&apos;, }, items: [{ title: &apos;Item 1&apos;, html: &apos;Item 1&apos;, flex: 1 },{ title: &apos;Item 2&apos;, html: &apos;Item 2&apos;, width: 100 },{ title: &apos;Item 3&apos;, html: &apos;Item 3&apos;, flex: 2 }] }); 上面代码输出： table 表格布局这个布局允许你渲染一个表格出来。你可以指定列数和行数，使用 rowspan 和 colspan 创建复杂布局： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo: Ext.getBody(), width: 700, height: 400, layout:{ type: &apos;table&apos;, columns: 3, tableAttrs: { style: { width: &apos;100%&apos; } } }, items: [{ rowspan: 3, title: &apos;Item 1&apos;, html: &apos;Item 1&apos; },{ title: &apos;Item 2&apos;, html: &apos;Item 2&apos; },{ title: &apos;Item 3&apos;, rowspan: 2, html: &apos;Item 3&apos; },{ title: &apos;Item 4&apos;, html: &apos;Item 4&apos; },{ title: &apos;Item 5&apos;, html: &apos;Item 5&apos; },{ title: &apos;Item 6&apos;, html: &apos;Item 6&apos; },{ title: &apos;Item 7&apos;, html: &apos;Item 7&apos; }] }); 以下截图所示为前面 table 布局代码的输出结果： VBox 布局这个布局内，子组件是垂直向下一个接一个排列。看一下以下的示例代码： Ext.create(&apos;Ext.panel.Panel&apos;, { renderTo: Ext.getBody(), width: 700, height: 400, layout:{ type: &apos;vbox&apos;, pack: &apos;start&apos;, align: &apos;stretch&apos;, }, items: [{ title: &apos;Item 1&apos;, html: &apos;Item 1&apos;, flex: 1 },{ title: &apos;Item 2&apos;, html: &apos;Item 2&apos;, height: 100 },{ title: &apos;Item 3&apos;, html: &apos;Item 3&apos;, flex: 2 }] }); 这段代码所示的输出： 总结在本章中，我们了解学习了在 Ext JS 中的基础类和这些类中常用的方法，你还学习了如何创建和扩展一个类。还有如何使用 事件 和 查询元素及组件的功能。 在下一章，我们将会看一看许多有用的组件，例如 buttons ，menus ，toolbars 等等。我们也将根据所学创建一个小型的计算器应用。","categories":[{"name":"ExtJs","slug":"ExtJs","permalink":"https://www.itchina.top/categories/ExtJs/"}],"tags":[{"name":"ext","slug":"ext","permalink":"https://www.itchina.top/tags/ext/"},{"name":"extjs","slug":"extjs","permalink":"https://www.itchina.top/tags/extjs/"},{"name":"javascript","slug":"javascript","permalink":"https://www.itchina.top/tags/javascript/"}]},{"title":"Ext JS 6学习文档–第1章–ExtJS入门指南","slug":"Ext JS 6学习文档–第1章–ExtJS入门指南","date":"2018-04-19T16:34:21.417Z","updated":"2018-04-19T16:29:58.004Z","comments":true,"path":"2018/04/20/Ext JS 6学习文档–第1章–ExtJS入门指南/","link":"","permalink":"https://www.itchina.top/2018/04/20/Ext JS 6学习文档–第1章–ExtJS入门指南/","excerpt":"","text":"## Ext JS 入门指南 前言本来我是打算自己写一个系列的 ExtJS 6 学习笔记的，因为 ExtJS 6 目前的中文学习资料还很少。google 搜索资料时找到了一本国外牛人写的关于ExtJS 6 的电子书 [Ext JS 6 By Example]。这份资料在 PACKT 上卖 35.99 刀的，当然了万能的 google还是帮我下载到了 PDF文档。大概看了一下，讲的很详细，例子也比较简单，容易理解，现我准备利用工作之余翻译这份文档，为自己学习加深理解，也希望能帮助更多的人学习。 翻译时，我并不会 100%按照原文照搬，而是可能加上我的理解和我自己的看法，所谓求其上而得其中，求其中而得其下，如果你看到这个文章，也不要以此作为标准，保持你的意见和思想。 正文现在如果你打算学习 Ext JS 了，那你应该告别使用普通的 JavaScript 了。JavaScript 是一个伟大，卓越的语言，但是随着 web应用越来越大，我们的代码也越来越难以维护，这是十分困难并耗费时间的。 普通的 JavaScript 非常的灵活，这有很多优点，同时这样也会带来很多问题，随着你的应用越来越大，参与的人就越来越多，普通的 JavaScript 让10 个人来写，就会有 10 种不同的风格，往往有些代码只有写代码的当事人知道为什么这么写，如果这个人不再负责这个功能，就会成为后来人的坑。所以在代码上的约束和规范是十分有必要的。这也是为什么我一直喜欢 ExtJS 的原因，ExtJS 写起来代码就像 Java 一样，非常严谨，非常面向对象。缺点就是在前端 JS库中属于比较重量级，学习曲线相对陡峭。 当涉及到 JavaScript 框架时，有客户端的 JavaScript 框架以及服务端的 JavaScript 框架。Ext JS 就是一个客户端的JavaScript 框架。 在本章基本上是讲述关于如何使用我们所需的工具来设置开发环境以及Ext JS 的基本介绍。在这一章，我们主要涉及以下几点 ： 使用 Ext JS 的优点 对 Ext JS 的介绍 安装设置 Sencha Cmd 和 Ext JS 使用 SenchaCmd 搭建 Ext JS 应用 Ext JS 应用的体系结构 探索 Sencha Cmd 命令 如何调试 Ext JS 应用 使用开发工具 IDE 为什么使用 Ext JS?既然推荐你使用，自然要告诉你使用 Ext JS 都有哪些看得见的好处。现在让我们瞧一瞧，在你的应用里使用 Ext JS 相较普通 JavaScript有哪些优点。 跨浏览器支持只要你做 web 开发，你一定解决过浏览器兼容问题，这有多么消耗时间和影响工作进度你一定有体会，你可能会花上几小时甚至几天来解决跨浏览器bug。你为什么不把这些时间用来关注你的业务功能呢？相反，如果使用 Ext JS 这个 JavaScript框架，这种事情将由它去考虑，而你可以专注于业务功能。 丰富的 UI 组件Ext JS 提供了大量丰富的 UI 控件，如 data grid ，tab panels,tree 控件，日期选择工具，图表 等等，Ext JS作为一站式的前端框架，有很多优秀且实用的控件，尤其是表格对复杂数据展示的支持是其他的 JavaScript 框架不具备的， 这些都能大量节省你的开发时间。 双向数据绑定双向数据绑定意味着当视图 view 的数据发生变化，你的模型 model 将自动更新。同样的，当你的应用更新这个模型 model，这个数据也将自动传递到view。 就拿编辑页面来举栗。 当这个页面(view)加载，这时已经渲染了来自模型(model) 的数据到HTML，并且当用户在页面(view)上更新这个数据，这时候你需要更新你的模型(model)，但如果你使用 Ext JS 将不需要你自己去做这些编程。 JavaScript 的架构模式(MVC/MVVM)随着越来越多的代码转移到客户端，维护客户端的 JavaScript 代码变的非常困难。通过在客户端使用 MVC ( Model ViewController )/ MVVM ( Model View, View Model ) 使维护客户端的 JavaScript变得更容易，并提高了生产效率。关于 MVC 和 MVVM 架构模式会在本章后面解释。 简化复杂的操作想象一下使用纯 JavaScript 写一个 AJAX 调用，你需要考虑确保支持所有浏览器，这你可以看一下任何的 JavaScript 框架里进行 AJAX调用的方法的源码。想象一下使用纯 JavaScript 创建一个复杂的控件，例如 grid ，分页，排序，过滤，分组，可编辑字段等等。Ext JS不需要你自己来做这些工作。这里其实是废话，没有谁闲的蛋疼重复造轮子。但是其他框架一定没有 Ext JS 这种一站式的支持。 访问 DOM 变得容易普通的纯 JavaScript 里，你可以访问 DOM，但是这有点复杂。使用 Ext JS 就会很容易查找 DOM。当然使用 jquery的人肯定不信服，还能比 jquery 查找 DOM 更方便吗？我也常用 jquery ，这里我可以说 Ext JS 相较 jquery 查找 DOM不逞多让。 客户端路由在 web 应用里，URL 映射到 web 页面的路由方式背后有一系列的逻辑。路由可以在服务端也可以在客户端。通常客户端路由都是用单页式应用实现的。Single-Page Application ( SPA )。 支持无障碍访问无障碍访问特性意味着这个应用程序的内容必须是可以方便的让视力受损的人借助辅助设备访问(例如屏幕阅读器)。而开发一个应用程序能够很好的支持无障碍特性是非常困难的。这里 Ext JS 已经为你做了。 在美国，如果你开发的软件供联邦和州政府职员使用，在绝大多数情况下，你需要确保你的程序是支持无障碍访问特性的。这一点，很少 JavaScript框架能对无障碍访问特性有较好的支持。而 Ext JS 提供了完美的无障碍访问支持。 World Wide Web Consortium ( W3C )已经创立了一个名为 WAI-ARIA ( Web AccessibilityInitiative – Accessible Rich Internet Applications ) 的技术规范。 WAI-ARIA, 是Web Accessibility Initiative – Accessible Rich Internet Applications 的缩写，指无障碍网页应用技术。她主要解决的一个问题:让残障人士能无障碍地访问网页上的动态内容。 这种规范方式使残疾人也能无障碍访问 web 应用。 Ext JS 对此具有良好的支持，并且所有的 控件/部件 都可以支持，不需要你做任何额外的编码。 ### 介绍 Ext JSExt JS 作为一个一站式的开发富 UI 应用的框架，它提供支持 MVC,MVVM, 双向绑定，跨浏览器兼容，路由功能，一组广泛的丰富的 UI组件，图表等等。对于框架中所有的 API ， Ext JS 还拥有一个非常优秀的文档。Ext JS 最初的建立是由 Jack Slocum 开发的，做为YUI 的一个附加扩展库使用，现在则是成为 Sencha 公司的产品。 在 Ext JS 中，你写的代码基本上就是 JavaScript，因为你不需要写 HTML。Ext JS 附带一组庞大的丰富的 UI组件，这在你的开发过程中会节约你相当多的时间。 本书中，所有的样例代码和示例项目代码将使用最新的 Ext JS Version 6，但是大多数代码是兼容以前的 Ext JS 5 的。Ext JS 5 和Ext JS 6 的大多数概念是相同的。所以如果你在使用 Ext JS 5，你仍然可以从这本书中受益不少。但是请记住这本书的代码将不会运行在 Ext JS5 并且可能需要做一些小修改才能运行在 Ext JS 5。在 Ext JS 6 中最重要的变化是它合并了两个框架：Ext JS 和 Sencha Touch合并成为了一个框架。Ext JS 6 还带来了一个新的 SASS 编译器叫 Fashion，以及3D 图表的改进等等。 要明白为什么会发生合并 Ext JS 和 Sencha Touch , 我们需要回顾一下。 Sencha Touch 是一个独立的产品，专用于为移动设备和平板电脑创建可支持触摸的应用，它利用硬件加速技术为移动设备提供高性能的 UI 组件。 Ext JS 4 和 Ext JS 5 主要用于开发桌面级的 web 应用。 如果你已经在 Ext JS 5 或 Ext JS 4 创建了用于桌面的 web应用，这仍然可以在移动设备和平板电脑上运行，但是它将不支持一些特定的触摸功能，并且不能利用硬件加速为移动设备提供高性能 UI组件。所以为了更好的支持移动设备，Sencha 开发人员被告知要使用 Sencha Touch。 使用 Sencha Touch 有很多优势。 在 Sencha Touch编写的应用将具备移动平台本地应用一样的外观，并且性能将更好。然而许多开发人员有一个抱怨,因为他们被迫保持两套相同的应用程序的代码库。 尽管 Sencha Touch 和 Ext JS 有很多差异是完全不同的产品，但他们的概念和思想的框架非常相似，如果你会用 Ext JS,那么学习Sencha Touch 也非常容易。 长期以来,许多 Ext JS 和 Sencha Touch 用户问为什么不把两个产品合二为一使 Ext JS 能够带触摸功能。在 Ext JS 6中,Sencha 决定将这两个产品合并到一个单一的产品。 现在，在 Ext JS 6 你仍然可以维护一套独立的代码。而要 Sencha Touch 和 Ext JS 6两者兼存，有些视图的代码你可能需要单独的编写，但是大部分代码都是共享的。 在 Ext JS 6 合并后将两者通用的代码做为核心(两者公用一个核心)，并且引入了一个 toolkit(工具箱) 的概念。toolkit是一个可视化组件的包，例如 button，panel 等等。Ext JS 6 有两个工具包：classic(古典) 和 modern(现代)。原来的 ExtJS 的可视化组件放在 classic 工具包，原来的 Sencha Touch 的可视化组件则放在 modern 工具包。 在 Ext JS 6 中选择你想使用的 toolkit(工具包)很简单，如果你正在开发的程序只是针对移动设备的，你可以选择modern，如果你只用于桌面那么你可以选择 classic。默认则是通用的，通用的应用你在桌面端访问 Ext JS 6 应用，就会自动展现 classic风格，如果用移动设备或平板电脑访问则自动展现 modern 风格。 通用应用如果你的应用要同时支持桌面和移动设备，在 Ext JS 6你可以创建一个通用的应用，这时候将会同时应用两个工具包。你可以添加以下的构建配置(这个配置在程序根目录 app.json配置文件中，详细的后面会讲到)，来指定构建使用的工具包和主题： &quot;builds&quot;: { //这里就很简单了，如果你只想用 classic 那么就注释 modern 的配置即可。 &quot;classic&quot;: { &quot;toolkit&quot;: &quot;classic&quot;, &quot;theme&quot;: &quot;theme-triton&quot; }, &quot;modern&quot;: { &quot;toolkit&quot;: &quot;modern&quot;, &quot;theme&quot;: &quot;theme-neptune&quot; } } 这样做的大概路子就是，在 Ext JS 这个框架里用这两套工具包分别对应 桌面 和 移动设备。程序在构建过程中，会构建两套 UI界面出来，而不是我们平时那种响应式的应用，响应式是一套 UI自动根据不同设备改变布局。实际上在企业开发中，甚至互联网开发中，往往都是独立再开发一套支持移动设备的前端 UI，而 Ext JS 6将此合并我认为是非常好的，这样你桌面和移动端都有一套标准，而且很多逻辑可以共享复用，不同的 view 写在独立的工具包里。维护起来也很方便。 如果你是一个 Ext JS 新手，看到这里肯定非常困惑，不过你现在不用担心，这些在后面都会有我们的样例代码来说明，会让你有更深的理解。 Ext JS 6 附带了两个主题包， classic 和 modern 主题包，这两个主题包里分别有各自支持的几种主题。 在 Ext JS 中的一些特定主题，提供了在 Windows，Android，iPhone等设备上类似原生应用的外观。这些你将在第八章(主题和响应设计)学习。 设置 Ext JS 开发环境你需要安装一个叫 Sencha Cmd 的工具，这会让你的 Ext JS 应用开发变得简单。它可用于Windows、Mac 和 Linux。 Sencha Cmd 并不是开发 Ext JS 应用必须用的，但是它会让你的工作非常轻松，所以这里强烈推荐使用 Sencha Cmd。 Sencha CmdSencha Cmd 是在 sencha 产品下做开发时使用的命令行工具，例如开发 Ext JS ,Sencha Touch应用时都可以用。它通过许多的自动化任务帮助你提高生产力。它包含以下功能，包管理，JS 编译器，构建脚本，主题等等。 在安装 Sencha Cmd 之前，你需要安装 JRE 环境，如果你使用的是 Sencha Cmd 5，那么你还需要安装 Ruby。这里如何安装 JRE 或JDK，还是也翻译一下，因为 Sencha Cmd 使用的是 apache ant 作为构建工具，所以需要安装 JRE 环境。而在 Sencha Cmd 5编译 SASS 时则需要使用 Ruby，上面说过 Ext JS 6 使用 fashion 编译 SASS 了，下载最新的 Sencha Cmd 6则不需要安装 Ruby了。 Java 运行时环境 (JRE)在命令行窗口输入以下命令检查 java 是否能正常运行在你的设备上： java -version 如果你已经在你的设备上安装了 java，那么你应该看到类似下面的代码；否则请下载安装 JRE 或 JDK： java version “1.8.0_25” Java(TM) SE Runtime Environment (build 1.8.0_25-b17) Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode) 这一步报错的话，检查一下你是否配置了 java 环境变量，不知道怎么配置请自行搜索。 Ruby注意，如果你使用 Sencha Cmd 6 就不需要安装 Ruby，但是如果你正在使用 Sencha Cmd 5，那还是要安装 Ruby的。输入以下命令，检查 Ruby 是否安装成功: ruby --version 如果已经安装完成，应该看到类似下面的代码；否则请下载安装 Ruby： ruby –version ruby 2.0.0p481 (2014-05-08 revision 45883) [universal.x86_64-darwin14] Ruby 也是需要配置环境变量的，这里不再介绍方法，不会的自行搜索。 安装 Sencha Cmd现在从 Sencha 官网上下载并安装 Sencha Cmd 。安装完成后在命令行窗口输入以下命令检查是否正常运行(同样需要配置环境变量)： sencha which 正常情况下应该显示类似以下的代码： Sencha Cmd v6.0.0.92 /bin/Sencha/Cmd/6.0.0.92/ 如果报错，你应该配置环境变量，在 Mac 电脑上运行以下命令添加安装路径到 PATH 变量： export PATH=~/bin/Sencha/Cmd/6.0.0.92:$PATH 在 Windows，运行以下命令添加环境变量(这一步你其实可以略过的，我想能看这篇文章的人都知道怎么做)： set PATH=%PATH%;C:\\Sencha\\Cmd\\6.0.0.92 用 Sencha Cmd 生成第一个 Ext JS 应用打开命令行窗口键入以下命令： sencha generate app --ext MyApp ./myapp 运行上面的命令将会创建名为 MyApp 的 Ext JS 应用，应用所有的文件都放在当前目录下名为 myapp 的文件夹。 注意，上面的命令生成的 Ext JS 应用代码，包含两个工具包：classic 和modern。因为你不明确指定需要用那个工具包的时候，默认创建的就是通用的应用。如果你需要指定使用 classic 或者 modern 工具包。那么用–modern 或者 –classic 参数，如以下命令所示： sencha generate app --ext --modern MyApp ./myapp 当你第一次运行这个命令时，这应该会自动下载 Ext JS 6。如果没有自动下载，那你需要手动的取下载 Ext JS 6，这里贴出来 GPL 协议的 ExtJS 6 官网下载地址 http://cdn.sencha.com/ext/gpl/ext-6.0.0-gpl.zip 这里下载后解压，这时候生成 Ext JS应用时就可以使用以下命令以指定 SDK 的形式生成了： sencha -sdk /path/to/sdk generate app MyApp /path/to/myapp Sencha Cmd 支持 Ext JS 4.1.1a 以及更高版本，支持 Sencha Touch 2.1 以及更高版本。在你的电脑里可以有多个版本的SDK 。 上面的命令是基于一个特定的 Sencha SDK 来生成的 Ext JS 应用。 下面的例子，在目录 /projects/extjs/myapp 下生成名为 MyApp 的 Ext JS 应用： sencha -sdk /bin/Sencha/ext/6.0.0/ generate app MyApp /projects/extjs/myapp OK，现在可以查看已经创建的应用了，运行以下命令： cd /projects/extjs/myapp sencha app watch 这时会运行一些构建相关的任务，最终你将在命令行窗口看到类似下图的界面： 上面的命令监控了任意代码修改保存后，都会在浏览器刷新时反应最新的改动。 在浏览器输入默认 URL ( http://localhost:1842) ，如图所示，看到类似以下界面： 默认当你使用电脑访问 URL ( http://localhost:1842 )，应用会自动检测并为你展示 classic 工具包的UI。如果访问是来自一个移动端浏览器，它将展示 modern 工具包。如何在电脑上看 modern 风格的应用呢？附加参数 (http://localhost:1842?profile=modern )，你将看到以下截图： MyApp 应用的整体目录结构如下图。我们瞧一瞧这个实例程序都有哪些比较重要的文件。 应用包含了 model , store , 和 application.js 。你就把 store 看成是一个 model实例的集合。store 是为你的程序功能提供并加载数据用的，你可以认为 store 就是一个数据源，它支持排序，过滤，分页等等，经常用到 store 的就是grid 组件。这些都会在后面一一讲到。 在下面截图中,有 classci 和 modern 这两个文件夹。这两个文件夹包含使用不同工具包时写的 view(视图)代码，例如你 classic 风格的view(视图) 就应该写在 classic 目录下，modern 风格的 view(视图) 就应该写在 modern 目录下。 下图为 classic 和 modern 文件夹下的结构。classic 和 modern 都包含 src 目录，而你的 view(视图) 就应该写在src 里面。 而这个 main.scss 文件是样式文件，在 classic 和 modern 工具包都存在，对应桌面和移动设备的样式。 还有就是在根目录也有一个 sass 文件夹，那里是放置应用所有设备共用的样式。 SASS ( Syntactically Awesome Stylesheets )是一种样式语言。Ext JS 中大量的用到SASS。你将在第8章(主题和响应设计)学习到更多关于样式的知识。 注意 classic 和 modern 目录，这里面都不是 Ext JS 框架的工具包源码，这里是程序的代码，classic 和 modern两个工具包的源码在根目录 ext 文件夹里： 在下一节，我将给你介绍 MVC ，并且会在 MyApp 这个应用下使用 Sencha Cmd 生成这些 MVC 相关的文件以及学习它。 应用的体系结构Ext JS 提供支持两种应用架构 MVC 和 MVVM。 Model(模型)这代表着数据层。model 保存的数据可以包含数据验证和逻辑，model 经常用于 store 中。上文已经讲过，store 就是多个 model 的集合。 View(视图)这一层就是用户界面。包含有 button，form，和 message box 等等组件。 Controller(控制器)控制器处理 view(视图)相关的逻辑，例如 view 的 event(事件)处理，还有任何程序相关逻辑都可以写在这里。 View model (视图模型)view model 封装了 view(视图)所需要的展示逻辑，绑定数据到 view 并且每当数据改变时处理更新。 我们看一下通过 Sencha Cmd 创建的 view，controller，view model 相关的文件。 如果你打开 app.js ，你将看到下列代码，这是 Ext JS 应用的启动代码： Ext.application({ name : &apos;MyApp&apos;, extend : &apos;MyApp.Application&apos;, requires : [ &apos;MyApp.view.main.Main&apos; ], mainView : &apos;MyApp.view.main.Main&apos; }); 在上面代码中， name 定义了程序的名称， extend 表示继承 MyApp.Application 类，这个类文件定义在 app文件夹下名为 Application.js : extend: ‘MyApp.Application’ requires 部分指定了这个类需要的类列表。这样在 requires 里面添加的类在当前类中首次实例化时，会去先加载它，你可以把requires 的作用理解为 java 中的 import 关键字。 mainView 指定的是要初始化创建的 view(视图)。 继续，现在查看 app 文件夹，你将看到文件 Application.js ，和 model ， view ， store 等等。 下面是 Application.js 文件里的代码： Ext.define(&apos;MyApp.Application&apos;, { extend: &apos;Ext.app.Application&apos;, name: &apos;MyApp&apos;, stores: [ // TODO: add global / shared stores here ], launch: function () { // TODO - Launch the application } }); 这里你可以看到 MyApp.Application 继承自 Ext.app.Application 。这个 launch 函数是在Ext.app.Application 类里。这个函数将会在页面加载完成后调用。 这个 stores 是指定需要的 store 的，这里并没有用到，你将在后面的章节中学习到关于 store 的更详细的知识。 视图模型 – MainModel.js现在看一下 \\app\\view\\main\\ 目录下的 MainModel.js 文件。这个类是 Main 视图的 viewmodel(视图模型)。这个视图模型继承自 Ext.app. ViewModel ，代码如下所示： Ext.define(&apos;MyApp.view.main.MainModel&apos;,{ extend : &apos;Ext.app.ViewModel&apos;, alias : &apos;viewmodel.main&apos;, data : { name : &apos;MyApp&apos;, loremIpsum : &apos;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&apos; } }); 控制器 – MainController.js这个类是 Main 视图的控制器。在下列代码中你可以看到 onItemSelected 函数，这个函数将在视图里的 grid中选中某一项时触发调用。这是什么原理呢？后面会讲到的。 Ext.define(&apos;MyApp.view.main.MainController&apos;, { extend : &apos;Ext.app.ViewController&apos;, alias : &apos;controller.main&apos;, onItemSelected : function(sender, record) { Ext.Msg.confirm(&apos;Confirm&apos;, &apos;Are you sure?&apos;, &apos;onConfirm&apos;, this); }, onConfirm : function(choice) { if (choice === &apos;yes&apos;) { // } } }); 我们可以看到 extend 继承了 Ext.app.ViewController 这个类。Ext JS 中有两种类型的控制器：Ext.app.ViewController 和 Ext.app.Controller 。 在后面的章节中你将会学习到这两种控制器有何区别。 视图 – Main.js如果你用的是 Sencha Cmd 5,，并且你生成应用时执行了使用哪种 toolkits 工具包，是 –modern 或 –classic，如果是这样那么 Main.js 文件就在 \\app\\view\\main 文件夹下面。但是如果你用 Sencha Cmd 6生成的是通用的应用，那么将会有两个 Main.js 文件，分别在 \\modern\\src\\view\\main\\ 和\\classic\\src\\view\\main\\ 目录下面。 在查看这两个文件的内容之前，我先通过这两个不同路径的 Main.js 文件来解释一下。在本章的上文中，你已经知道为什么 Ext JS 6 合并了 ExtJS 和 Sencha Touch 为一个框架。这两个框架合并后共用一个核心，剩下的代码则分为两部分 classic 和 modern。传统的 Ext JS代码移动到 classic 工具包，而 modern 的代码支持触摸和 HTML5 在 modern工具包。所以这里需要两个工具包，程序会根据访问设备自动使用对应的工具包里的 UI 类(view)。 应用分两个工具包并共享核心资源和逻辑，这称为通用应用。 现在我们看一下在 modern 下的 Main.js 文件： Ext.define(&apos;MyApp.view.main.Main&apos;, { extend : &apos;Ext.tab.Panel&apos;, xtype : &apos;app-main&apos;, requires : [ &apos;Ext.MessageBox&apos;, &apos;MyApp.view.main.MainController&apos;, &apos;MyApp.view.main.MainModel&apos;, &apos;MyApp.view.main.List&apos; ], controller : &apos;main&apos;, viewModel : &apos;main&apos;, defaults : { styleHtmlContent : true }, tabBarPosition : &apos;bottom&apos;, items : [{ title : &apos;Home&apos;, iconCls : &apos;fa-home&apos;, layout : &apos;fit&apos;, items : [ { xtype : &apos;mainlist&apos; } ] }, { title : &apos;Users&apos;, iconCls : &apos;fa-user&apos;, bind : { html : &apos;{loremIpsum}&apos; } }, { title : &apos;Groups&apos;, iconCls : &apos;fa-users&apos;, bind : { html : &apos;{loremIpsum}&apos; } }, { title : &apos;Settings&apos;, iconCls : &apos;fa-cog&apos;, bind : { html : &apos;{loremIpsum}&apos; } }] }); 这个 Main 视图是一个 tab panel，因为它继承了 Ext.tab.Panel 。这个类有属性 controller ，viewmodel ， requires 配置了需要依赖的类。创建了四个 tab 页(items属性)，并且绑定了数据 ViewModel 里的loremIpsum 属性。你将会在后续章节中了解关于此更多的详细信息。 接着看一下在 \\classic\\src\\view\\main\\ 下的 Main.js 文件内容： Ext.define(&apos;NewApp.view.main.Main&apos;, { extend : &apos;Ext.tab.Panel&apos;, xtype : &apos;app-main&apos;, requires : [ &apos;Ext.plugin.Viewport&apos;, &apos;Ext.window.MessageBox&apos;, &apos;NewApp.view.main.MainController&apos;, &apos;NewApp.view.main.MainModel&apos;, &apos;NewApp.view.main.List&apos; ], controller : &apos;main&apos;, viewModel : &apos;main&apos;, ui : &apos;navigation&apos;, tabBarHeaderPosition : 1, titleRotation : 0, tabRotation : 0, header : { layout : { align : &apos;stretchmax&apos; }, title : { bind : { text : &apos;{name}&apos; }, flex : 0 }, iconCls : &apos;fa-th-list&apos; }, tabBar : { flex : 1, layout : { align : &apos;stretch&apos;, overflowHandler : &apos;none&apos; } }, responsiveConfig : { tall : { headerPosition : &apos;top&apos; }, wide : { headerPosition : &apos;left&apos; } }, defaults : { bodyPadding : 20, tabConfig : { plugins : &apos;responsive&apos;, responsiveConfig : { wide : { iconAlign : &apos;left&apos;, textAlign : &apos;left&apos; }, tall : { iconAlign : &apos;top&apos;, textAlign : &apos;center&apos;, width : 120 } } } }, items : [ { title : &apos;Home&apos;, iconCls : &apos;fa-home&apos;, items : [ { xtype : &apos;mainlist&apos; } ] }, { title : &apos;Users&apos;, iconCls : &apos;fa-user&apos;, bind : { html : &apos;{loremIpsum}&apos; } }, { title : &apos;Groups&apos;, iconCls : &apos;fa-users&apos;, bind : { html : &apos;{loremIpsum}&apos; } }, { title : &apos;Settings&apos;, iconCls : &apos;fa-cog&apos;, bind : { html : &apos;{loremIpsum}&apos; } } ] }); 上面代码中，items 中的代码几乎和 modern 工具包中的是一样的。此外，这个文件有些配置是专用于支持响应设计的。下列代码告诉框架使用的 ui组件为 navigation ： ui: ‘navigation’ 在第8章(主题和响应设计)中会介绍关于这个 UI 配置和响应设计的内容。 同样的，如果你打开 classic 或 modern 下的 List.js ，你会发现他们只有很细微的区别。 探索 Sencha Cmd 命令 现在让我们学习 Sencha Cmd 的一些非常有用的命令。 Sencha 命令格式Sencha 命令采取以下格式： sencha [category] [command] [options…] [arguments…] 在 Sencha Cmd 中许多命令和可选项。我们看一下都有哪些比较重要的命令。 Help键入以下命令，你将获取一个 categories(类别)列表，一个顶层的 commands(命令)列表，一个可用的 options(选项)列表： sencha help 获取一个特定类别的帮助信息，类别名称紧随在 help 后面，例如获取一个类别 app 的帮助信息，运行下列命令： sencha help app 将产生以下输出： 如果你想进一步获取 app 命令下的子命令的帮助信息，你只需要在最后添加子命令例如 clean，如以下代码所示： sencha help app clean 将产生以下输出： 升级 Sencha Cmd如果你想检查是否有 Sencha Cmd 可用的更新，使用以下命令： sencha upgrade --check 如果你要升级 Sencha Cmd，只需要移除 –check 选项，如以下代码所示： sencha upgrade 升级 ExtJS 应用升级一个现有的 ExtJS 应用到最新版本，需要先进入到你的 ExtJS 工程目录，使用一下命令： sencha app upgrade 后面跟上 sdk 路径 不加路径的话，就会自动从官网下载最新版本的 ExtJS 框架。 注意：如果 sencha cmd 与要升级到的 ExtJS 框架版本不兼容，需要先升级 SenchaCMD 再升级 ExtJS。 生成一个应用Sencha Cmd 支持 Ext JS 4.1.1a 及更高版本和支持 Sencha Touch 2.1 及更高版本。你电脑上可以存在多个版本的SDK。这是基于 Sencha SDK 生成应用的命令格式，例如 Ext JS 或者 Sencha Touch： sencha -sdk /path/to/sdk generate app [--modern/classic] MyApp /path/to/ myapp 这个示例代码将在目录 /Users/SomeUser/projects/extjs/myapp 下生成名为 MyApp 的 Ext JS 6 应用： sencha -sdk /Users/SomeUser/bin/Sencha/Cmd/repo/extract/ext/6.0.0/ generate app MyApp /Users/SomeUser/projects/extjs/myapp 构建应用运行下列命令将进行构建 HTML，JS，SASS 等等： sencha app build 使用 Sencha Cmd 6 构建 Ext JS 6 应用，你还可以运行下列命令选择构建 moern 或 classic 风格的应用： sencha app build modern sencha app build classic 这里说一下， modern 和 classic 的构建配置在 app.json 。 默认 Sencha Cmd 运行两个构建配置：classic 和 modern 。如果需要你也可以在 app.json 中添加额外的构建配置。 启动应用watch 命令用于重新构建并启动应用。这不仅会启动应用程序,还监视任何代码更改，一旦代码改变，浏览器刷新将包括最新的代码： sencha app watch 在 Sencha Cmd 6 和 Ext JS 6，你也可以运行下列命令选择 modern 或 classic： sencha app watch modern sencha app watch classic 代码生成用Sencha Cmd，你可以生成 Ext JS 代码，例如 view，controller，model： sencha generate view myApp.MyView sencha generate model MyModel id:int,fname,lname sencha generate controller MyController 当你生成 model 时如果不指定字段类型，默认类型是 string。 升级你的应用Sencha Cmd 升级 SDK 的版本是很容易的。使用这个升级命令将你的程序升级到新框架： sencha app upgrade [ path-to-new-framework ] 调试 Ext JS 应用你可以使用浏览器默认的调试器来调试 Ext JS 代码，但是使用火狐浏览器的 firebug 插件再安装 Illumination 或者使用 Chrome的 Inspector 插件调试这将会容易得多。 Illumination Illumination 是一个第三方工具。它并不是 Sencha 的一个产品，目前它只支持火狐浏览器。 Illumination 的特性这有些 Illumination 的特性，这将减少你在调试上花的时间。 对象命名Illumination 会很容易识别出 Ext JS 组件，所以在 illumination 标签页你能看到 Ext JS 组件名称，例如Ext.panel.Panel 而不是像在 firebug 的 DOM 页里那样显示成 Object 。 Element 高亮如果在 Illumination 窗口你鼠标悬停在任意对象上，将会突出高亮在 HTML 页面中的组件。 上下文菜单The contextual menu一个 Ext JS 组件是由数个 HTML 元素组成的。如果你在页面右击选择使用 firebug 查看元素，你会看到元素是嵌套在 Ext JS组件里，但是如果你选择 Illumination 来查看元素，会直接显示 Ext JS 组件，这更有便于检查组件的方法属性和事件。 firebug DOM 标签页里对象是如何展示的： 再看一下 Illumination 标签页下对象是如何展示的，你会发现所有组件都显示在下列截图中： 尽管 Illumination 使调试 Ext JS 应用变得容易，但是并不是必须用它。它并不是免费的，你不想购买的话，仍然可以使用 firebug调试，但你也许会多花一些时间调试，或者使用 App Inspector 插件或者 Sencha Fillde 调试。然并卵，我还是建议使用 firebug就行了。 App InspectorApp Inspector 是一个由 Sencha 开发的免费的 Chrome 插件。它支持所有 Illumination 支持的功能。 相比使用 Illumination 一些信息在 App Inspector 查找更容易方便，并且使用 Illumination 比使用 AppInspector 载入程序时间更长。 App Inspector 的截图： Sencha Fiddle这是另外的一个调试工具。这也是一个在线的基于 web 的 IDE 并提供了一些调试功能，如下图： 开发 IDE 尽管你可以使用任何简单的文本编辑器来编写 Ext JS 代码，使用 IDE 开发肯定更简单。Sencha 为JetBrains 提供 SenchaJetBrains 插件支持，例如 IntelliJ，WebStrome，PHPStorm，和 RubyMine。 如果你在寻找一些免费的 IDE，那么你可以看一下 Visual Studio Code 和 Brackets.io。这两个都是非常轻量级，并且开源的文本编辑器，支持 Mac，Windows，Linux，下图是 Visual Studio Code ： 总结在本章中, 我们看到了使用 JavaScript 框架相较于使用传统纯 JavaScript 的优势。也了解了 Ext JS应用的体系结构，你也学习到如何配置你的开发环境以及如何用 Sencha Cmd 搭建 Ext JS 应用。 在下一章中, 您将了解Ext JS的核心概念和基本知识。","categories":[{"name":"ExtJs","slug":"ExtJs","permalink":"https://www.itchina.top/categories/ExtJs/"}],"tags":[{"name":"ext","slug":"ext","permalink":"https://www.itchina.top/tags/ext/"},{"name":"extjs","slug":"extjs","permalink":"https://www.itchina.top/tags/extjs/"},{"name":"javascript","slug":"javascript","permalink":"https://www.itchina.top/tags/javascript/"}]},{"title":"Docker私有仓库的搭建与使用","slug":"Docker私有仓库的搭建与使用","date":"2018-04-19T16:34:21.416Z","updated":"2018-04-19T16:29:55.158Z","comments":true,"path":"2018/04/20/Docker私有仓库的搭建与使用/","link":"","permalink":"https://www.itchina.top/2018/04/20/Docker私有仓库的搭建与使用/","excerpt":"","text":"和Maven一样，Docker不仅提供了一个中央仓库，同时也允许我们搭建私有仓库。如果读者对Maven有所了解，将会很容易理解私有仓库的优势： 节省带宽，镜像无需从中央仓库下载，只需从私有仓库中下载即可 对于私有仓库中已有的镜像，提升了下载速度 便于内部镜像的统一管理 下面我们来讲解一下如何搭建、使用私有仓库 准备工作准备两台安装有Docker的CentOS7的机器，主机规划如下（仅供参考）： 主机 IP 角色 node0 192.168.11.143 Docker开发机 node1 192.168.11.144 Docker私有仓库 安装、使用私有仓库网上有很多 docker-registry 的教程，但是 docker-registry 已经过时，并且已经2年不维护了。详见 https://github.com/docker/docker-registry ，故而本文不做探讨，对 docker-registry 有兴趣的童鞋可以查阅本节的参考文档。 本节讲解registry V2，registry V2需要Docker版本高于1.6.0。registryV2要求使用https访问，那么我们先做一些准备，为了方便，这边模拟以域名 reg.itmuch.com 进行讲解。 使用域名搭建https的私有仓库 首先修改两台机器的hosts，配置 192.168.11.144 到 reg.itmuch.com 的映射 echo &apos;192.168.11.144 reg.itmuch.com&apos;&gt;&gt; /etc/hosts 既然使用https，那么我们需要生成证书，本文讲解的是使用openssl自签名证书，当然也可以使用诸如 Let’s Encrypt 等工具生成证书，首先在node1机器上生成key： mkdir -p ~/certs cd ~/certs openssl genrsa -out reg.itmuch.com.key 2048 再生成密钥文件： openssl req -newkey rsa:4096 -nodes -sha256 -keyout reg.itmuch.com.key -x509 -days 365 -out reg.itmuch.com.crt 会有一些信息需要填写： Country Name (2 letter code) [XX]:CN # 你的国家名称 State or Province Name (full name) []:JS # 省份 Locality Name (eg, city) [Default City]:NJ # 所在城市 Organization Name (eg, company) [Default Company Ltd]:ITMUCH # 组织名称 Organizational Unit Name (eg, section) []:ITMUCH # 组织单元名称 Common Name (eg, your name or your server&apos;s hostname) []:reg.itmuch.com # 域名 Email Address []:eacdy0000@126.com # 邮箱 这样自签名证书就制作完成了。 由于是自签名证书，默认是不受Docker信任的，故而需要将证书添加到Docker的根证书中，Docker在CentOS 7中，证书存放路径是 /etc/docker/certs.d/域名 ： node1 端： mkdir -p /etc/docker/certs.d/reg.itmuch.com cp ~/certs/reg.itmuch.com.crt /etc/docker/certs.d/reg.itmuch.com/ node0 端：将生成的证书下载到根证书路径 mkdir -p /etc/docker/certs.d/reg.itmuch.com scp root@192.168.11.144:/root/certs/reg.itmuch.com.crt /etc/docker/certs.d/reg.itmuch.com/ 重新启动 node0 和 node1 的Docker service docker restart 在 node1 上启动私有仓库 首先切换到家目录中，这一步不能少，原因是下面的-v 挂载了证书，如果不切换，将会引用不到证书文件。 cd ~ 启动Docker私有仓库（注意：如果直接粘贴运行，请删除掉注释）： docker run -d -p 443:5000 --restart=always --name registry \\ -v `pwd`/certs:/certs \\ # 将“当前目录/certs”挂载到容器的“/certs” -v /opt/docker-image:/opt/docker-image \\ -e STORAGE_PATH=/opt/docker-image \\ # 指定容器内存储镜像的路径 -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/reg.itmuch.com.crt \\ # 指定证书文件 -e REGISTRY_HTTP_TLS_KEY=/certs/reg.itmuch.com.key \\ # 指定key文件 registry:2 其中，之所以挂载/opt/docker-image目录，是为了防止私有仓库容器被删除，私有仓库中的镜像也会丢失。 在 node0 上测试，将镜像push到私服 docker pull kitematic/hello-world-nginx docker tag kitematic/hello-world-nginx reg.itmuch.com/kitematic/hello-world-nginx # 为本地镜像打标签 docker push reg.itmuch.com/kitematic/hello-world-nginx # 将镜像push到私服 会发现如下内容： The push refers to a repository [reg.itmuch.com/kitematic/hello-world-nginx] 5f70bf18a086: Pushed b51acdd3ef48: Pushed 3f47ff454588: Pushed .... latest: digest: sha256:d3e1883b703c39556f2f09da14cc3b820f69a43436655c882c0c0ded0dda6a4b size: 3226 说明已经push成功。 从私服中下载镜像： docker pull reg.itmuch.com/kitematic/hello-world-nginx 配置登录认证在很多场景下，我们需要用户登录后才能访问私有仓库，那么我们可以如下操作： 建立在上文生成证书，同时重启过Docker服务的前提下，我们讲解一下如何配置： 为防止端口冲突，我们首先删除或停止之前启动好的私有仓库： docker kill registry 在node1机器上安装 httpd-tools ： yum install httpd-tools 在node机器上创建密码文件，并添加一个用户 testuser ，密码是 testpassword ： cd ~ mkdir auth htpasswd -Bbn testuser testpassword &gt; auth/htpasswd 在node1机器上切换到 ~ 目录，并启动私有仓库（注意：如果直接粘贴运行，请删除掉注释）： docker run -d -p 443:5000 --restart=always --name registry2 \\ -v /opt/docker-image:/var/lib/registry \\ # 挂载容器内存储镜像路径到宿主机 -v `pwd`/certs:/certs \\ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/reg.itmuch.com.crt \\ -e REGISTRY_HTTP_TLS_KEY=/certs/reg.itmuch.com.key \\ -v `pwd`/auth:/auth \\ -e &quot;REGISTRY_AUTH=htpasswd&quot; \\ -e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \\ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\ registry:2 测试： docker push reg.itmuch.com/kitematic/hello-world-nginx 提示： 461f75075df2: Image push failed no basic auth credentials 说明需要认证。 我们登陆一下，执行： docker login reg.imuch.com 再次执行 docker push reg.itmuch.com/kitematic/hello-world-nginx 就可以正常push镜像到私有仓库了。 注意： 如果想要从私有仓库上下载镜像，同样需要登录。 参考文档：官方文档： https://docs.docker.com/registry/deploying/#/running-a-domain-registry Docker Registry V2 htpasswd认证方式搭建： http://www.tuicool.com/articles/vMZZveM Docker Registry V2搭建： http://www.tuicool.com/articles/6jEJZj Docker Registry V2搭建： http://tomhat.iteye.com/blog/2304098 Docker Registry V1搭建： http://blog.csdn.net/wsscy2004/article/details/26279569 非认证的Docker Registry V1搭建： http://blog.csdn.net/wangtaoking1/article/details/44180901 带认证的Docker Registry V1搭建： http://snoopyxdy.blog.163.com/blog/static/601174402015823741997/ Docker专题汇总： http://www.zimug.com/360.html Docker疑难解答： https://segmentfault.com/q/1010000000938076","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.itchina.top/tags/docker/"}]},{"title":"Excel文件office2003 and office2007 操作","slug":"Excel文件office2003 and office2007 操作","date":"2018-04-19T16:34:21.416Z","updated":"2018-04-19T16:30:25.700Z","comments":true,"path":"2018/04/20/Excel文件office2003 and office2007 操作/","link":"","permalink":"https://www.itchina.top/2018/04/20/Excel文件office2003 and office2007 操作/","excerpt":"","text":"这篇blog主要是讲述java中poi读取excel，而excel的版本包括：2003-2007和2010两个版本，即excel的后缀名为：xls和xlsx。 poi-3.7-20101029.jar，下载地址：http://download.csdn.net/detail/evangel_z/4107089geronimo-stax-api_1.0_spec-1.0.jar，下载地址：http://download.csdn.net/detail/evangel_z/4107083xmlbeans-2.3.0.jar，下载地址：http://download.csdn.net/detail/evangel_z/4107140poi-ooxml-3.7-20101029.jar，下载地址：http://download.csdn.net/detail/evangel_z/4107145poi-ooxml-schemas-3.7-20101029.jar，下载地址：http://download.csdn.net/detail/evangel_z/4108997以上5个jar，就可读取Excel 2003； -—————————————————————————-读取Excel2007，请加上dom4j-1.6.1.jar，下载地址：http://download.csdn.net/detail/evangel_z/6739735 -—————————————————————————-poi-3.6-20091214.jar，下载地址：http://download.csdn.net/detail/evangel_z/3895051poi-contrib-3.6-20091214.jar，下载地址：http://download.csdn.net/detail/evangel_z/4107197poi-scratch.6-20091214.jar，下载地址：http://download.csdn.net/detail/evangel_z/4107204 ================================================= 源码部分： 读取操作 ReadExcelUtil ================================================= 1 import java.io.File; 2 import java.io.FileInputStream; 3 import java.io.FileNotFoundException; 4 import java.io.IOException; 5 import java.text.DecimalFormat; 6 import java.text.SimpleDateFormat; 7 import java.util.ArrayList; 8 import java.util.LinkedList; 9 import java.util.List; 10 11 import org.apache.poi.hssf.usermodel.*; 12 import org.apache.poi.xssf.usermodel.XSSFCell; 13 import org.apache.poi.xssf.usermodel.XSSFRow; 14 import org.apache.poi.xssf.usermodel.XSSFSheet; 15 import org.apache.poi.xssf.usermodel.XSSFWorkbook; 16 17 /** 18 * 读Excel文件office2003 and office2007 19 * @author lerry.li 20 * @date 2016-9-2 21 */ 22 public class ReadExcelUtil { 23 24 private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(ReadExcelUtil.class); 25 static DecimalFormat df = new DecimalFormat(&quot;0&quot;);// 格式化 number String 字符 26 static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);// 格式化日期字符串 27 static DecimalFormat nf = new DecimalFormat(&quot;0.00&quot;);// 格式化数字 28 29 /** 30 * 对外提供读取excel 的方法 31 * @param file 32 * @return 33 * @throws java.io.IOException 34 * @throws java.io.IOException 35 */ 36 public static List&lt;List&lt;Object&gt;&gt; readExcel(File file) throws IOException { 37 String fileName = file.getName(); 38 String extension = fileName.lastIndexOf(&quot;.&quot;) == -1 ? &quot;&quot; : fileName 39 .substring(fileName.lastIndexOf(&quot;.&quot;) + 1); 40 if (&quot;xls&quot;.equals(extension)) { 41 return read2003Excel(file); 42 } else if (&quot;xlsx&quot;.equals(extension)) { 43 return read2007Excel(file); 44 } else { 45 throw new IOException(&quot;不支持的文件类型&quot;); 46 } 47 } 48 49 /** 50 * 读取 office 2003 excel 51 * @throws java.io.IOException 52 * @throws java.io.FileNotFoundException 53 */ 54 @SuppressWarnings(&quot;unused&quot;) 55 private static List&lt;List&lt;Object&gt;&gt; read2003Excel(File file) 56 throws IOException { 57 List&lt;List&lt;Object&gt;&gt; list = new LinkedList&lt;List&lt;Object&gt;&gt;(); 58 HSSFWorkbook hwb = new HSSFWorkbook(new FileInputStream(file)); 59 HSSFSheet sheet = hwb.getSheetAt(0); 60 Object value = null; 61 HSSFRow row = null; 62 HSSFCell cell = null; 63 for (int i = sheet.getFirstRowNum(); i &lt;= sheet 64 .getPhysicalNumberOfRows(); i++) { 65 row = sheet.getRow(i); 66 if (row == null) { 67 continue; 68 } 69 List&lt;Object&gt; linked = new LinkedList&lt;Object&gt;(); 70 for (int j = row.getFirstCellNum(); j &lt;= row.getLastCellNum(); j++) { 71 cell = row.getCell(j); 72 if (cell == null) { 73 continue; 74 } 75 DecimalFormat df = new DecimalFormat(&quot;0&quot;);// 格式化 number String 76 // 字符 77 SimpleDateFormat sdf = new SimpleDateFormat( 78 &quot;yyyy-MM-dd HH:mm:ss&quot;);// 格式化日期字符串 79 DecimalFormat nf = new DecimalFormat(&quot;0&quot;);// 格式化数字 80 switch (cell.getCellType()) { 81 case HSSFCell.CELL_TYPE_STRING: 82 value = cell.getStringCellValue(); 83 break; 84 case HSSFCell.CELL_TYPE_NUMERIC: 85 if (&quot;@&quot;.equals(cell.getCellStyle().getDataFormatString())) { 86 value = df.format(cell.getNumericCellValue()); 87 } else if (&quot;General&quot;.equals(cell.getCellStyle() 88 .getDataFormatString())) { 89 value = nf.format(cell.getNumericCellValue()); 90 } else { 91 value = sdf.format(HSSFDateUtil.getJavaDate(cell 92 .getNumericCellValue())); 93 } 94 break; 95 case HSSFCell.CELL_TYPE_BOOLEAN: 96 value = cell.getBooleanCellValue(); 97 break; 98 case HSSFCell.CELL_TYPE_BLANK: 99 value = &quot;&quot;; 100 break; 101 default: 102 value = cell.toString(); 103 } 104 //if (value == null || &quot;&quot;.equals(value)) { 105 // continue; 106 //} 107 if (value == null) { 108 continue; 109 } 110 linked.add(value); 111 } 112 list.add(linked); 113 } 114 return list; 115 } 116 117 /** 118 * 读取Office 2007 excel 119 * @param file 120 * @return 121 * @throws java.io.IOException 122 */ 123 private static List&lt;List&lt;Object&gt;&gt; read2007Excel(File file) 124 throws IOException { 125 int flag=0; 126 List&lt;List&lt;Object&gt;&gt; list = new ArrayList&lt;List&lt;Object&gt;&gt;(); 127 // 构造 XSSFWorkbook 对象，strPath 传入文件路径 128 XSSFWorkbook xwb = new XSSFWorkbook(new FileInputStream(file)); 129 // 读取第一章表格内容 130 XSSFSheet sheet = xwb.getSheetAt(0); 131 Object value = null; 132 XSSFRow row = null; 133 XSSFCell cell = null; 134 for (int i = sheet.getFirstRowNum(); i &lt;= sheet 135 .getPhysicalNumberOfRows(); i++) { 136 flag++; 137 row = sheet.getRow(i); 138 if (row == null) { 139 continue; 140 } 141 List&lt;Object&gt; linked = new LinkedList&lt;Object&gt;(); 142 for (int j = row.getFirstCellNum(); j &lt;= row.getLastCellNum(); j++) { 143 cell = row.getCell(j); 144 if (cell == null) { 145 continue; 146 } 147 //DecimalFormat df = new DecimalFormat(&quot;0&quot;);// 格式化 number String 148 // 字符 149 switch (cell.getCellType()) { 150 case HSSFCell.CELL_TYPE_STRING: 151 value = cell.getStringCellValue(); 152 break; 153 case HSSFCell.CELL_TYPE_NUMERIC: 154 if (&quot;@&quot;.equals(cell.getCellStyle().getDataFormatString())) { 155 value = df.format(cell.getNumericCellValue()); 156 } else if (&quot;General&quot;.equals(cell.getCellStyle() 157 .getDataFormatString())) { 158 value = nf.format(cell.getNumericCellValue()); 159 } else { 160 value = sdf.format(HSSFDateUtil.getJavaDate(cell 161 .getNumericCellValue())); 162 } 163 break; 164 case HSSFCell.CELL_TYPE_BOOLEAN: 165 value = cell.getBooleanCellValue(); 166 break; 167 case HSSFCell.CELL_TYPE_BLANK: 168 value = &quot;&quot;; 169 break; 170 default: 171 value = cell.toString(); 172 } 173 //if (value == null || &quot;&quot;.equals(value)) { 174 // continue; 175 //} 176 if (value == null) { 177 continue; 178 } 179 linked.add(value); 180 } 181 list.add(linked); 182 } 183 return list; 184 } 185 /** 186 * 获取行数2003 187 * @param file 188 * @return 行数 189 */ 190 public static int getRow2003(File file){ 191 HSSFWorkbook hwb = null; 192 try { 193 FileInputStream f = new FileInputStream(file); 194 hwb = new HSSFWorkbook(f); 195 } catch (FileNotFoundException e) { 196 e.printStackTrace(); 197 } catch (IOException e) { 198 e.printStackTrace(); 199 } 200 HSSFSheet sheet = hwb.getSheetAt(0); 201 return sheet.getPhysicalNumberOfRows(); 202 } 203 /** 204 * 获取行数2007 205 * @param file 206 * @return 207 */ 208 public static int getRow2007(File file){ 209 XSSFWorkbook xwb = null; 210 try { 211 FileInputStream f = new FileInputStream(file); 212 xwb = new XSSFWorkbook(f); 213 } catch (Exception e) { 214 e.printStackTrace(); 215 } 216 XSSFSheet sheet = xwb.getSheetAt(0); 217 return sheet.getPhysicalNumberOfRows(); 218 } 219 220 public static void main(String[] args) { 221 222 File f = new File(&quot;C:/Users/Administrator/Desktop/Book1.xlsx&quot;); 223 try { 224 List&lt;List&lt;Object&gt;&gt; list = readExcel(f); 225 for (int i = 0; i &lt; list.size(); i++) { 226 String s1 = list.get(i).toString().trim(); 227 s1 = s1.replace(&quot;[&quot;, &quot;&quot;); 228 s1 = s1.replace(&quot;]&quot;, &quot;&quot;); 229 s1 = s1.replace(&quot; &quot;, &quot;&quot;); 230 String str = s1.replaceAll(&quot; &quot;, &quot;&quot;).trim(); 231 String[] s=str.split(&quot;,&quot;); 232 for(int j=0;j&lt;s.length;j++){ 233 System.out.println(&quot;===&quot;+s[j]); 234 } 235 } 236 } catch (Exception e) { 237 e.printStackTrace(); 238 } 239 } 240 241 } ================================================= 源码部分： 下载操作 DownLoadExcelUtil ================================================= 1 import java.io.BufferedInputStream; 2 import java.io.BufferedOutputStream; 3 import java.io.File; 4 import java.io.FileInputStream; 5 import java.io.IOException; 6 import java.io.InputStream; 7 import java.io.OutputStream; 8 9 import javax.servlet.ServletContext; 10 import javax.servlet.ServletOutputStream; 11 import javax.servlet.http.HttpServletRequest; 12 import javax.servlet.http.HttpServletResponse; 13 14 import org.slf4j.Logger; 15 16 /** 17 * 读Excel文件office2003 and office2007 18 * @author lerry.li 19 * @date 2016-9-2 20 */ 21 public class DownLoadExcelUtil { 22 23 private static final Logger log = org.slf4j.LoggerFactory.getLogger(DownLoadExcelUtil.class); 24 /** 25 * 下载Excel 26 * @param path 文件路径 27 * @param response 28 */ 29 public static void download(String path, HttpServletResponse response) { 30 try { 31 // path是指欲下载的文件的路径。 32 File file = new File(path); 33 // 取得文件名。 34 String filename = file.getName(); 35 // 以流的形式下载文件。 36 InputStream fis = new BufferedInputStream(new FileInputStream(path)); 37 byte[] buffer = new byte[fis.available()]; 38 fis.read(buffer); 39 fis.close(); 40 // 清空response 41 response.reset(); 42 // 设置response的Header 43 response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; 44 + new String(filename.getBytes())); 45 response.addHeader(&quot;Content-Length&quot;, &quot;&quot; + file.length()); 46 OutputStream toClient = new BufferedOutputStream( 47 response.getOutputStream()); 48 response.setContentType(&quot;application/vnd.ms-excel;charset=gb2312&quot;); 49 toClient.write(buffer); 50 toClient.flush(); 51 toClient.close(); 52 } catch (Exception ex) { 53 log.info(ex.getMessage()); 54 ex.printStackTrace(); 55 } 56 } 57 58 }","categories":[{"name":"J2EE","slug":"J2EE","permalink":"https://www.itchina.top/categories/J2EE/"}],"tags":[]},{"title":"apache调优隐藏版本信息及404重定向","slug":"apache调优隐藏版本信息及404重定向","date":"2018-04-19T16:34:21.415Z","updated":"2018-04-19T16:30:17.020Z","comments":true,"path":"2018/04/20/apache调优隐藏版本信息及404重定向/","link":"","permalink":"https://www.itchina.top/2018/04/20/apache调优隐藏版本信息及404重定向/","excerpt":"","text":"apache调优隐藏版本信息及404重定向 本节所讲 内容： 实战：源码编译安装 apache 及调优技巧 实战环境： 生产环境中，部署了 apache 之后，我们应该从安全还是性能角度，在 apache 服务上线之前，对其做诸多的优化调试才行。 Apache 实验环境： apache 版本： httpd-2.2.31 源码包存放位置： /usr/local/src 源码包编译安装位置： apache ： /usr/local/apache2.2-xuegod/ 技巧 1 ： 安装 apache 屏蔽 apache 版本等敏感信息 查看 apache 版本信息： [root@xuegod63 ~]# curl -Iwww.baidu.com 。。。 X-Powered-By: HPHP Server: BWS/1.1 X-UA-Compatible:IE=Edge,chrome=1 BDPAGETYPE: 1 BDQID: 0xcfd31d8200026e11 BDUSERID: 0 测试自己的网站看是什么版本？有没有相应的漏洞 [root@xuegod63 ~]# curl -Iwww.taobao.com HTTP/1.1 302 Found Server :Tengine 基于 nginx 做了二次开发 Date: Tue, 17 Nov 201502:22:06 GMT Content-Type: text/html Content-Length: 258 Connection: keep-alive Location: https://www.taobao.com/ 彻底让版本等敏感信息消失 要彻底将版本之类的信息进行改头换面，需要在编译之前修改源码包下 include/ap_release.h 文件 [root@xuegod63 httpd-2.2.25]#pwd /usr/local/src [root@xuegod63 src]# rm -rfhttpd-2.2.25 [root@xuegod63 src]# tar zxfhttpd-2.2.25.tar.gz [root@xuegod63 src]# cdhttpd-2.2.25 [root@xuegod63 httpd-2.2.25]#vim include/ap_release.h # 修改源码中的版本信息为自己公司的相关信息，隐藏真实版本信息 改： 42 #define AP_SERVER_BASEVENDOR”Apache Software Foundation” 43 #define AP_SERVER_BASEPROJECT “ApacheHTTP Server” 44 #define AP_SERVER_BASEPRODUCT”Apache” 45 46 #define AP_SERVER_MAJORVERSION_NUMBER 2 47 #define AP_SERVER_MINORVERSION_NUMBER 2 48 #define AP_SERVER_PATCHLEVEL_NUMBER 25 49 #define AP_SERVER_DEVBUILD_BOOLEAN 0 为： #defineAP_SERVER_BASEVENDOR “xuegod” #defineAP_SERVER_BASEPROJECT “ web server” #defineAP_SERVER_BASEPRODUCT “ xuegod web server” #defineAP_SERVER_MAJORVERSION_NUMBER 8 #defineAP_SERVER_MINORVERSION_NUMBER 1 #defineAP_SERVER_PATCHLEVEL_NUMBER 2 #defineAP_SERVER_DEVBUILD_BOOLEAN 3 注释： #define AP_SERVER_BASEVENDOR”Apache Software Foundation” # 服务的供应商名称 #define AP_SERVER_BASEPROJECT”Apache HTTP Server” # 服务的项目名称 #define AP_SERVER_BASEPRODUCT”Apache” # 服务的产品名 #define AP_SERVER_MAJORVERSION_NUMBER2 # 主要版本号 #defineAP_SERVER_MINORVERSION_NUMBER 4 # 小版本号 #defineAP_SERVER_PATCHLEVEL_NUMBER 6 # 补丁级别 #defineAP_SERVER_DEVBUILD_BOOLEAN 0 # 注：上述列出的行，大家可以修改成自己想要的，然后编译安装之后，再对 httpd-default.conf 文件进行修改，对方就彻底不知道你的版本号了。 源码编译安装 apache [root@xuegod63 httpd-2.2.11]# yum installopenssl* [root@xuegod63 httpd-2.2.25]#./configure –prefix=/usr/local/apache2.2-xuegod –enable-so –enable-rewrite–enable-ssl –enable-deflate –enable-expires # 检查安装环境并生成 Makefile 文件 配置参数用途： --prefix=/usr/local/apache2.2 # 指定安装路径 --enable-so # 支持动态加载模 块 --enable-rewrite # 支持网站地址重写 --enable-ssl # 支持 ssl 加密 --enable-deflate # 支持页面传输前进行压缩 --enable-expires # 支持设置网页缓存的时间 编译安装： make&amp;&amp; make install 查看安装后目录： [root@xuegod63 httpd-2.2.25]# ls/usr/local/apache2.2-xuegod/conf/httpd.conf /usr/local/apache2.2-xuegod/conf/httpd.conf 存放网站的根目录： [root@xuegod63 httpd-2.2.25]#ls /usr/local/apache2.2-xuegod/htdocs/ index.html 修改默认首页内容： [root@xuegod63 httpd-2.2.25]# echo apache-xuegod&gt;&gt; /usr/local/apache2.2-xuegod/htdocs/index.html 启动 apache ： 配置 apache 可以开机启动并且可以使用 service 命令启动 apache 服务器 [root@xuegod63 httpd-2.2.25]#cp /usr/local/apache2.2-xuegod/bin/apachectl /etc/init.d/apachectl-xuegod 启动 apache ： [root@xuegod63httpd-2.2.25]# /etc/init.d/apachectl-xuegod start 测试： 测试：隐藏 apache 版本信息 [root@xuegod63 ~]# curl -I192.168.1.63 # 看不到 apache 版本相关内容了 HTTP/1.1 200 OK Date: Sat, 29 Aug 201509:43:44 GMT Server: xuegod web server/8.1.2-dev (Unix) mod_ssl/8.1.2-devOpenSSL/1.0.0-fips Last-Modified: Sat, 29 Aug2015 09:37:36 GMT ETag: “6d086-3a-51e6ff35dba19” Accept-Ranges: bytes Content-Length: 58 Content-Type: text/html 再次隐藏版本号和系统类型 接下来再次修改： [root@xuegod63 ~]# vim/usr/local/apache2.2-xuegod/conf/httpd.conf 405 #Includeconf/extra/httpd-default.conf 为： Includeconf/extra/httpd-default.conf 2 ）打开 httpd-default.conf 文件，修改如下两个地方 [root@xuegod63 ~]# vim/usr/local/apache2.2-xuegod/conf/extra/httpd-default.conf 改： 55 ServerTokens Full 65 ServerSignature On signature 签名 为： ServerTokens Prod # 不显示服务器操作系统类型 ServerSignature Off # 不显示 web 服务器版本号 让 apache 配置文件生效的方法： 方法 1 ：重启服务： restart 方法 2 ：不重启服务，重新加载配置文件 reload 是 nginx [root@xuegod63 ~]#/etc/init.d/apachectl-xuegod graceful 优雅的 测试： [root@xuegod63 ~]# curl -I192.168.1.63 HTTP/1.1 200 OK Date: Thu, 14 Jan 201602:31:24 GMT Server: xuegod web server 总结： 1， 安装之前改 include/ap_release.h 2， Httpd.conf extra/httpd-default.conf 去掉注释 3， 修改 extra/httpd-default.conf 55 ServerTokens Full 65 ServerSignature On signature 签名 为： ServerTokens Prod # 不显示服务器操作系统类型 ServerSignature Off # 不显示 web 服务器版本号 2 、错误页面优雅显示 为了提升网站的用户体验，避免 404 ， 403 之类的丑陋的默认错误提示出现。 http://192.18.1.63/a.html 方法一： [root@xuegod63 ~]# vim/usr/local/apache2.2-xuegod/conf/httpd.conf # 在根目录的标签中添加以下红色标记内容。 132 。。。 在大约 159 行，插入： ErrorDocument 404 http://www.baidu.com 160 注： # 将 404 错误跳转到 http://www.baidu.com 重启： [root@xuegod63 ~]#/etc/init.d/apachectl-xuegod restart 总结： ErrorDocument 的命令格式如下： ErrorDocument 错误代码 跳转到的页面或文件 另外这里需要注意，你若设置跳转到文件，必须要有这个文件才行。另外文件必须在站点目录内，不然会报错。 终极总结： 1、 隐藏 web 服务的版本信息 2、 出现 404 错误，给它一个友好的提示","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.itchina.top/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.itchina.top/tags/linux/"},{"name":"Apache","slug":"Apache","permalink":"https://www.itchina.top/tags/Apache/"}]},{"title":"Activiti工作流引擎使用","slug":"Activiti工作流引擎使用","date":"2018-04-19T16:34:21.414Z","updated":"2018-04-19T16:30:20.657Z","comments":true,"path":"2018/04/20/Activiti工作流引擎使用/","link":"","permalink":"https://www.itchina.top/2018/04/20/Activiti工作流引擎使用/","excerpt":"","text":"Activiti工作流引擎使用1.简单介工作流引擎与Activiti对于工作流引擎的解释请参考百度百科： 工作流引擎 1.1 我与工作流引擎在第一家公司工作的时候主要任务就是开发OA系统，当然基本都是有工作流的支持，不过当时使用的工作流引擎是公司一些牛人开发的（据说是用一个开源的引擎修改的），名称叫CoreFlow；功能相对Activiti来说比较弱，但是能满足日常的使用，当然也有不少的问题所以后来我们只能修改引擎的代码打补丁。 现在是我工作的第二家公司，因为要开发ERP、OA等系统需要使用工作流，在项目调研阶段我先搜索资料选择使用哪个 开源 工作流引擎，最终确定了Activiti5并基于公司的架构做了一些DEMO。 1.2 Activiti与JBPM5？对于Activiti、jBPM4、jBPM5我们应该如何选择，在InfoQ上有一篇文章写的很好，从大的层面比较各个引擎之间的差异，请参考文章： 纵观jBPM：从jBPM3到jBPM5以及Activiti5 1.3 Activiti资料 官网： http://www.activiti.org/ 下载： http://www.activiti.org/download.html 版本：Activiti的版本是从 5 开始的，因为Activiti是使用jBPM4的源码； 版本发布 ：两个月发布一次。 Eclipse Plugin: http://activiti.org/designer/update/ Activit中文群：5435716 2.初次使用遇到问题收集因为Activiti刚刚退出不久所以资料比较 空缺 ，中文资料更是少的 可怜 ，所以开始的时候一头雾水（虽然之前用过工作流，但是感觉差距很多），而且官方的手册还不是很全面；所以我把我在学习使用的过程遇到的一些疑问都罗列出来分享给大家；以下几点是我遇到和想到的，如果你还有什么疑问可以在评论中和我交流再补充。 2.1 部署流程图后中文乱码 乱码 是一直缠绕着国人的问题，之前各个技术、工具出现乱码的问题写过很多文章，这里也不例外……，Activiti的乱码问题在流程图中。 流程图的乱码如下图所示： 解决办法有两种： 2.1.1 修改源代码方式修改源码 org.activiti.engine.impl.bpmn.diagram.ProcessDiagramCanvas 在构造方法 public ProcessDiagramCanvas(int width, int height) 中有一行代码是设置字体的，默认是用 Arial 字体，这就是乱码产生的原因，把字改为本地的中文字体即可，例如： Font font = new Font(&quot;WenQuanYi Micro Hei&quot;, Font.BOLD, 11); 当然如果你有配置文件读取工具那么可以设置在*.properties文件中，我就是这么做的： Font font = new Font(PropertyFileUtil.get(&quot;activiti.diagram.canvas.font&quot;), Font.BOLD, 11); 2.1.2 使用压缩包方式部署Activiti支持部署*.bpmn20.xml、bar、zip格式的流程定义。 使用Activit Deisigner工具设计流程图的时候会有三个类型的文件: .activiti设计工具使用的文件 .bpmn20.xml设计工具自动根据.activiti文件生成的xml文件 .png流程图图片 解决办法就是把xml文件和图片文件同时部署，因为在单独部署xml文件的时候Activiti会自动生成一张流程图的图片文件，但是这样在使用的时候坐标和图片对应不起来…… 所以把xml和图片同时部署的时候Activiti自动关联xml和图片，当需要获取图片的时候直接返回部署时压缩包里面的图片文件，而不是Activiti自动生成的图片文件 2.1.2.1 使用工具打包Bar文件右键项目名称然后点击“Create deployment artifacts”，会在src目录中创建 deployment 文件夹，里面包含*.bar文件. 2.1.2.2 使用Ant脚本打包Zip文件这也是我们采用的办法，你可以手动选择xml和png打包成zip格式的文件，也可以像我们一样采用ant target的方式打包这两个文件。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project name=&quot;foo&quot;&gt; &lt;property name=&quot;workflow.definition&quot; value=&quot;foo-common-core/src/main/resources/diagrams&quot; /&gt; &lt;property name=&quot;workflow.deployments&quot; value=&quot;foo-common-core/src/main/resources/deployments&quot; /&gt; &lt;target name=&quot;workflow.package.oa.leave&quot;&gt; &lt;echo&gt;打包流程定义及流程图::OA-请假&lt;/echo&gt; &lt;zip destfile=&quot;${workflow.deployments}/oa/leave.zip&quot; basedir=&quot;${workflow.definition}/oa/leave&quot; update=&quot;true&quot; includes=&quot;*.xml,*.png&quot; /&gt; &lt;/target&gt; &lt;/project&gt; 这样当修改流程定义文件后只要运行ant命令就可以打包了： ant workflow.package.oa.leave 现在部署bar或者zip文件查看流程图图片就不是乱码了，而是你的压缩包里面的png文件。 2.2 使用引擎提供的Form还是自定义业务Form2.2.1 引擎提供的Form定义表单的方式在每个Task标签中定义 extensionElements 和 activiti:formProperty 即可，到达这个节点的时候可以通过API读取表单元素。 Activiti官方的例子使用的就是在流程定义中设置每一个节点显示什么样的表单哪些字段需要显示、哪些字段只读、哪些字段必填。 但是这种方式仅仅适用于比较简单的流程，对于稍微复杂或者页面需要业务逻辑的判断的情况就不适用了。 对于数据的保存都是在引擎的表中，不利于和其他表的关联、对整个系统的规划也不利！ 2.2.2 自定义业务Form这种方式应该是大家用的最多的了，因为一般的业务系统业务逻辑都会比较复杂，而且数据库中很多表都会有依赖关系，表单中有很多状态判断。 例如我们的系统适用jQuery UI作为UI，有很多javascript代码，页面的很多操作需要特殊处理（例如：多个选项的互斥、每个节点根据类型和操作人显示不同的按钮）；基本每个公司都有一套自己的UI风格，要保持多个系统的操作习惯一致只能使用自定义表单才能满足。 2.3 业务和流程的关联方式这个问题在群里面很多人都问过，这也是我刚刚开始迷惑的地方； 后来看了以下API发现RuntimeService有两个方法： 2.3.1 startProcessInstanceByKeyjavadoc对其说明： startProcessInstanceByKey(String processDefinitionKey, Map variabes) Starts a new process instance in the latest version of the process definition with the given key 其中 businessKey 就是业务ID，例如要申请请假，那么先填写登记信息，然后（保存+启动流程），因为请假是单独设计的数据表，所以保存后得到实体ID就可以把它传给 processInstanceBusinessKey 方法启动流程。当需要根据businessKey查询流程的时候就可以通过API查询: runtimeService.createProcessInstanceQuery().processInstanceBusinessKey(processInstanceBusinessKey, processDefinitionKey); 建 议数据库冗余设计 ：在业务表设计的时候添加一列： PROCESS_INSTANCE_ID varchar2(64) ，在流程启动之后把流程ID更新到业务表中，这样不管从业务还是流程都可以查询到对方！ 特别说明： 此方法启动时自动选择最新版本的流程定义。 2.3.2 startProcessInstanceByIdjavadoc对其说明： startProcessInstanceById(String processDefinitionId, String businessKey, Map variables) Starts a new process instance in the exactly specified version of the process definition with the given id. processDefinitionId ：这个参数的值可以通过 repositoryService.createProcessDefinitionQuery() 方法查询，对应数据库： ACT_RE_PROCDEF ；每次部署一次流程定义就会添加一条数据，同名的版本号累加。 特别说明： 此可以指定不同版本的流程定义，让用户多一层选择。 2.3.3 如何选择建议使用 startProcessInstanceByKey ，特殊情况需要使用以往的版本选择使用 startProcessInstanceById 。 2.4 同步用户数据这个问题也是比较多的人询问过，Activiti支持对任务分配到：指定人、指定组、两者组合，而这些人和组的信息都保存在 ACT_ID.. 表中，有自己的用户和组(角色)管理让很多人不知所措了；原因是因为每个系统都会存在一个权限管理模块（维护：用户、部门、角色、授权），不知道该怎么和Activiti同步。 2.4.1 建议处理方式Activiti有一个 IdentityService 接口，通过这个接口可以操控Activiti的ACT_ID_*表的数据，一般的做法是用业务系统的权限管理模块维护用户数据，当进行CRUD操作的时候在原有业务逻辑后面添加同步到Activiti的代码；例如添加一个用户时同步ActivitiUser的代码片段： /** * 保存用户信息 并且同步用户信息到activiti的identity.User，同时设置角色 * @param user * @param roleIds */ public void saveUser(User user, List&lt;Long&gt; roleIds, boolean synToActiviti) { accountManager.saveEntity(user); String userId = user.getId().toString(); if (synToActiviti) { List&lt;org.activiti.engine.identity.User&gt; activitiUsers = identityService.createUserQuery().userId(userId).list(); if (activitiUsers.size() == 1) { //更新信息 org.activiti.engine.identity.User activitiUser = activitiUsers.get(0); activitiUser.setFirstName(user.getName()); activitiUser.setLastName(&quot;&quot;); activitiUser.setPassword(user.getPassword()); activitiUser.setEmail(user.getEmail()); identityService.saveUser(activitiUser); // 删除用户的membership List&lt;Group&gt; activitiGroups = identityService.createGroupQuery().groupMember(userId).list(); for (Group group : activitiGroups) { identityService.deleteMembership(userId, group.getId()); } // 添加membership for (Long roleId : roleIds) { Role role = roleManager.getEntity(roleId); identityService.createMembership(userId, role.getEnName()); } } else { org.activiti.engine.identity.User newUser = identityService.newUser(userId); newUser.setFirstName(user.getName()); newUser.setLastName(&quot;&quot;); newUser.setPassword(user.getPassword()); newUser.setEmail(user.getEmail()); identityService.saveUser(newUser); // 添加membership for (Long roleId : roleIds) { Role role = roleManager.getEntity(roleId); identityService.createMembership(userId, role.getEnName()); } } } } 删除操作也和这个类似！ 不管从业务系统维护用户还是从Activiti维护，肯定要确定一方，然后CRUD的时候同步到对方，如果需要同步多个子系统那么可以再调用WebService实现。 2.5 流程图设计工具用什么Activiti提供了两个流程设计工具，但是面向对象不同。 Activiti Modeler，面向业务人员，使用开源的BPMN设计工具 Signavio ，使用BPMN描述业务流程图 Eclipse Designer，面向开发人员，Eclipse的插件，可以让开发人员定制每个节点的属性（ID、Name、Listener、Attr等） 2.5.1 我们的方式可能你会惊讶，因为我们没有使用Activiti Modeler，我们认为用Viso已经能表达流程图的意思了，而且项目经理也是技术出身，和开发人员也容易沟通。 目前这个项目是第一个使用Activiti的，开始我们在需求调研阶段使用Viso设计流程图，利用 泳道流程图 设计和客户沟通，确定后由负责流程的开发人员用Eclipse Designer设计得到bpmn20.xml，最后部署。 2.6 Eclipse Designer存在的问题这个插件有一个很讨厌的Bug一直未修复，安装了插件后Eclipse的复制和粘帖快捷键会被更换为(Ctrl+Insert、Shift+Insert)；Bug描述请见： Activit Forums中报告的Bug Jira的登记 所以最后我们只能单独开一个安装了Eclipse Designer的Eclipse专门用来设计流程图，这样就不影响正常使用Eclipse JAVAEE了。 3.配置3.1 集成Spring对于和Spring的集成Activiti做的不错，简单配置一些Bean代理即可实现，但是有两个和事务相关的地方要提示： 配置 processEngineConfiguration 的时候属性 transactionManager 要使用和业务功能的同一个事务管理Bean，否则事务不同步。 对于实现了org.activiti.engine.delegate包中的接口的类需要被事务控制的实现类需要被Spring代理，并且添加事务的Annotation或者在xml中配置，例如: /** * 创建缴费流程的时候自动创建实体 * * @author HenryYan */ @Service @Transactional publicclass CreatePaymentProcessListener implementsExecutionListener { .... } 4.使用单元测试单元测试均使用Spring的AbstractTransactionalJUnit4SpringContextTests作为SuperClass，并且在测试类添加： @ContextConfiguration(locations = { &quot;/applicationContext-test.xml&quot;}) @RunWith(SpringJUnit4ClassRunner.class) 虽然Activiti也提供了测试的一些超类，但是感觉不好用，所以自己封装了一些方法。 代码请转移： https://gist.github.com/2182847 4.1 验证流程图设计是否正确代码请转移： https://gist.github.com/2182869 4.2 业务对象和流程关联测试代码请转移： https://gist.github.com/2182973 5.各种状态的任务查询以及和业务对象关联我们目前分为4中状态：未签收、办理中、运行中、已完成。 查询到任务或者流程实例后要显示在页面，这个时候需要添加业务数据，最终结果就是业务和流程的并集，请参考 6.2 。 5.1 未签收(Task)此类任务针对于把Task分配给一个角色时，例如部门领导，因为 部门领导 角色可以指定多个人所以需要先签收再办理，术语： 抢占式 对应的API查询： /** * 获取未签收的任务查询对象 * @param userId 用户ID */ @Transactional(readOnly = true) publicTaskQuery createUnsignedTaskQuery(String userId) { TaskQuery taskCandidateUserQuery = taskService.createTaskQuery().processDefinitionKey(getProcessDefKey()) .taskCandidateUser(userId); returntaskCandidateUserQuery; } 5.2 办理中(Task)此类任务数据类源有两种: 签收后的，5.1中签收后就应该为办理中状态 节点指定的是具体到一个人，而不是角色 对应的API查询： /** * 获取正在处理的任务查询对象 * @param userId 用户ID */ @Transactional(readOnly = true) publicTaskQuery createTodoTaskQuery(String userId) { TaskQuery taskAssigneeQuery = taskService.createTaskQuery().processDefinitionKey(getProcessDefKey()).taskAssignee(userId); returntaskAssigneeQuery; } 5.3 运行中(ProcessInstance)说白了就是没有结束的流程，所有参与过的人都应该可以看到这个实例，但是Activiti的API没有可以通过用户查询的方法，这个只能自己用hack的方式处理了，我目前还没有处理。 从表 ACT_RU_EXECUTION 中查询数据。 对应的API查询： /** * 获取未经完成的流程实例查询对象 * @param userId 用户ID */ @Transactional(readOnly = true) publicProcessInstanceQuery createUnFinishedProcessInstanceQuery(String userId) { ProcessInstanceQuery unfinishedQuery = runtimeService.createProcessInstanceQuery().processDefinitionKey(getProcessDefKey()) .active(); returnunfinishedQuery; } 5.4 已完成(HistoricProcessInstance)已经结束的流程实例。 从表 ACT_HI_PROCINST 中查询数据。 /** * 获取已经完成的流程实例查询对象 * @param userId 用户ID */ @Transactional(readOnly = true) publicHistoricProcessInstanceQuery createFinishedProcessInstanceQuery(String userId) { HistoricProcessInstanceQuery finishedQuery = historyService.createHistoricProcessInstanceQuery() .processDefinitionKey(getProcessDefKey()).finished(); returnfinishedQuery; } 5.5 查询时和业务关联提示：之前在业务对象添加了 PROCESS_INSTANCE_ID 字段 思路：现在可以利用这个字段查询了，不管是Task还是ProcessInstance都可以得到流程实例ID，可以根据流程实例ID查询实体然后把流程对象设置到实体的一个属性中由Action或者Controller输出到前台。 代码请参考： https://gist.github.com/2183557 6.UI及截图结合实际业务描述一个业务从开始到结束的过程，对于迷惑的同学看完豁然开朗了；这里使用请假作为例子。 6.1 单独一个列表负责申请这样的好处是申请和流程办理分离开处理，列表显示未启动流程的请假记录（数据库PROCESS_INSTANCE_ID为空）。 申请界面的截图： 6.2 流程状态 6.3 流程跟踪图片方式显示当前节点： 列表形式显示流程流转过程: 6.3.1 当前节点定位JS Java 代码请移步： https://gist.github.com/2183712 Javascript 思路：先通过Ajax获取当前节点的坐标，在指定位置添加红色边框，然后加载图片。 代码移步： https://gist.github.com/2183804 7.开启Logger 添加log4j的jar 设置 log4j.logger.java.sql =DEBUG 8.结束之前就想写这篇文章，现在终于完成了，花费了几个小时，希望能节省你几天的时间。 请读者仔细阅读Activiti的用户手册和Javadoc。","categories":[],"tags":[]},{"title":"ActiveMQ笔记(7)：如何清理无效的延时消息？","slug":"ActiveMQ笔记(7)：如何清理无效的延时消息？","date":"2018-04-19T16:34:21.413Z","updated":"2018-04-19T16:29:59.329Z","comments":true,"path":"2018/04/20/ActiveMQ笔记(7)：如何清理无效的延时消息？/","link":"","permalink":"https://www.itchina.top/2018/04/20/ActiveMQ笔记(7)：如何清理无效的延时消息？/","excerpt":"","text":"ActiveMQ的延时消息是一个让人又爱又恨的功能，具体使用可参考上篇 ActiveMQ笔记(6)：消息延时投递 ，在很多需要消息延时投递的业务场景十分有用，但是也有一个缺陷，在一些大访问量的场景，如果瞬间向MQ发送海量的延时消息，超过MQ的调度能力，就会造成很多消息到了该投递的时刻，却没有投递出去，形成积压，一直停留在ActiveMQ web控制台的Scheduled面板中。 下面的代码演示了，如何清理activemq中的延时消息（包括：全部清空及清空指定时间段的延时消息），这也是目前唯一可行的办法。 为了演示方便，先封装一个小工具类： + View Code ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 package cn.mwee.utils.mq; import cn.mwee.utils.list.ListUtil; import cn.mwee.utils.log4j2.MwLogger; import org.apache.commons.lang.StringUtils; import org.slf4j.Logger; import org.springframework.jms.core.JmsTemplate; import org.springframework.jms.core.MessagePostProcessor; import javax.jms.ConnectionFactory; import javax.jms.JMSException; import javax.jms.TextMessage; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors; /** * Created by yangjunming on 6/20/16. */ public final class MessageUtil { private Logger logger = new MwLogger(MessageUtil. class ); //这里就是一个Log4j2的实例,大家可以换成原生的log4j2或类似工具 private ConnectionFactory connectionFactory; private long receiveTimeout; //接收超时时间 private JmsTemplate jmsTemplate; private List&lt;String&gt; destinationQueueNames; private final static String BACKUP_QUEUE_SUFFIX = &quot;_B&quot;; private boolean autoBackup = false ; //是否自动将消息备份到_b的队列，方便调试 public MessageUtil( final ConnectionFactory connectionFactory, final long receiveTimeout, final List&lt;String&gt; destinationQueueNames) { this .connectionFactory = connectionFactory; this .receiveTimeout = receiveTimeout; this .destinationQueueNames = new ArrayList&lt;&gt;(); this .destinationQueueNames.addAll(destinationQueueNames.stream().co llect(Collectors.toList())); jmsTemplate = new JmsTemplate( this .connectionFactory); jmsTemplate.setReceiveTimeout( this .receiveTimeout); } public MessageUtil(ConnectionFactory connectionFactory, List&lt;String&gt; destinationQueueNames) { this (connectionFactory, 10000 , destinationQueueNames); } public void convertAndSend(Object message) { if (ListUtil.isEmpty(destinationQueueNames)) { logger.error( &quot;目标队列为空，无法发送，请检查配置！message =&gt; &quot; \\+ message.toString()); return ; } for (String dest : destinationQueueNames) { jmsTemplate.convertAndSend(dest, message); if (autoBackup) { jmsTemplate.convertAndSend(dest + BACKUP_QUEUE_SUFFIX, message); } } } public void convertAndSend(Object message, MessagePostProcessor messagePostProcessor) { if (ListUtil.isEmpty(destinationQueueNames)) { logger.error( &quot;目标队列为空，无法发送，请检查配置！message =&gt; &quot; \\+ message.toString()); return ; } for (String dest : destinationQueueNames) { jmsTemplate.convertAndSend(dest, message, messagePostProcessor); if (autoBackup) { jmsTemplate.convertAndSend(dest + BACKUP_QUEUE_SUFFIX, message, messagePostProcessor); } } } public void convertAndSend(String destinationName, Object message) { if (StringUtils.isBlank(destinationName)) { logger.error( &quot;目标队列为空，无法发送，请检查配置！message =&gt; &quot; \\+ message.toString()); return ; } jmsTemplate.convertAndSend(destinationName, message); if (autoBackup) { jmsTemplate.convertAndSend(destinationName + BACKUP_QUEUE_SUFFIX, message); } } public void convertAndSend(String destinationName, Object message, MessagePostProcessor messagePostProcessor) { if (StringUtils.isBlank(destinationName)) { logger.error( &quot;目标队列为空，无法发送，请检查配置！message =&gt; &quot; \\+ message.toString()); return ; } jmsTemplate.convertAndSend(destinationName, message, messagePostProcessor); if (autoBackup) { jmsTemplate.convertAndSend(destinationName + BACKUP_QUEUE_SUFFIX, message, messagePostProcessor); } } public static String getText(javax.jms.Message message) { if (message instanceof TextMessage) { try { return ((TextMessage) message).getText(); } catch (JMSException e) { return message.toString(); } } return message.toString(); } public String getFirstDestination() { if (ListUtil.isEmpty(destinationQueueNames)) { return null ; } return destinationQueueNames.get( 0 ); } public boolean isAutoBackup() { return autoBackup; } public void setAutoBackup( boolean autoBackup) { this .autoBackup = autoBackup; } } 其中主要就用到了convertAndSend(Object message, MessagePostProcessormessagePostProcessor) 这个方法，其它代码可以无视。 先来模拟瞬间向MQ发送大量延时消息： ? 1 2 3 4 5 6 7 8 9 10 11 /** * 发送延时消息 * * @param messageUtil */ private static void sendScheduleMessage(MessageUtil messageUtil) { for ( int i = 0 ; i &lt; 10000 ; i++) { Object obj = &quot;test:&quot; \\+ i; messageUtil.convertAndSend(obj, new ScheduleMessagePostProcessor( 1000 \\+ i * 1000 )); } } 这里向MQ发送了1w条延时消息，每条消息延时1秒*i，上面代码中的ScheduleMessagePostProcessor类可在上篇中找到。 运行完之后，MQ中应该堆积着了很多消息了： 下面的代码可以清空所有延时消息： ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 删除所有延时消息 * * @param connectionFactory * @throws JMSException */ private static void deleteAllScheduleMessage( final ConnectionFactory connectionFactory) throws JMSException { Connection conn = connectionFactory.createConnection(); Session session = conn.createSession( false , Session.AUTO_ACKNOWLEDGE); Destination management = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION); MessageProducer producer = session.createProducer(management); Message request = session.createMessage(); request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL); producer.send(request); } 清空所有延时消息，有些用力过猛了，很多时候，我们只需要清理掉过期的延时消息（即：本来计划是8:00投递出去的消息，结果过了8点还没投递出去） ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 删除过期的延时消息 * * @param connectionFactory * @throws JMSException */ private static void deleteExpiredScheduleMessage( final ConnectionFactory connectionFactory) throws JMSException { long start = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(12 ); //删除：当前时间前12小时范围的延时消息 long end = System.currentTimeMillis(); Connection conn = connectionFactory.createConnection(); Session session = conn.createSession( false , Session.AUTO_ACKNOWLEDGE); Destination management = session.createTopic(ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION); MessageProducer producer = session.createProducer(management); Message request = session.createMessage(); request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION, ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL); request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_START_TIME, Long.toString(start)); request.setStringProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_END_TIME, Long.toString(end)); producer.send(request); } 与上一段代码基本相似，只是多指定了删除消息的起止时间段。 最后贴一段spring的配置文件及main函数入口 1 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 2 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 3 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 4 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 5 6 &lt;bean id=&quot;jmsFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt; 7 &lt;property name=&quot;connectionFactory&quot;&gt; 8 &lt;bean class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; 9 &lt;property name=&quot;brokerURL&quot; 10 value=&quot;failover:(tcp://localhost:61616,tcp://localhost:61626)?randomize=false&amp;amp;backup=true&quot;/&gt; 11 &lt;property name=&quot;maxThreadPoolSize&quot; value=&quot;100&quot;/&gt; 12 &lt;/bean&gt; 13 &lt;/property&gt; 14 &lt;/bean&gt; 15 16 &lt;bean id=&quot;messageUtil&quot; class=&quot;cn.mwee.utils.mq.MessageUtil&quot;&gt; 17 &lt;constructor-arg index=&quot;0&quot; ref=&quot;jmsFactory&quot;/&gt; 18 &lt;constructor-arg index=&quot;1&quot; value=&quot;10000&quot;/&gt; 19 &lt;constructor-arg index=&quot;2&quot;&gt; 20 &lt;list&gt; 21 &lt;value&gt;dest1&lt;/value&gt; 22 &lt;value&gt;dest2&lt;/value&gt; 23 &lt;/list&gt; 24 &lt;/constructor-arg&gt; 25 &lt;property name=&quot;autoBackup&quot; value=&quot;true&quot;/&gt; 26 &lt;/bean&gt; 27 28 &lt;/beans&gt; main函数： 1 2 3 4 5 6 7 8 public static void main(String[] args) throws InterruptedException, JMSException { ApplicationContext context = new ClassPathXmlApplicationContext( &quot;spring-sender.xml&quot; ); ConnectionFactory connectionFactory = context.getBean(ConnectionFactory. class , &quot;jmsFactory&quot; ); MessageUtil messageUtil = context.getBean(MessageUtil. class ); // sendScheduleMessage(messageUtil); // deleteAllScheduleMessage(connectionFactory); deleteExpiredScheduleMessage(connectionFactory); } 参考文章： Enhanced JMS Scheduler in ActiveMQ","categories":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://www.itchina.top/categories/ActiveMQ/"}],"tags":[{"name":"activemq","slug":"activemq","permalink":"https://www.itchina.top/tags/activemq/"}]},{"title":"ActiveMQ笔记(6)：消息延时投递","slug":"ActiveMQ笔记(6)：消息延时投递","date":"2018-04-19T16:34:21.413Z","updated":"2018-04-19T16:29:59.783Z","comments":true,"path":"2018/04/20/ActiveMQ笔记(6)：消息延时投递/","link":"","permalink":"https://www.itchina.top/2018/04/20/ActiveMQ笔记(6)：消息延时投递/","excerpt":"","text":"在开发业务系统时，某些业务场景需要消息定时发送或延时发送（类似：飞信的短信定时发送需求），这时候就需要用到activemq的消息延时投递，详细的文档可参考 官网说明 ，本文只介绍二种常用的用法： 注：本文采用spring的JmsTemplate来发送消息 步骤1、 首先要修改activemq.xml配置文件，启用延时投递 1 &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; ... schedulerSupport=&quot;true&quot; &gt; 2 ... 3 &lt;/broker&gt; 即：在broker节点加上schedulerSupport=”true”，然后重启activemq即可 步骤2、 定义一个MessagePostProcessor的实现类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import javax.jms.JMSException; import javax.jms.Message; import lombok.Data; import org.apache.activemq.ScheduledMessage; import org.apache.commons.lang3.StringUtils; import org.springframework.jms.core.MessagePostProcessor; /** * MQ延时投递处理器（注：ActiveMQ的配置文件中，要配置schedulerSupport=&quot;true&quot;，否则不起作用） * by: 杨俊明 2016-06-16 */ @Data public class ScheduleMessagePostProcessor implements MessagePostProcessor { private long delay = 0l; private String corn = null ; public ScheduleMessagePostProcessor( long delay) { this .delay = delay; } public ScheduleMessagePostProcessor(String cron) { this .corn = cron; } public Message postProcessMessage(Message message) throws JMSException { if (delay &gt; 0 ) { message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay); } if (!StringUtils.isEmpty(corn)) { message.setStringProperty(ScheduledMessage.AMQ_SCHEDULED_CRON, corn); } return message; } } 步骤3、 jmsTemplate发送示例 1 2 3 4 5 6 7 8 9 10 11 12 13 Object message1 = &quot;corn消息内容：&quot; \\+ DateUtil.formatDate( new Date()); //分 时 天 月 星期几 jmsTemplate.convertAndSend(message1, new ScheduleMessagePostProcessor( &quot;40 22 * * *&quot; )); logger.info( &quot;消息1：[&quot; \\+ message1 + &quot;] 延时发送成功！&quot; ); jmsTemplate.convertAndSend(message1, new ScheduleMessagePostProcessor( &quot;50 22 * * *&quot; )); logger.info( &quot;消息1：[&quot; \\+ message1 + &quot;] 延时发送成功！&quot; ); Object message2 = &quot;message：&quot; \\+ DateUtil.formatDate( new Date()); jmsTemplate.convertAndSend(message2, new ScheduleMessagePostProcessor( 30 * 1000 )); //延时30秒 jmsTemplate.convertAndSend(message2, new ScheduleMessagePostProcessor( 3600 * 24 * 1000 )); //延时24小时 logger.info( &quot;消息2：[&quot; \\+ message2 + &quot;] 延时发送成功！&quot; ); 上面的代码演示了二种延时的用法：延时N毫秒、按corn表达式延时（注：此corn表达式并非Quartz框架中的corn表达式，而是linux中corntab中的表达 式，基本顺序是”分(0-59) 时(0-23) 日(1-31) 月（1-12） 星期几(1-7) “） 发送成功后，可以登录activemq的webconsole查看消息的属性： 在scheduled面板中，可以看到延时的消息 注：在开启消息持久化存储的前提下，就算把相应的queue在webconsole面板中删除（即删除队列），只要投递的时间尚未到，该消息也不会删除，仍然能正常延时投递。 此外，在queues面板中，如何查看某条具体的消息，也可以通过属性发现这条消息是延时消息，参考下图： 参考文章：1、 Delay and Schedule Message Delivery 2、 喂鸡百科上的Corn表达式解释 （中文） 3、 喂鸡百科上的Corn表达式解释 （英文） 4、kahaDB官方文档","categories":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://www.itchina.top/categories/ActiveMQ/"}],"tags":[{"name":"activemq","slug":"activemq","permalink":"https://www.itchina.top/tags/activemq/"}]},{"title":"ActiveMQ笔记(5)：JMX监控","slug":"ActiveMQ笔记(5)：JMX监控","date":"2018-04-19T16:34:21.412Z","updated":"2018-04-19T16:30:00.260Z","comments":true,"path":"2018/04/20/ActiveMQ笔记(5)：JMX监控/","link":"","permalink":"https://www.itchina.top/2018/04/20/ActiveMQ笔记(5)：JMX监控/","excerpt":"","text":"系统上线运行后，及时监控报警是很必要的手段，对于ActiveMQ而言，主要监控的指标有:MQ本身的健康状况、每个队列的生产者数量、消费者数量、队列的当前消息数等。 ActiveMQ支持JMX监控，使用步骤如下： 一、 修改conf/activemq.xml &lt;broker … useJmx=&quot;true”&gt; &lt;managementContext&gt; &lt;managementContext createConnector=&quot;true&quot; connectorPort=“jmx端口号” connectorHost=“本机ip地址&quot; /&gt; &lt;/managementContext&gt; &lt;/broker&gt; 二、 设置jmx.access、jmx.password的文件权限 ? 1 chmod 400 conf /jmx .* (即：将jmx.password, jmx.access这二个文件设置成只读权限，activemq出于安全考虑，要求这二个文件只读) 三、 修改bin\\activemq 启动shell脚本 找到invoke_start(){ 这段，然后在前面插入： ? 1 2 3 4 5 ACTIVEMQ_CONF=“jmx.password所在位置的物理路目录&quot; ACTIVEMQ_SUNJMX_START= &quot;-Dcom.sun.management.jmxremote.port=端口号 &quot; ACTIVEMQ_SUNJMX_START= &quot;$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.password.file=${ACTIVEMQ_CONF}/jmx.password&quot; ACTIVEMQ_SUNJMX_START= &quot;$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.access.file=${ACTIVEMQ_CONF}/jmx.access&quot; ACTIVEMQ_SUNJMX_START= &quot;$ACTIVEMQ_SUNJMX_START -Dcom.sun.management.jmxremote.ssl=false&quot; 然后重启activemq即可。 然后在jconsole中，可以输入 ip地址:jmx端口号 其中username,password即jmx.password中定义的用户名和密码。 四、 spring中使用JMX &lt;bean class=&quot;org.springframework.jmx.support.MBeanServerConnectionFactoryBean&quot; id=&quot;mbeanServerConnection1&quot;&gt; &lt;property name=&quot;serviceUrl&quot; value=&quot;${mq_jmx_url1}&quot;/&gt; &lt;property name=&quot;connectOnStartup&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;environment&quot;&gt; &lt;props&gt; &lt;prop key=&quot;java.naming.security.principal&quot;&gt; ${mq_jmx_user1} &lt;/prop&gt; &lt;prop key=&quot;java.naming.security.credentials&quot;&gt; ${mq_jmx_passwor1} &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 其中serviceUrl的值类似：service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi 参考示例： ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private List&lt;ActiveMQData&gt; getMonitorDataList(MBeanServerConnection conn, String objectName) { List&lt;ActiveMQData&gt; datas = new ArrayList&lt;&gt;(); try { ObjectName objRootName = new ObjectName(objectName); String brokerName = (String) conn.getAttribute(objRootName, &quot;BrokerName&quot; ); String brokerId = (String) conn.getAttribute(objRootName, &quot;BrokerId&quot; ); String openWireUrl = (String) conn.getAttribute(objRootName, &quot;OpenWireURL&quot; ); // 健康状态 ObjectName healthObjName = new ObjectName(objectName + &quot;,service=Health&quot; ); String healthStatus = (String) conn.getAttribute(healthObjName, &quot;CurrentStatus&quot; ); // 遍历队列 ObjectName[] objectNames = (ObjectName[]) conn.getAttribute(objRootName, &quot;Queues&quot; ); Arrays. sort (objectNames); List&lt;String&gt; blackList = monitorConfig.getQueueBlackList(); for (ObjectName queueName : objectNames) { ... Long queueSize = (Long) conn.getAttribute(queueName, &quot;QueueSize&quot; ); // 队列消息数量 Long producerCount = (Long) conn.getAttribute(queueName, &quot;ProducerCount&quot; ); // 生产者数量 Long consumerCount = (Long) conn.getAttribute(queueName, &quot;ConsumerCount&quot; ); // 消费者数量 Long enqueueCount = (Long) conn.getAttribute(queueName, &quot;EnqueueCount&quot; ); // 入队消息总数 Long dequeueCount = (Long) conn.getAttribute(queueName, &quot;DequeueCount&quot; ); // 出队消息总数 ... } } catch (Exception e) { ... } return datas; } 其中objectName值，可以在jconsole中查到","categories":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://www.itchina.top/categories/ActiveMQ/"}],"tags":[{"name":"activemq","slug":"activemq","permalink":"https://www.itchina.top/tags/activemq/"},{"name":"jmx","slug":"jmx","permalink":"https://www.itchina.top/tags/jmx/"}]},{"title":"ActiveMQ笔记(3)：基于Networks of Brokers的HA方案","slug":"ActiveMQ笔记(3)：基于Networks of Brokers的HA方案","date":"2018-04-19T16:34:21.411Z","updated":"2018-04-19T16:30:01.556Z","comments":true,"path":"2018/04/20/ActiveMQ笔记(3)：基于Networks of Brokers的HA方案/","link":"","permalink":"https://www.itchina.top/2018/04/20/ActiveMQ笔记(3)：基于Networks of Brokers的HA方案/","excerpt":"","text":"上一篇介绍了基于ZK的ActiveMQ HA方案 ，虽然理解起来比较容易，但是有二个不足： 1) 占用的节点数过多，1个zk集群至少3个节点，1个activemq集群也至少得3个节点，但其实正常运行时，只有一个master节点在对外响应，换句话说，花6个节点的成本只为了保证1个activemq master节点的高可用，太浪费资源了。 2) 性能下降太明显，比起单节点的activemq，性能下降了近1个数量级。 这一篇将介绍基于networks ofbrokers的HA方案，不需要借助zk等第3方组件，只需要2个activemq节点就能达到类似效果，进入正题之前，先来简单谈谈Broker这个概念。 Broker一词的原意是『 经纪人、中间人 』，用在ActiveMQ的构架中，即：Broker作为Producer与Consumer的中间人(或代理人)，生产者不用知道消费者在哪里、如何消费这些细节，只要将消息扔给中间人Broker即可，类似的，消费者也不用关心消息是从哪个生产者过来的，它只知道这是从Broker那里拿来的，如果画一张图来描述，就是下面这样（引用自本文最后参考文章中的图片） 那么，当生产者将消息发给Broker时，会发生什么？下图描述的就是这个过程： 1) 生产者将消息发给Broker 2) Broker将消息落地存储 3) 然后给生产者反馈：事情我已经办妥了！ 继续，再来看看消费者又是如何跟Broker打交道的： 1) Broker将接收到的消息，从db中取出 2) 然后发送给消费者 3)如果消费者使用的是自动确认模式(即：Session.AUTO_ACKNOWLEDGE），则Consumer会马上告诉Broker：ok，消息我已经收到了。 4) 然后进行自己的业务处理 5) Broker一旦收到确认，将会马上更新消息的状态为已消费(或直接删除，取决于持久化的实现机制）（注：虽然图中步骤5排在步骤4之后，但是步骤4、5几乎是同时发生的） 在一些大型应用中，如果一个Broker出现性能瓶颈抗不住压力，可能会拆分成多个Broker，如下图所示： (注：上图中箭头的方法并非数据流向，而应该理解成调用关系，即：Producer调用Broker1，Consumer调用Broker2…) Producer将消息发送给Broker1，而Consumer从另一个Broker2接收消息，有点类似数据库读写分离的意思，这样系统的性能可以提升一定程度的提升，但是问题来了，Broker1上的消息，如何 “同步”（见下面的注释） 到Broker2呢，这就依赖networkConnector的配置。 注： _ 同步这个词用在这里可能不太准确，但也找不到一个更精确的词来描述，实际上，二个broker用上述机制组建成小集群后，如果生产者连接到broker1，消费者连接到broker2，当消息发送到broker1后，broker1不会将该消息复制一份到broker2，而是等消费者从broker2上消费该消息时，这条消息才从broker1取到broker2上，相当于此时broker2是消费者，从broker1消费了一条消息，然后broker2上就有这条消息了，最终消费者才能broker2上拿到这条消息。 _ 1 &lt;beans 2 xmlns=&quot;http://www.springframework.org/schema/beans&quot; 3 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 4 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 5 http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd&quot;&gt; 6 7 &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; 8 &lt;property name=&quot;locations&quot;&gt; 9 &lt;value&gt;file:${activemq.conf}/credentials.properties&lt;/value&gt; 10 &lt;/property&gt; 11 &lt;/bean&gt; 12 13 &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;activemq-1&quot;&gt; 14 &lt;networkConnectors&gt; 15 &lt;networkConnector uri=&quot;static:(tcp://127.0.0.1:61626)&quot;/&gt; 16 &lt;/networkConnectors&gt; 17 &lt;persistenceAdapter&gt; 18 &lt;kahaDB directory=&quot;${activemq.data}/kahadb&quot;/&gt; 19 &lt;/persistenceAdapter&gt; 20 &lt;transportConnectors&gt; 21 &lt;transportConnector name=&quot;openwire&quot; 22 uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; 23 &lt;/transportConnectors&gt; 24 &lt;/broker&gt; 25 26 &lt;import resource=&quot;jetty.xml&quot;/&gt; 27 &lt;/beans&gt; View Code 注意：14-16行及21-22行，该Broker对外暴露616 1 6端口，同时”连接”到616 2 6端口（即另1个broker）,最终的效果相当于，如果有producer把消息发到616 1 6（broker1）,则从另一个broker(616 2 6端口)上也能消费这条消息。 明白这些基本原理后，在61626对应的activemq上，也做类似的配置，只不过”连接方向”正好相反，参考以下配置： 1 &lt;beans 2 xmlns=&quot;http://www.springframework.org/schema/beans&quot; 3 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 4 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 5 http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd&quot;&gt; 6 7 &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; 8 &lt;property name=&quot;locations&quot;&gt; 9 &lt;value&gt;file:${activemq.conf}/credentials.properties&lt;/value&gt; 10 &lt;/property&gt; 11 &lt;/bean&gt; 12 13 &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;activemq-2&quot;&gt; 14 &lt;networkConnectors&gt; 15 &lt;networkConnector uri=&quot;static:(tcp://127.0.0.1:61616)&quot;/&gt; 16 &lt;/networkConnectors&gt; 17 &lt;persistenceAdapter&gt; 18 &lt;kahaDB directory=&quot;${activemq.data}/kahadb&quot;/&gt; 19 &lt;/persistenceAdapter&gt; 20 &lt;transportConnectors&gt; 21 &lt;transportConnector name=&quot;openwire&quot; 22 uri=&quot;tcp://0.0.0.0:61626?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; 23 &lt;/transportConnectors&gt; 24 &lt;/broker&gt; 25 26 &lt;import resource=&quot;jetty.xml&quot;/&gt; 27 &lt;/beans&gt; View Code (注：如果希望2个activemq上都能访问admin管理界面，jetty.xml中的端口要修改，不要冲突) 这样，activemq-1与activemq-2这二个broker就互为主备，发给你的消息会同步到我，发给我的消息也会同步到你，实现了HA，示意图如下： Producer与Consumer连接到activemq时，配置文件可以这么写： 1 &lt;bean id=&quot;jmsFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt; 2 &lt;property name=&quot;connectionFactory&quot;&gt; 3 &lt;bean class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; 4 &lt;!--broker服务的地址--&gt; 5 &lt;property name=&quot;brokerURL&quot; value=&quot;failover:(tcp://localhost:61616,tcp://localhost:61626)&quot;/&gt; 6 ... 7 &lt;/bean&gt; 8 &lt;/property&gt; 9 &lt;/bean&gt; 这种HA方案的优点是占用的节点数更少(只需要2个节点),而且2个broker都可以响应消息的接收与发送，性能比zookeeper方案要好一些。 最后，再给一个简化配置的技巧，以上述的2节点HA方案中，二个activemq的配置文件都要加networkConnector配置，如果想减轻配置的工作量，也可以只在其中一个activemq设置，参考以下片段： &lt;networkConnectors&gt; &lt;networkConnector uri=&quot;static:(tcp://127.0.0.1:61626)&quot; duplex=&quot;true&quot;/&gt; &lt;/networkConnectors&gt; 即：在61616这个activemq的配置文件中，添加networkConnector时，增加 duplex=”true” ，也就是双工通讯的意思，这样61616与61626这二个activemq上的broker就建立了双向通讯连接，另一个activemq上就无需额外配置了（注：如果在61626上配置了，反而会报错） 参考文章： http://www.jakubkorab.net/2011/11/understanding-activemq-broker-networks.html http://activemq.apache.org/networks-of-brokers.html 最后 贴二段程序运行的输出日志，以说明同步机制的正确性，打消回复中“大鹏520”的顾虑： 背景： ...15 与 ...16 作为HA(双主)的activemq集群，发送程序只连接到15发消息，然后退出。接收程序只从16上收消息，如果收到了，表明15上的消息同步到16。 下面是 发送程序 的输出片段：（注意输出日志中关于IP的部分，这是只连接到...[b]15[/b]上发送的）(注：部分敏感信息，比如真实IP前缀，公司package名，用代替了) _ 14:53:09,996 &lt;.DemoSender&gt; INFO [main]: 准备发送消息… __ 14:53:10,270 &lt;org.apache.activemq.transport.WireFormatNegotiator&gt; DEBUG[main]: Sending: WireFormatInfo { version=11,properties={TcpNoDelayEnabled=true, SizePrefixDisabled=false, CacheSize=1024,StackTraceEnabled=true, CacheEnabled=true, TightEncodingEnabled=true,MaxFrameSize=9223372036854775807, Host=...15, MaxInactivityDuration=30000,MaxInactivityDurationInitalDelay=10000}, magic=[A,c,t,i,v,e,M,Q]} __ 14:53:10,306 &lt;org.apache.activemq.transport.InactivityMonitor&gt; DEBUG[ActiveMQ Transport: tcp:///... 15 :61616@50616]: Using min oflocal: WireFormatInfo { version=11, properties={TcpNoDelayEnabled=true,SizePrefixDisabled=false, CacheSize=1024, StackTraceEnabled=true,CacheEnabled=true, TightEncodingEnabled=true,MaxFrameSize=9223372036854775807, Host=...15, MaxInactivityDuration=30000,MaxInactivityDurationInitalDelay=10000}, magic=[A,c,t,i,v,e,M,Q]} and remote:WireFormatInfo { version=11, properties={TcpNoDelayEnabled=true,SizePrefixDisabled=false, CacheSize=1024, StackTraceEnabled=true,CacheEnabled=true, TightEncodingEnabled=true, MaxFrameSize=104857600,MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000},magic=[A,c,t,i,v,e,M,Q]} __ 14:53:10,306 &lt;org.apache.activemq.transport.WireFormatNegotiator&gt; DEBUG[ActiveMQ Transport: tcp:///... 15 :61616@50616]: ReceivedWireFormat: WireFormatInfo { version=11, properties={TcpNoDelayEnabled=true,SizePrefixDisabled=false, CacheSize=1024, StackTraceEnabled=true,CacheEnabled=true, TightEncodingEnabled=true, MaxFrameSize=104857600,MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000},magic=[A,c,t,i,v,e,M,Q]} __ 14:53:10,306 &lt;org.apache.activemq.transport.WireFormatNegotiator&gt; DEBUG[ActiveMQ Transport: tcp:///... 15 :61616@50616]:tcp:///...15:61616@50616 before negotiation: OpenWireFormat{version=11,cacheEnabled=false, stackTraceEnabled=false, tightEncodingEnabled=false,sizePrefixDisabled=false, maxFrameSize=9223372036854775807} __ 14:53:10,307 &lt;org.apache.activemq.transport.WireFormatNegotiator&gt; DEBUG[ActiveMQ Transport: tcp:///... 15 :61616@50616]:tcp:///...15:61616@50616 after negotiation: OpenWireFormat{version=11,cacheEnabled=true, stackTraceEnabled=true, tightEncodingEnabled=true,sizePrefixDisabled=false, maxFrameSize=104857600} __ 14:53:10,416 &lt;org.springframework.jms.core.JmsTemplate&gt; DEBUG [main]:Executing callback on JMS Session: PooledSession { ActiveMQSession {id=ID:yangjunmings-MacBook-Pro.local-50615-1461480790088-1:1:1,started=false}java.lang.Object@5a56cdac } __ 14:53:10,471 &lt;org.springframework.jms.core.JmsTemplate&gt; DEBUG [main]:Sending created message: ActiveMQTextMessage {commandId = 0, responseRequired= false, messageId = null, originalDestination = null, originalTransactionId =null, producerId = null, destination = null, transactionId = null, expiration= 0, timestamp = 0, arrival = 0, brokerInTime = 0, brokerOutTime = 0,correlationId = null, replyTo = null, persistent = false, type = null,priority = 0, groupID = null, groupSequence = 0, targetConsumerId = null,compressed = false, userID = null, content = null, marshalledProperties =null, dataStructure = null, redeliveryCounter = 0, size = 0, properties =null, readOnlyProperties = false, readOnlyBody = false, droppable = false,jmsXGroupFirstForConsumer = false, text = message test:0 } __ 14:53:10,516 &lt;.DemoSender&gt; INFO [main]: 消息0发送完成! __ 14:53:11,520 &lt;org.springframework.jms.core.JmsTemplate&gt; DEBUG [main]:Executing callback on JMS Session: PooledSession { ActiveMQSession {id=ID:yangjunmings-MacBook-Pro.local-50615-1461480790088-1:1:1,started=false}java.lang.Object@5a56cdac } __ 14:53:11,521 &lt;org.springframework.jms.core.JmsTemplate&gt; DEBUG [main]:Sending created message: ActiveMQTextMessage {commandId = 0, responseRequired= false, messageId = null, originalDestination = null, originalTransactionId =null, producerId = null, destination = null, transactionId = null, expiration= 0, timestamp = 0, arrival = 0, brokerInTime = 0, brokerOutTime = 0,correlationId = null, replyTo = null, persistent = false, type = null,priority = 0, groupID = null, groupSequence = 0, targetConsumerId = null,compressed = false, userID = null, content = null, marshalledProperties =null, dataStructure = null, redeliveryCounter = 0, size = 0, properties =null, readOnlyProperties = false, readOnlyBody = false, droppable = false,jmsXGroupFirstForConsumer = false, text = message test:1} _ 运行完以后，关掉发送程序，然后启动 接收程序 ： _ 14:54:40,965 &lt;org.apache.activemq.transport.WireFormatNegotiator&gt; DEBUG[main]: Sending: WireFormatInfo { version=11,properties={TcpNoDelayEnabled=true, SizePrefixDisabled=false, CacheSize=1024,StackTraceEnabled=true, CacheEnabled=true, TightEncodingEnabled=true,MaxFrameSize=9223372036854775807, Host=... 16 ,MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000},magic=[A,c,t,i,v,e,M,Q]} __ 14:54:41,002 &lt;org.apache.activemq.transport.InactivityMonitor&gt; DEBUG[ActiveMQ Transport: tcp:///... 16 :61616@50642]: Using min oflocal: WireFormatInfo { version=11, properties={TcpNoDelayEnabled=true,SizePrefixDisabled=false, CacheSize=1024, StackTraceEnabled=true,CacheEnabled=true, TightEncodingEnabled=true,MaxFrameSize=9223372036854775807, Host=... 16 ,MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000},magic=[A,c,t,i,v,e,M,Q]} and remote: WireFormatInfo { version=11,properties={TcpNoDelayEnabled=true, SizePrefixDisabled=false, CacheSize=1024,StackTraceEnabled=true, CacheEnabled=true, TightEncodingEnabled=true,MaxFrameSize=104857600, MaxInactivityDuration=30000,MaxInactivityDurationInitalDelay=10000}, magic=[A,c,t,i,v,e,M,Q]} __ 14:54:41,003 &lt;org.apache.activemq.transport.WireFormatNegotiator&gt; DEBUG[ActiveMQ Transport: tcp:///... 16 :61616@50642]: ReceivedWireFormat: WireFormatInfo { version=11, properties={TcpNoDelayEnabled=true,SizePrefixDisabled=false, CacheSize=1024, StackTraceEnabled=true,CacheEnabled=true, TightEncodingEnabled=true, MaxFrameSize=104857600,MaxInactivityDuration=30000, MaxInactivityDurationInitalDelay=10000},magic=[A,c,t,i,v,e,M,Q]} __ 14:54:41,003 &lt;org.apache.activemq.transport.WireFormatNegotiator&gt; DEBUG[ActiveMQ Transport: tcp:///... 16 :61616@50642]: tcp:///... 16 :61616@50642 before negotiation: OpenWireFormat{version=11,cacheEnabled=false, stackTraceEnabled=false, tightEncodingEnabled=false,sizePrefixDisabled=false, maxFrameSize=9223372036854775807} __ 14:54:41,004 &lt;org.apache.activemq.transport.WireFormatNegotiator&gt; DEBUG[ActiveMQ Transport: tcp:///... 16 :61616@50642]:tcp:///...16:61616@50642 after negotiation: OpenWireFormat{version=11,cacheEnabled=true, stackTraceEnabled=true, tightEncodingEnabled=true,sizePrefixDisabled=false, maxFrameSize=104857600} __ 14:54:41,163 &lt;org.apache.activemq.thread.TaskRunnerFactory&gt; DEBUG [main]:Initialized TaskRunnerFactory[ActiveMQ Session Task] using ExecutorService:java.util.concurrent.ThreadPoolExecutor@485966cc[Running, pool size = 0,active threads = 0, queued tasks = 0, completed tasks = 0] __ 14:54:41,181 &lt;*.DemoListener&gt; INFO [ActiveMQ Session Task-1]: messagetest:0 _ 注意接收程序中IP的部分，这是从...[b]16[/b]上接收到的，说明消息已经从 ...15同步到..*.16上了，否则不可能收到消息。","categories":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://www.itchina.top/categories/ActiveMQ/"}],"tags":[{"name":"activemq","slug":"activemq","permalink":"https://www.itchina.top/tags/activemq/"}]},{"title":"ActiveMQ笔记(4)：搭建Broker集群(cluster)","slug":"ActiveMQ笔记(4)：搭建Broker集群(cluster)","date":"2018-04-19T16:34:21.411Z","updated":"2018-04-19T16:30:00.636Z","comments":true,"path":"2018/04/20/ActiveMQ笔记(4)：搭建Broker集群(cluster)/","link":"","permalink":"https://www.itchina.top/2018/04/20/ActiveMQ笔记(4)：搭建Broker集群(cluster)/","excerpt":"","text":"[ ActiveMQ笔记(4)：搭建Broker集群(cluster)](http://blog.csdn.net/lsy0903/article/details/54862508) 上一篇 介绍了基于Networksof Borkers的2节点HA方案，这一篇继续来折腾Networks of Brokers，当应用规模日渐增长时，2节点的broker可能仍然抗不住访问压力，这时候就需要多加一些broker，弄一个更大规模的Broker集群，但是怎么合理设置broker之间的网络桥接，却是有讲究的，先来看一种不太好的设计： 这个架构看上去没瑕疵，没毛病，3个broker之间两两互通，整体可用性极高，但是从消息的路由角度来看，却不是一个好的设计，当producer向broker1发送一条消息时，Consumer得到消息的路径可能有如下2条： a） producer -&gt; broker1 -&gt; broker2 b） producer -&gt; broker1 -&gt; broker3 -&gt; broker2 当broker更多时，情况会更复杂，比如下面这张图： 消息的路由途径将会更多： a) producer -&gt; broker1 -&gt; broker4 b) producer -&gt; broker1 -&gt; broker2 -&gt; broker4 c) producer -&gt; broker1 -&gt; broker2 -&gt; broker3 -&gt; broker4 d) producer -&gt; broker1 -&gt; broker3 -&gt; broker4 不难想像，每多经过一个节点，消息处理的延时将会增加一些，如果Broker越多，情况越复杂，最终系统对外表现为消息处理有时很快，有时很慢，整体性能很不稳定，所以 实际生产中，不要采用所有Broker之间两两互连的方案 。 合理的方案如下： 这张图的灵感，应该来自组建局域网中的星形网络，在中心放置一个Borker充当Hub，与其它所有Broker互连，这样不管Consumer连接到外围的哪个Broker，消息的路由途径都比较稳定(最多经过3个Broker)，这种架构性能虽然稳定了，但是中心的Hub就变成单点隐患，如果中间的DockerHub挂了，整个系统也就废了。 改进后的架构如下： 本质上仍然是一个星形网络，只不过将hub弄成二个互备，然后每个hub都与其它外围的broker相连，消费者连接到broker1/broker2/broker3，生产者(Producer)连接到hub1/hub2，消息的最长路径不超过3个broker(注：生产者也可以连接到broker1/2/3，与消费者一样，但是消息经过的最长路径会变成4) 如果以后要扩张，比如增加了Broker4,Broker5…，直接修改hub1/2上的配置，增加与新的broker的连接即可，不影响消息的路由途径长度。 最后，在本机演练一把，给出一些配置示例： 1、 端口规划 ? 1 2 3 4 5 activemq1: 61616 (broker1) activemq2: 61626 (broker2) activemq3: 61636 (broker3) activemq4: 61646 (broker-hub1) activemq5: 61656 (broker-hub2) 共5个activemq实例，端口61616、61626、61636为broker1、broker2、broker3，61645、61656为broker-hub1、broker-hub2 2、 activemq.xml配置 以boker1为例，配置文件内容如下： 1 &lt;beans 2 xmlns=&quot;http://www.springframework.org/schema/beans&quot; 3 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 4 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 5 http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd&quot;&gt; 6 7 &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; 8 &lt;property name=&quot;locations&quot;&gt; 9 &lt;value&gt;file:${activemq.conf}/credentials.properties&lt;/value&gt; 10 &lt;/property&gt; 11 &lt;/bean&gt; 12 13 &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;broker1&quot;&gt; 14 &lt;persistenceAdapter&gt; 15 &lt;kahaDB directory=&quot;${activemq.data}/kahadb&quot;/&gt; 16 &lt;/persistenceAdapter&gt; 17 &lt;transportConnectors&gt; 18 &lt;transportConnector name=&quot;openwire&quot; 19 uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; 20 &lt;/transportConnectors&gt; 21 &lt;/broker&gt; 22 23 &lt;import resource=&quot;jetty.xml&quot;/&gt; 24 &lt;/beans&gt; View Code broker2及broker3，大家参考该配置修改端口号及brokerName即可。 broker-hub1的配置： 1 &lt;beans 2 xmlns=&quot;http://www.springframework.org/schema/beans&quot; 3 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 4 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 5 http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd&quot;&gt; 6 7 &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; 8 &lt;property name=&quot;locations&quot;&gt; 9 &lt;value&gt;file:${activemq.conf}/credentials.properties&lt;/value&gt; 10 &lt;/property&gt; 11 &lt;/bean&gt; 12 13 &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;broker-hub1&quot;&gt; 14 &lt;networkConnectors&gt; 15 &lt;networkConnector uri=&quot;static:(tcp://127.0.0.1:61656,tcp://127.0.0.1:61616,tcp://127.0.0.1:61626,tcp://127.0.0.1:61636)&quot; duplex=&quot;true&quot;/&gt; 16 &lt;/networkConnectors&gt; 17 &lt;persistenceAdapter&gt; 18 &lt;kahaDB directory=&quot;${activemq.data}/kahadb&quot;/&gt; 19 &lt;/persistenceAdapter&gt; 20 &lt;transportConnectors&gt; 21 &lt;transportConnector name=&quot;openwire&quot; 22 uri=&quot;tcp://0.0.0.0:61646?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; 23 &lt;/transportConnectors&gt; 24 &lt;/broker&gt; 25 26 &lt;import resource=&quot;jetty.xml&quot;/&gt; 27 &lt;/beans&gt; broker-hub2的配置： 1 &lt;beans 2 xmlns=&quot;http://www.springframework.org/schema/beans&quot; 3 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 4 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 5 http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd&quot;&gt; 6 7 &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; 8 &lt;property name=&quot;locations&quot;&gt; 9 &lt;value&gt;file:${activemq.conf}/credentials.properties&lt;/value&gt; 10 &lt;/property&gt; 11 &lt;/bean&gt; 12 13 &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;broker-hub2&quot;&gt; 14 &lt;networkConnectors&gt; 15 &lt;networkConnector uri=&quot;static:(tcp://127.0.0.1:61616,tcp://127.0.0.1:61626,tcp://127.0.0.1:61636)&quot; duplex=&quot;true&quot;/&gt; 16 &lt;/networkConnectors&gt; 17 &lt;persistenceAdapter&gt; 18 &lt;kahaDB directory=&quot;${activemq.data}/kahadb&quot;/&gt; 19 &lt;/persistenceAdapter&gt; 20 &lt;transportConnectors&gt; 21 &lt;transportConnector name=&quot;openwire&quot; 22 uri=&quot;tcp://0.0.0.0:61656?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; 23 &lt;/transportConnectors&gt; 24 &lt;/broker&gt; 25 26 &lt;import resource=&quot;jetty.xml&quot;/&gt; 27 &lt;/beans&gt; 3、 java代码中spring配置文件 a) 生产者 1 &lt;bean id=&quot;jmsFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt; 2 &lt;property name=&quot;connectionFactory&quot;&gt; 3 &lt;bean class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; 4 &lt;!--broker服务的地址--&gt; 5 &lt;property name=&quot;brokerURL&quot; value=&quot;failover:(tcp://localhost:61646,tcp://localhost:61656)&quot;/&gt; 6 &lt;!--默认值为1000,如果不需要这么大,可以调小--&gt; 7 &lt;property name=&quot;maxThreadPoolSize&quot; value=&quot;100&quot;/&gt; 8 &lt;!--&lt;property name=&quot;userName&quot; value=&quot;system&quot;/&gt;--&gt; 9 &lt;!--&lt;property name=&quot;password&quot; value=&quot;manager&quot;/&gt;--&gt; 10 &lt;/bean&gt; 11 &lt;/property&gt; 12 &lt;/bean&gt; b) 消费者 1 &lt;bean id=&quot;jmsFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt; 2 &lt;property name=&quot;connectionFactory&quot;&gt; 3 &lt;bean class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; 4 &lt;!--broker服务的地址--&gt; 5 &lt;property name=&quot;brokerURL&quot; value=&quot;failover:(tcp://localhost:61616,tcp://localhost:61626,tcp://localhost:61636)&quot;/&gt; 6 &lt;!--默认值为1000,如果不需要这么大,可以调小--&gt; 7 &lt;property name=&quot;maxThreadPoolSize&quot; value=&quot;100&quot;/&gt; 8 &lt;!--&lt;property name=&quot;userName&quot; value=&quot;system&quot;/&gt;--&gt; 9 &lt;!--&lt;property name=&quot;password&quot; value=&quot;manager&quot;/&gt;--&gt; 10 &lt;/bean&gt; 11 &lt;/property&gt; 12 &lt;/bean&gt;","categories":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://www.itchina.top/categories/ActiveMQ/"}],"tags":[{"name":"activemq","slug":"activemq","permalink":"https://www.itchina.top/tags/activemq/"},{"name":"集群","slug":"集群","permalink":"https://www.itchina.top/tags/集群/"}]},{"title":"ActiveMQ笔记(2)：基于ZooKeeper的HA方案","slug":"ActiveMQ笔记(2)：基于ZooKeeper的HA方案","date":"2018-04-19T16:34:21.410Z","updated":"2018-04-19T16:30:01.948Z","comments":true,"path":"2018/04/20/ActiveMQ笔记(2)：基于ZooKeeper的HA方案/","link":"","permalink":"https://www.itchina.top/2018/04/20/ActiveMQ笔记(2)：基于ZooKeeper的HA方案/","excerpt":"","text":"activemq官网给出了3种master/slave的HA方案，详见： http://activemq.apache.org/masterslave.html ，基于共享文件目录，db，zookeeper。 下面演示了如何在本机搭建基于zookeeper的activemq集群： 一、 在目录activemq1下安装activemq(可参考 上篇内容 )，然后修改conf/activemq.xml 1 &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot;&gt; 2 ... 3 &lt;persistenceAdapter&gt; 4 &lt;!--&lt;kahaDB directory=&quot;${activemq.data}/kahadb&quot;/&gt;--&gt; 5 &lt;replicatedLevelDB 6 directory=&quot;activemq-data&quot; 7 replicas=&quot;3&quot; 8 bind=&quot;tcp://0.0.0.0:0&quot; 9 zkAddress=&quot;127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183&quot; 10 zkSessionTimeout=&quot;2s&quot; 11 zkPath=&quot;/activemq/leveldb-stores&quot; 12 /&gt; 13 &lt;/persistenceAdapter&gt; 14 ... 15 &lt;/broker&gt; 注：为保证zk的HA，本机至少要有3个zk的节点，可参考 我以前的文章 搭建. 二、 将activemq1复制二分，变成activemq2、activemq3，由于是在本机测试，为防止端口冲突，这二个目录下的activemq.xml，得修改端口 ? 1 2 3 4 5 6 7 8 9 10 11 12 &lt;transportConnectors&gt; &lt;transportConnector name= &quot;openwire&quot; uri= &quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFram eSize=104857600&quot; /&gt; &lt;transportConnector name= &quot;amqp&quot; uri= &quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFram eSize=104857600&quot; /&gt; &lt;transportConnector name= &quot;stomp&quot; uri= &quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;wireFormat.maxFr ameSize=104857600&quot; /&gt; &lt;transportConnector name= &quot;mqtt&quot; uri= &quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;wireFormat.maxFram eSize=104857600&quot; /&gt; &lt;transportConnector name= &quot;ws&quot; uri= &quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600&quot; /&gt; &lt;/transportConnectors&gt; 上面这几个端口，大家看情况调整，只要保证3个activemq不冲突即可 三、 启动zk1,zk2,zk3，以及activemq1,activemq2,activemq3即可。 注：为方便观察输出，建议启动activemq时，用./activemq.sh console启动 四、 测试Failover 正常启动后，然后手动停掉master，然后观察剩下的2个节点终端输出，正常情况下，应该过一会儿，有一个会自动提升为master. 最后提醒一下：采用上述HA方案后，虽然系统可用性提高了，但是在本机上测试发现，跟 上篇 同样的测试代码和用例，单节点运行时，1秒可以发8k+条消息，采用zookeeper的HA方案后，每秒只能写入500条消息左右，对于性能要求较高的场景，建议采用其它方案，比如下一篇要介绍的 基于Networks of brokers的HA方案 。 参考文章： http://activemq.apache.org/replicated-leveldb-store.html","categories":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://www.itchina.top/categories/ActiveMQ/"}],"tags":[{"name":"activemq","slug":"activemq","permalink":"https://www.itchina.top/tags/activemq/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://www.itchina.top/tags/zookeeper/"}]},{"title":"ActiveMQ笔记(1)：编译、安装、示例代码","slug":"ActiveMQ笔记(1)：编译、安装、示例代码","date":"2018-04-19T16:34:21.409Z","updated":"2018-04-19T16:30:02.639Z","comments":true,"path":"2018/04/20/ActiveMQ笔记(1)：编译、安装、示例代码/","link":"","permalink":"https://www.itchina.top/2018/04/20/ActiveMQ笔记(1)：编译、安装、示例代码/","excerpt":"","text":"一、编译 虽然 ActiveMQ 提供了发布版本，但是建议同学们自己下载源代码编译，以后万一有坑，还可以尝试自己改改源码。 1.1 https://github.com/apache/activemq/releases 到这里下载最新的release版源码（当前最新版本为5.13.2），并解压到某个目录(以下用$ACTIVEMQ_HOME代替解压根目录) 1.2 编译 1 2 cd $ACTIVEMQ_HOME mvn clean install -Dmaven. test .skip= true 编译成功后，在$ACTIVEMQ_HOME /assembly/target下会生成可xxx.bin.tar.gz的可执行文件压缩包 二、启动 将编译后得到的xxx.bin.tar.gz解压，然后执行 ? 1 2 3 tar -zxvf apache-activemq-5.13.2-bin. tar .gz cd apache-activemq-5.13.2 /bin . /activemq start 后面的可选参数还有 status、restart、stop、list等，不清楚的地方，直接 –help 查看。 注： 生产环境中，可能会对activemq的jvm内存设置上限，可以直接修改bin/activemq启动脚本，vi bin/activemq找到下面的位置： ? 1 2 3 4 5 6 # Note: This function uses globally defined variables # - $ACTIVEMQ_PIDFILE : the name of the pid file&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;bash comments&quot;&gt;# - $ACTIVEMQ_OPTS : Additional options ACTIVEMQ_OPTS= &quot;-server -Xms512M -Xmx512M -XX:PermSize=64M -XX:MaxPermSize=128M &quot; # - $ACTIVEMQ_SUNJMX_START : options for JMX settings&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;bash comments&quot;&gt;# - $ACTIVEMQ_SSL_OPTS : options for SSL encryption 设置ACTIVEMQ_OPTS即可，然后重启activemq，建议启动成功后，用jinfo {activemq的pid} 来验证查看一下 三、管理界面 启动成功后，可以浏览 http://localhost:8161/admin/ 默认用户名、密码：admin/admin 管理界面是用jetty做容器的，如果想修改管理界面的端口，可以编辑../conf/jetty.xml，找到下面这一段： &lt;bean id=&quot;jettyPort&quot; class=&quot;org.apache.activemq.web.WebConsolePort&quot; init-method=&quot;start&quot;&gt; &lt;!-- the default port number for the web console --&gt; &lt;property name=&quot;host&quot; value=&quot;0.0.0.0&quot;/&gt; &lt;property name=&quot;port&quot; value=&quot;8161&quot;/&gt; &lt;/bean&gt; 用户名/密码是在 ../conf/jetty-realm.properties 里，比如要增加一个管理员jimmy/123456，可参考下面修改： ? 1 2 3 admin: admin, admin jimmy: 123456, admin user: user, user 注： 管理界面有一个 小坑 ，ActiveMQ 5.13. 2 与jdk1.8兼容性有点问题，如果使用jdk1.8，管理界面进入Queues标签页时，偶尔会报错，但是并不影响消息正常收发，只是无法从界面上查看队列情况，如果出现该问题，可将jdk版本降至1.7，同时最好清空data目录下的所有数据，再重启activemq即可。 2016-06-18 注： 最新版的5.13. 3 已经修复了这个bug，建议大家使用最新版本。 四、示例代码 通常消息队列都支持二种模式：基于主题(topic)的发布(Publish)/订阅(Subscribe)模式、点对点(p2p)模式，下面的示例代码为p2p场景。 先给出gradle项目的依赖项 + View Code ? 1 2 3 4 5 6 7 8 9 dependencies { compile &quot;org.springframework:spring-core:4.2.5.RELEASE&quot; compile &quot;org.springframework:spring-beans:4.2.5.RELEASE&quot; compile &quot;org.springframework:spring-context:4.2.5.RELEASE&quot; compile &quot;org.springframework:spring-jms:4.2.3.RELEASE&quot; compile &#39;org.apache.activemq:activemq-all:5.13.2&#39; compile &#39;org.apache.commons:commons-pool2:2.4.2&#39; testCompile group: &#39;junit&#39; , name: &#39;junit&#39; , version:&#39;4.12&#39; } 4.1 spring配置文件 1 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 2 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 3 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 4 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 5 6 &lt;bean id=&quot;jmsFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt; 7 &lt;property name=&quot;connectionFactory&quot;&gt; 8 &lt;bean class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; 9 &lt;!--broker服务的地址--&gt; 10 &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot;/&gt; 11 &lt;!--默认值为1000,如果不需要这么大,可以调小--&gt; 12 &lt;property name=&quot;maxThreadPoolSize&quot; value=&quot;100&quot;/&gt; 13 &lt;/bean&gt; 14 &lt;/property&gt; 15 &lt;/bean&gt; 16 17 &lt;bean id=&quot;dest&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt; 18 &lt;!--队列名称--&gt; 19 &lt;property name=&quot;physicalName&quot; value=&quot;myQueue&quot;/&gt; 20 &lt;/bean&gt; 21 22 &lt;bean id=&quot;myJmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt; 23 &lt;property name=&quot;connectionFactory&quot; ref=&quot;jmsFactory&quot;/&gt; 24 &lt;!--默认的队列--&gt; 25 &lt;property name=&quot;defaultDestination&quot; ref=&quot;dest&quot;/&gt; 26 &lt;!--接收超时时间10秒--&gt; 27 &lt;property name=&quot;receiveTimeout&quot; value=&quot;10000&quot;/&gt; 28 &lt;/bean&gt; 29 30 &lt;/beans&gt; View Code 注：brokerURL的地址是在conf/activemq.xml里定义里，见下面的片段 1 &lt;transportConnectors&gt; 2 &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt; 3 &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; 4 &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; 5 &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; 6 &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; 7 &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt; 8 &lt;/transportConnectors&gt; View Code 另外，连接ActiveMQ默认情况下，没有任何安全机制，也就是说任何人只要知道brokerURL都能连接，这显然不安全，可以在activemq.xml里，找到节点，紧贴它的地方添加下面这段： &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;${activemq.data}&quot;&gt; &lt;plugins&gt; &lt;simpleAuthenticationPlugin&gt; &lt;users&gt; &lt;authenticationUser username=&quot;${activemq.username}&quot;&lt;/span&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt; password&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;=&quot;${activemq.password}&quot; groups=&quot;users,admins&quot;/&gt; &lt;/users&gt; &lt;/simpleAuthenticationPlugin&gt; &lt;/plugins&gt; ... &lt;/broker&gt; 那么问题来了，这个 activemq.username&#x53CA;” role=”presentation”&gt; a c t i v e mq . u s e r n a m e 及 activemq.username及{activemq.password}的值是在哪里定义的呢？仍然在activemq.xml里找答案，在最开始的地方有一段： 1 &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; 2 &lt;property name=&quot;locations&quot;&gt; 3 &lt;value&gt;file:${activemq.conf}/credentials.properties&lt;/value&gt; 4 &lt;/property&gt; 5 &lt;/bean&gt; 换句话说，conf/credentials.properties这里保存的就是连接activemq的用户名和密码，启用连接的安全机制后，spring的配置文件要做如下调整： 1 &lt;bean id=&quot;jmsFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt; 2 &lt;property name=&quot;connectionFactory&quot;&gt; 3 &lt;bean class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; 4 &lt;!--broker服务的地址--&gt; 5 &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot;/&gt; 6 &lt;!--默认值为1000,如果不需要这么大,可以调小--&gt; 7 &lt;property name=&quot;maxThreadPoolSize&quot; value=&quot;100&quot;/&gt; 8 &lt;property name=&quot;userName&quot; value=&quot;system&quot;/&gt; 9 &lt;property name=&quot;password&quot; value=&quot;manager&quot;/&gt; 10 &lt;/bean&gt; 11 &lt;/property&gt; 12 &lt;/bean&gt; View Code 4.2 生产者代码 发送消息的代码有二种写法： a） 利用spring-jms的JmsTemplate + View Code ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.cnblogs.yjmyzz.activemq; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.springframework.jms.core.JmsTemplate; /** * ActiveMQ消息发送示例（利用JMSTemplate） * Author:菩提树下的杨过 http://yjmyzz.cnblogs.com */ public class JmsTemplateProducer { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext( &quot;spring-context.xml&quot; ); JmsTemplate jmsTemplate = context.getBean(JmsTemplate. class ); System.out.println( &quot;准备发送消息...&quot; ); int max = 100000 ; Long start = System.currentTimeMillis(); for ( int i = 0 ; i &lt; max; i++) { jmsTemplate.convertAndSend( &quot;message test:&quot; \\+ i); } Long end = System.currentTimeMillis(); Long elapse = end - start; int perform = Double.valueOf(max / (elapse / 1000d)).intValue(); System.out.print( &quot;发送 &quot; \\+ max + &quot; 条消息，耗时：&quot; \\+ elapse + &quot;毫秒，平均&quot; \\+ perform + &quot;条/秒&quot; ); } } b) 利用activeMQ的Producer + View Code ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package com.cnblogs.yjmyzz.activemq; import org.apache.activemq.command.ActiveMQQueue; import org.apache.activemq.pool.PooledConnectionFactory; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import javax.jms.*; import java.io.IOException; /** * ActiveMQ消息发送示例（利用Producer） * Author:菩提树下的杨过 http://yjmyzz.cnblogs.com */ public class ActiveMQProducer { public static void main(String[] args) throws JMSException, IOException, InterruptedException { ApplicationContext context = new ClassPathXmlApplicationContext( &quot;spring-context.xml&quot; ); PooledConnectionFactory connectionFactory = context.getBean(PooledConnectionFactory. class ); ActiveMQQueue destination = context.getBean(ActiveMQQueue. class ); Connection connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession( false , Session.AUTO_ACKNOWLEDGE); MessageProducer producer = session.createProducer(destination); System.out.println( &quot;准备发送消息...&quot; ); int max = 100000 ; Long start = System.currentTimeMillis(); for ( int i = 0 ; i &lt; max; i++) { TextMessage msg = session.createTextMessage( &quot;message test:&quot; \\+ i); //msg.setIntProperty(&quot;id&quot;, i); producer.send(msg); } Long end = System.currentTimeMillis(); Long elapse = end - start; int perform = Double.valueOf(max / (elapse / 1000d)).intValue(); System.out.print( &quot;发送 &quot; \\+ max + &quot; 条消息，耗时：&quot; \\+ elapse + &quot;毫秒，平均&quot; \\+ perform + &quot;条/秒&quot; ); //producer.send(session.createTextMessage(&quot;SHUTDOWN&quot;)); //Thread.sleep(1000 * 3); //connection.close(); System.exit( 0 ); } } 这二种方式在性能上差不多，4核8G的mac bookpro上，大致每秒可以写入3k+条消息。但是从代码量来讲，明显JmsTemplate的代码量更少，推荐使用。 4.3 消费者代码 当然也可以用JmsTemplate接收消息，但是一般得自己去写while(true)循环，而且默认情况下，上下文如果不是同一个连接，JmsTemplateA发出的消息，JmsTemplateB是接收不到的，所以不建议这种方式。最好参考下面的示例，使用JMS的MessageLisenter去监听消息，这也是JMS规范建议的标准做法： + View Code ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package com.cnblogs.yjmyzz.activemq; import org.apache.activemq.command.ActiveMQQueue; import org.apache.activemq.pool.PooledConnectionFactory; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import javax.jms.*; import java.io.IOException; /** * ActiveMQ消息接收示例(使用MessageListener) * Author:菩提树下的杨过 http://yjmyzz.cnblogs.com */ public class MessageListenerConsumer { public static void main(String[] args) throws JMSException, IOException { ApplicationContext context = new ClassPathXmlApplicationContext( &quot;spring-context.xml&quot; ); PooledConnectionFactory connectionFactory = context.getBean(PooledConnectionFactory. class ); ActiveMQQueue destination = context.getBean(ActiveMQQueue. class ); Connection connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession( false , Session.AUTO_ACKNOWLEDGE); MessageConsumer consumer = session.createConsumer(destination); consumer.setMessageListener( new ActiveMQListener()); System.in.read(); } static class ActiveMQListener implements MessageListener { @Override public void onMessage(Message message) { try { if (message instanceof TextMessage) { System.out.println(((TextMessage) message).getText()); } } catch (JMSException e) { e.printStackTrace(); } } } } 4.4 嵌入式Broker 类似jetty、tombat之类可以内嵌到代码中启动一样，ActiveMQ也可以直接在代码中内嵌启动，这个很方便一些轻量级的使用场景，示例代码如下： + View Code ? 1 2 3 4 5 6 7 8 public class EmbbedBroker { public static void main(String[] args) throws Exception { BrokerService broker = new BrokerService(); broker.addConnector( &quot;tcp://localhost:61616&quot; ); broker.start(); System.out.println( &quot;ActiveMQ 已启动!&quot; ); } } 关于嵌入式Broker的更多细节，可以参考 http://activemq.apache.org/how-do-i-embed-a-broker-inside-a-connection.html 4.5 消息的自动确认与手动确认 在接收消息时，如果Session使用的是 Session.AUTO_ACKNOWLEDGE，即： ? 1 Session session = connection.createSession( false , Session.AUTO_ACKNOWLEDGE); 则消息一旦被接受，不论onMessage()里的业务逻辑执行成功与否，消息都将从ActiveMQ的队列里立刻删除。如果希望业务处理成功后，再通知ActiveMQ删除消息，可以改成： ? 1 Session session = connection.createSession( false , Session.CLIENT_ACKNOWLEDGE); 然后onMessage方法调用message.acknowledge手动确认，参考以下代码： ? 1 2 3 4 5 6 7 8 9 10 11 12 13 static class ActiveMQListener implements MessageListener { @Override public void onMessage(Message message) { try { if (message instanceof TextMessage) { System.out.println(((TextMessage) message).getText()); message.acknowledge(); //手动确认消息 } } catch (JMSException e) { e.printStackTrace(); } } }","categories":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://www.itchina.top/categories/ActiveMQ/"}],"tags":[{"name":"activemq","slug":"activemq","permalink":"https://www.itchina.top/tags/activemq/"}]},{"title":"7个步骤让PC网站自动适配手机网页","slug":"7个步骤让PC网站自动适配手机网页","date":"2018-04-19T16:34:21.408Z","updated":"2018-04-19T16:30:17.424Z","comments":true,"path":"2018/04/20/7个步骤让PC网站自动适配手机网页/","link":"","permalink":"https://www.itchina.top/2018/04/20/7个步骤让PC网站自动适配手机网页/","excerpt":"","text":"传统的网站如何完成向移动设备的快速转型？ 通过移动适配技术可以实现，切图网是国内首家基于web技术服务的公司，而移动适配主要通过底层的web技术开发手段来完成，下面切图网将从技术角度来告诉你通过7个步骤来完成一个PC网站向移动设备的跳跃！ 1允许网页宽度自动调整 “自适应网页设计”到底是怎么做到的？其实并不难。 首先，在网页代码的头部，加入一行viewport元标签。 viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。 所有主流浏览器都支持这个设置，包括IE9。对于那些老式浏览器（主要是IE6、7、8），需要使用css3-mediaqueries.js。 2、不使用绝对宽度 由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。 具体说，CSS代码不能指定像素宽度： width:xxxpx; 只能指定百分比宽度： width:xx%; 或者 width:auto; 3、相对大小的字体 字体也不能使用绝对大小（px），而只能使用相对大小（em）。 body{ font:normal100%Helvetica,Arial,sans-serif; } 上面的代码指定，字体大小是页面默认大小的100%，即16像素。 h1{ font-size:1.5em; } 然后，h1的大小是默认大小的1.5倍，即24像素（24/16=1.5）。 small{ font-size:0.875em; } small元素的大小是默认大小的0.875倍，即14像素（14/16=0.875）。 4、流动布局（fluidgrid） “流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。 .main{ float:right; width:70%; } .leftBar{ float:left; width:25%; } float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。 另外，绝对定位（position:absolute）的使用，也要非常小心。 5、选择加载CSS “自适应网页设计”的核心，就是CSS3引入的MediaQuery模块。 它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 media=”screenand(max-device-width:400px)” href=”tinyScreen.css”/&gt; 上面的代码意思是，如果屏幕宽度小于400像素（max-device-width:400px），就加载tinyScreen.css文件。 media=”screenand(min-width:400px)and(max-device-width:600px)” href=”smallScreen.css”/&gt; 如果屏幕宽度在400像素到600像素之间，则加载smallScreen.css文件。 除了用html标签加载CSS文件，还可以在现有CSS文件中加载。 6、CSS的@media规则 同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 @mediascreenand(max-device-width:400px){ .column{ float:none; width:auto; } #sidebar{ display:none; } } 上面的代码意思是，如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）。 7、图片的自适应（fluidimage） 除了布局和文本，”自适应网页设计”还必须实现图片的自动缩放。 这只要一行CSS代码： img{max-width:100%;} 这行代码对于大多数嵌入网页的视频也有效，所以可以写成： img,object{max-width:100%;} 老版本的IE不支持max-width，所以只好写成： img{width:100%;} 此外，windows平台缩放图片时，可能出现图像失真现象。这时，可以尝试使用IE的专有命令： img{-ms-interpolation-mode:bicubic;} 或者，EthanMarcotte的imgSizer.js。 addLoadEvent(function(){ varimgs=document.getElementById(“content”).getElementsByTagName(“img”); imgSizer.collate(imgs); }); 最好还是做适配分辨率的图片。有很多方法可以做到同样效果，服务器端和客户端都可以实现。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.itchina.top/categories/web前端/"}],"tags":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://www.itchina.top/tags/搜索引擎/"},{"name":"优化","slug":"优化","permalink":"https://www.itchina.top/tags/优化/"}]},{"title":"40个Java多线程问题总结","slug":"40个Java多线程问题总结","date":"2018-04-19T16:34:21.408Z","updated":"2018-04-19T16:29:56.077Z","comments":true,"path":"2018/04/20/40个Java多线程问题总结/","link":"","permalink":"https://www.itchina.top/2018/04/20/40个Java多线程问题总结/","excerpt":"","text":"前言 个人认为，学习，内容越多、越杂的知识，越需要进行深刻的总结，这样才能记忆深刻，将知识变成自己的。这篇文章主要是对多线程的问题进行总结的，因此罗列了40个多线程的问题。 这些多线程的问题，有些来源于各大网站、有些来源于自己的思考。可能有些问题网上有、可能有些问题对应的答案也有、也可能有些各位网友也都看过，但是本文写作的重心就是 所有的问题都会按照自己的理解回答一遍，不会去看网上的答案 ，因此可能有些问题讲的不对，能指正的希望大家不吝指教。 40个问题汇总 1、多线程有什么用？ 一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法： （1）发挥多核CPU的优势 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。 单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了 。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。 （2）防止阻塞 从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 （3）便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 2、创建线程的方式 比较常见的一个问题了，一般就是两种： （1）继承Thread类 （2）实现Runnable接口 至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度， 面向接口编程 也是设计模式6大原则的核心。 3、start()方法和run()方法的区别 只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。 4、Runnable接口和Callable接口的区别 有点深的问题了，也看出一个Java程序员学习知识的广度。 Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 这其实是很有用的一个特性，因为 多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性 ，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。 5、CyclicBarrier和CountDownLatch的区别 两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于： （1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行 （2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 （3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 6、volatile关键字的作用 一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个： （1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据 （2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是 Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互 ，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。 7、什么是线程安全 又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的： 如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的 。 这个问题有值得一提的地方，就是线程安全也是有几个级别的： （1）不可变 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 （2）绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet （3）相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是 fail-fast机制 。 （4）线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类 8、Java中如何获取到线程dump文件 死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步： （1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java （2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid 另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈， 9、一个线程如果出现了运行时异常会怎么样 如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是： 如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放 10、如何在两个线程之间共享数据 通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的 11、sleep方法和wait方法有什么区别 这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器 12、生产者消费者模型的作用是什么 这个问题很理论，但是很重要： （1） 通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率 ，这是生产者消费者模型最重要的作用 （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约 13、ThreadLocal有什么用 简单说ThreadLocal就是一种以 空间换时间 的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了 14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用 这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁 15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别 wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于： wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器 。 16、为什么要使用线程池 避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 17、怎么检测一个线程是否持有对象监视器 我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Objectobj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着 “某条线程”指的是当前线程 。 18、synchronized和ReentrantLock的区别 synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： （1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 （2）ReentrantLock可以获取各种锁的信息 （3）ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。 19、ConcurrentHashMap的并发度是什么 ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？ 20、ReadWriteLock是什么 首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。 因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离， 读锁是共享的，写锁是独占的 ，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 21、FutureTask是什么 这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。 22、Linux环境下如何查找哪个线程使用CPU最长 这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做： （1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过 （2）top -H -p pid，顺序不能改变 这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。 使用”top -H -p pid”+”jpspid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。 最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jpspid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。 23、Java编程写一个会导致死锁的程序 第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。 真正理解什么是死锁，这个问题其实不难，几个步骤： （1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁； （2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁 （3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的 这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多， Java多线程7：死锁 这篇文章里面有，就是上面步骤的代码实现。 24、怎么唤醒一个阻塞的线程 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 25、不可变对象对多线程有什么帮助 前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 26、什么是多线程的上下文切换 多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。 27、如果你提交任务时，线程池队列已满，这时会发生什么 这里区分一下： 如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务 如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy 28、Java中用到的线程调度算法是什么 抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 29、Thread.sleep(0)的作用是什么 这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。 30、什么是自旋 很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 31、什么是Java内存模型 Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容： （1）Java内存模型将内存分为了 主内存和工作内存 。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 （2）定义了几个原子操作，用于操作主内存和工作内存中的变量 （3）定义了volatile变量的使用规则 （4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的 32、什么是CAS CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数： 内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false 。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。 33、什么是乐观锁和悲观锁 （1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将 比较-替换 这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 （2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。 34、什么是AQS 简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。 如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。 AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。 35、单例模式的线程安全性 老生常谈的问题了，首先要说的是单例模式的线程安全意味着： 某个类的实例在多线程环境下只会被创建一次出来 。单例模式有很多种的写法，我总结一下： （1）饿汉式单例模式的写法：线程安全 （2）懒汉式单例模式的写法：非线程安全 （3）双检锁单例模式的写法：线程安全 36、Semaphore有什么作用 Semaphore就是一个信号量，它的作用是 限制某段代码块的并发数 。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。 37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？ 这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？ 关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点： （1） 同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问 。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性 （2） CPU执行代码，执行的不是Java代码，这点很关键，一定得记住 。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。 即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个 。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。 38、线程类的构造方法、静态块是被哪个线程调用的 这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。 如果说上面的说法让你感到困惑，那么我举个例子， 假设Thread2中new了Thread1，main函数中new了Thread2，那么： （1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的 （2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的 39、同步方法和同步块，哪个是更好的选择 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则： 同步的范围越小越好 。 借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做 锁粗化 的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。 40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？ 这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是： （1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换 （2）并发不高、任务执行时间长的业务要区分开看： a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 （3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。 ** ================================================================================== 我不能保证写的每个地方都是对的，但是至少能保证不复制、不黏贴，保证每一句话、每一行代码都经过了认真的推敲、仔细的斟酌。每一篇文章的背后，希望都能看到自己对于技术、对于生活的态度。 我相信乔布斯说的，只有那些疯狂到认为自己可以改变世界的人才能真正地改变世界。面对压力，我可以挑灯夜战、不眠不休；面对困难，我愿意迎难而上、永不退缩。 ** 其实我想说的是，我只是一个程序员，这就是我现在纯粹人生的全部。 ==================================================================================","categories":[{"name":"J2EE","slug":"J2EE","permalink":"https://www.itchina.top/categories/J2EE/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.itchina.top/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://www.itchina.top/tags/多线程/"}]},{"title":"【译】Redis Cluster官方教程","slug":"【译】Redis Cluster官方教程","date":"2018-04-19T16:34:21.407Z","updated":"2018-04-19T16:30:29.759Z","comments":true,"path":"2018/04/20/【译】Redis Cluster官方教程/","link":"","permalink":"https://www.itchina.top/2018/04/20/【译】Redis Cluster官方教程/","excerpt":"","text":"摘要这篇文章主要介绍redis cluster可用性和一致性相关的特性，值得一提的是，redis cluster需要高于等于redis3.0版本。 概要 这篇文章主要介绍redis cluster可用性和一致性相关的特性，值得一提的是，redis cluster需要高于等于redis3.0版本。 Redis Cluster 101 Redis Cluster提供了一种数据自动分片到不同Redis实例中的解决方案，Redis Cluster在一定程度上提高了Redis系统的可用性，即当一些节点挂掉之后，其他节点还可以继续提供服务。而当大部分的master节点都挂掉的时候，Redis Cluster会停止服务。因此Redis Cluster带来了： 自动将数据分散到不同的节点。 允许当一些节点挂掉之后剩下的节点仍然可以工作，或者是禁止这些节点继续工作。 Redis Cluster TCP ports 每一个Redis Cluster节点需要开两个TCP端口，一个是用来处理客户端的请求，例如6379端口，另一个端口由第一个端口加上10000之后得到即16379，第二个端口用来作为集群总线，也就是集群之间节点相互进行二进制通信用的。集群总线的用处如下： 错误检测 配置更新 failover …… 客户端的连接端口和集群总线的连接端口之间的距离10000是固定的。为了让Redis Cluster正常的工作，对于每一个节点： 客户端连接端口需要能够和Cluster进行通信，用于keys迁移。 所有节点的Cluster端口能够相互通信。 如果这两个端口没有打开，则Redis Cluster不能够正常工作。Cluster端口之间使用特殊的二进制协议进行通信，这种二进制协议更适合节点之间通信，可以占用更小的带宽和更少的传输时间。 Redis Cluster Docker 当前的Redis Cluster不支持NATted环境，Docker使用端口映射技术，也即运行在Docker容器内部的应用暴露在容器外面的端口和应用暴露的端口不一样，这对于多个应用在Docker中使用同一个端口是非常重要的。为了让Redis Cluster能够在Docker中好好工作，我们需要检查–net=host选项，更多的信息见 Docket文档 。 Redis Cluster 数据 sharding Redis Cluster不使用一致性哈希，但是不同形式的sharding，每一个key理论上是hash slot的一部分。在RedisCluster中有16384个hash slot，为了计算指定key的hashslot，我们简单的使用CRC16算法并对结果进行16384取模。在Redis Cluster中的每一个节点代表着所有hashslot的一个子集，例如我们有三个节点： Node A 包括0到5500之间的hash slots Node B 包括5501到11000之间的hash slots Node C 包括11001到16383之间的hash slots 这使得可以很容易的向Redis Cluster中添加或删除节点。例如，我们想要添加一个节点D，我们需要将一些hashslots从A，B，C节点移给D。假如我们想要移除A节点，我们可以把A节点上原有的hash slots移动到B和C节点。当A节点的hashslots移除完毕之后，就可以把A节点下线了。将hash slots从一个节点移动到其他节点不需要任何的停机操作。Redis Cluster支持多key操作，多个key是通过一个命令、或者一个事务、或者一个lua脚本执行的，属于同一个hashslot。用户可以强制多个key属于同一个hash slot，这个概念叫hash tags。Hash tags有关的介绍在Redis Cluster规范里面有介绍，主旨是当key中包含{}的时候，只有{}括号内的字符串才被用来hash。例如，一个key是this{key}，另一个key是that{key}，他们会被映射到同一个hash slot，而且可以被用于一批key一个命令的操作。 Redis Cluster master-slave模式 为了让当某一个master挂掉之后，这个master的hash slot仍然可以使用，Redis Cluster使用master-slave模式，因此对于每一批hash slot来说都有N个备份，其中N-1个是slave。在我们的例子中，节点A、B、C，如果B挂了，则整个RedisCluster就不能用了，因为没有实例类服务5501-11000这部分hashslots。但是如果我们为每个master节点各增加一个slave节点，比如A1，B1，C1节点，如果B挂了，整个集群还是可以正常工作的。Node B1是B的复制，如果B挂了，Cluster将会选择B1作为新的master，然后继续工作。值得注意的是，如果B和B1同时挂了，那就没辙了。 Redis Cluster一致性保证 Redis Cluster并不保证强一致性，也就是在一定条件下，Redis Cluster可能丢失被确认写入的数据，第一个有可能RedisCluster丢失数据的原因是因为复制是异步进行的，意味着下面情景有可能发生： 客户端将数据写入B master B回复客户端写入成功 master将写命令传播给B1，B2和B3 我们可以看到，在B回复客户端之前不会等到B1，B2，B3的应答。因此如果客户端向B写了数据，B确认了，但是在数据复制到B1，B2，B3之前挂了，那数据对于B1，B2，B3来说就丢失了。和传统的数据库类似，可以强制数据库将日志写入磁盘再告知客户端写成功，但是这么做带来的性能损耗是非常大的，这对于RedisCluster来说就是同步复制。所以这就是一致性和可用性之间的权衡，如果确实需要，Redis Cluster是支持同步写的，由WAIT命令实现，这可以保证尽量少的丢失数据，尽管RedisCluster提供了同步复制的支持，但是Redis Cluster并没有实现强一致性，因此在一些复杂的应用场景中，还是有可能丢失数据的。另外一个数据会丢失的场景也值得一提，即当出现网络分区的时候，也就是某一个或多个master和其他的master失去了联系，举个例子，我们有六个Redis实例，三个master和三个slave，还有一个client我们把它叫做Z1。当出现网络分区的时候，比如A，C，A1，B1，C1，处于一个分区，另一个分区有B和Z1。Z1还可以向B写数据，B也接受了Z1的写请求，如果分区只持续一小段时间，Cluster仍然可以继续工作。然而，如果时间足够大，Cluster选举了B1作为master，那么之前Z1写入的数据就丢失了。值得一提的是在Z1还可以向B写数据的时候，有一个最大的窗口时间，如果过了这个时间，Cluster选取了B1作为master，B就不能够接受写请求了。这段时间是非常重要的，这个时间被叫做node timeout。当nodetimeout之后，master被认为出问题了，并且可以被其slave代替，然后master不能够处理写请求。 Redis Cluster配置参数 cluster-enabled&lt;yes/no&gt; ：如果是yes，则当前redis启动为Redis Cluster的一个实例，否则当前Redis以单机模式启动。 cluster-config-file :值得注意的是这个配置文件是用户不可编辑的，是由Redis 集群节点自动创建的，每次节点状态有变化的时候都会持久化这个配置文件，也是为了Redis集群节点重启的时候重新读取。配置文件的内容包括集群中的其他节点、他们的状态、持久变量等等。每当接受到消息的时候，文件会被刷新并且写入磁盘。 cluster-node-timeout ：Redis集群节点的超时时间，如果在这个时间内Redis集群节点不可达，则集群将会执行failover策略，将该master的slave节点选为master。这个参数控制Redis集群重要的，值得提的是，如果指定时间当前节点联系不到大多数的master，则会拒绝服务。 cluster-slave-validity-factor ：如果将该项设置为0，不管slave节点和master节点间失联多久都会一直尝试failover（设为正数，失联大于一定时间（factor*节点TimeOut），不再进行FailOver）。比如，如果节点的timeout设置为5秒，该项设置为10，如果master跟slave之间失联超过50秒，slave不会去failover它的master（意思是不会去把master设置为挂起状态，并取代它）。注意：任意非0数值都有可能导致当master挂掉又没有slave去failover它，这样redis集群不可用。在这种情况下只有原来那个master重新回到集群中才能让集群恢复工作。 cluster-migration-barrier ：一个master可以拥有的最小slave数量。该项的作用是，当一个master没有任何slave的时候，某些有富余slave的master节点，可以自动的分一个slave给它。 cluster-require-full-coverage&lt;yes/no&gt; ：如果该项设置为yes（默认就是yes） 当一定比例的键空间没有被覆盖到（就是某一部分的哈希槽没了，有可能是暂时挂了）集群就停止处理任何查询操作。如果该项设置为no，那么就算请求中只有一部分的键可以被查到，一样可以查询（但是有可能会查不全）","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.itchina.top/categories/Redis/"}],"tags":[]},{"title":"GeneratedValue注解","slug":"GeneratedValue注解","date":"2018-04-19T16:34:21.406Z","updated":"2018-04-19T16:37:34.300Z","comments":true,"path":"2018/04/20/GeneratedValue注解/","link":"","permalink":"https://www.itchina.top/2018/04/20/GeneratedValue注解/","excerpt":"","text":"一、JPA通用策略生成器通过annotation来映射hibernate实体的,基于annotation的hibernate主键标识为@Id,其生成规则由@GeneratedValue设定的.这里的@id和@GeneratedValue都是JPA的标准用法,JPA提供四种标准用法,由@GeneratedValue的源代码可以明显看出. 1 @Target({METHOD,FIELD}) 2 @Retention(RUNTIME) 3 public @interface GeneratedValue{ 4 GenerationType strategy() default AUTO; 5 String generator() default &quot;&quot;; 6 } 其中GenerationType: 1 public enum GenerationType{ 2 TABLE, 3 SEQUENCE, 4 IDENTITY, 5 AUTO 6 } JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO.TABLE：使用一个特定的数据库表格来保存主键。SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。IDENTITY：主键由数据库自动生成（主要是自动增长型）AUTO：主键由程序控制。 1、TABLE 1 @Id 2 @GeneratedValue(strategy = GenerationType.TABLE, generator=&quot;payablemoney_gen&quot;) 3 @TableGenerator(name = &quot;pk_gen&quot;, 4 table=&quot;tb_generator&quot;, 5 pkColumnName=&quot;gen_name&quot;, 6 valueColumnName=&quot;gen_value&quot;, 7 pkColumnValue=&quot;PAYABLEMOENY_PK&quot;, 8 allocationSize=1 9 ) 这里应用表tb_generator，定义为 1 CREATE TABLE tb_generator ( 2 id NUMBER NOT NULL, 3 gen_name VARCHAR2(255) NOT NULL, 4 gen_value NUMBER NOT NULL, 5 PRIMARY KEY(id) 6 ) 插入纪录，供生成主键使用， 1 INSERT INTO tb_generator(id, gen_name, gen_value) VALUES (1,PAYABLEMOENY_PK&apos;, 1); 在主键生成后，这条纪录的value值，按allocationSize递增。 @TableGenerator的定义： 1 @Target({TYPE, METHOD, FIELD}) 2 @Retention(RUNTIME) 3 public @interface TableGenerator { 4 String name(); 5 String table() default &quot;&quot;; 6 String catalog() default &quot;&quot;; 7 String schema() default &quot;&quot;; 8 String pkColumnName() default &quot;&quot;; 9 String valueColumnName() default &quot;&quot;; 10 String pkColumnValue() default &quot;&quot;; 11 int initialValue() default 0; 12 int allocationSize() default 50; 13 UniqueConstraint[] uniqueConstraints() default {}; 14 } 其中属性说明：name属性表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中。table属性表示表生成策略所持久化的表名，例如，这里表使用的是数据库中的“tb_generator”。catalog属性和schema具体指定表所在的目录名或是数据库名。pkColumnName属性的值表示在持久化表中，该主键生成策略所对应键值的名称。例如在“tb_generator”中将“gen_name”作为主键的键值valueColumnName属性的值表示在持久化表中，该主键当前所生成的值，它的值将会随着每次创建累加。例如，在“tb_generator”中将“gen_value”作为主键的值pkColumnValue属性的值表示在持久化表中，该生成策略所对应的主键。例如在“tb_generator”表中，将“gen_name”的值为“CUSTOMER_PK”。initialValue表示主键初识值，默认为0。allocationSize表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。UniqueConstraint与@Table标记中的用法类似。 2、SEQUENCE 1 @Id 2 @GeneratedValue(strategy = GenerationType.SEQUENCE,generator=&quot;payablemoney_seq&quot;) 3 @SequenceGenerator(name=&quot;payablemoney_seq&quot;, sequenceName=&quot;seq_payment&quot;) @SequenceGenerator定义 1 @Target({TYPE, METHOD, FIELD}) 2 @Retention(RUNTIME) 3 public @interface SequenceGenerator { 4 String name(); 5 String sequenceName() default &quot;&quot;; 6 int initialValue() default 0; 7 int allocationSize() default 50; 8 } name属性表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中。sequenceName属性表示生成策略用到的数据库序列名称。initialValue表示主键初识值，默认为0。allocationSize表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。 3、IDENTITY 1 @Id 2 @GeneratedValue(strategy = GenerationType.IDENTITY) 4、AUTO 1 @Id 2 @GeneratedValue(strategy = GenerationType.AUTO) 在指定主键时，如果不指定主键生成策略，默认为AUTO。 1 @Id 跟下面的定义是一样的。 1 @Id 2 @GeneratedValue(strategy = GenerationType.AUTO) 二、hibernate主键策略生成器hibernate提供多种主键生成策略，有点是类似于JPA，有的是hibernate特有：native: 对于 oracle 采用 Sequence 方式，对于MySQL 和 SQL Server采用identity（自增主键生成机制），native就是将主键的生成工作交由数据库完成，hibernate不管（很常用）。uuid: 采用128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。占用空间大（字符串类型）。hilo: 使用hilo生成策略，要在数据库中建立一张额外的表，默认表名为hibernate_unique_key,默认字段为integer类型，名称是next_hi（比较少用）。assigned: 在插入数据的时候主键由程序处理（很常用），这是 元素没有指定时的默认生成策略。等同于JPA中的AUTO。identity: 使用SQL Server 和 MySQL 的自增字段，这个方法不能放到 Oracle 中，Oracle不支持自增字段，要设定sequence（MySQL 和 SQL Server 中很常用）。 等同于JPA中的INDENTITY。select: 使用触发器生成主键（主要用于早期的数据库主键生成机制，少用）。sequence: 调用底层数据库的序列来生成主键，要设定序列名，不然hibernate无法找到。seqhilo: 通过hilo算法实现，但是主键历史保存在Sequence中，适用于支持 Sequence 的数据库，如 Oracle（比较少用）increment:插入数据的时候hibernate会给主键添加一个自增的主键，但是一个hibernate实例就维护一个计数器，所以在多个实例运行的时候不能使用这个方法。foreign: 使用另外一个相关联的对象的主键。通常和联合起来使用。guid: 采用数据库底层的guid算法机制，对应MYSQL的uuid()函数，SQLServer的newid()函数，ORACLE的rawtohex(sys_guid())函数等。uuid.hex: 看uuid，建议用uuid替换。sequence-identity: sequence策略的扩展，采用立即检索策略来获取sequence值，需要JDBC3.0和JDK4以上（含1.4）版本hibernate提供了多种生成器供选择,基于Annotation的方式通过@GenericGenerator实现.hibernate每种主键生成策略提供接口org.hibernate.id.IdentifierGenerator的实现类,如果要实现自定义的主键生成策略也必须实现此接口. 1 public interface IdentifierGenerator { 2 /** 3 * The configuration parameter holding the entity name 4 */ 5 public static final String ENTITY_NAME = &quot;entity_name&quot;; 6 7 /** 8 * Generate a new identifier. 9 * @param session 10 * @param object the entity or toplevel collection for which the id is being generated 11 * 12 * @return a new identifier 13 * @throws HibernateException 14 */ 15 public Serializable generate(SessionImplementor session, Object object) 16 throws HibernateException; 17 } IdentifierGenerator提供一generate方法,generate方法返回产生的主键. 三、@GenericGenerator自定义主键生成策略，由@GenericGenerator实现。hibernate在JPA的基础上进行了扩展，可以用一下方式引入hibernate独有的主键生成策略，就是通过@GenericGenerator加入的。比如说，JPA标准用法 1 @Id 2 @GeneratedValue(GenerationType.AUTO) 就可以用hibernate特有以下用法来实现 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;assigned&quot;) @GenericGenerator的定义: 1 @Target({PACKAGE, TYPE, METHOD, FIELD}) 2 @Retention(RUNTIME) 3 public @interface GenericGenerator { 4 /** 5 * unique generator name 6 */ 7 String name(); 8 /** 9 * Generator strategy either a predefined Hibernate 10 * strategy or a fully qualified class name. 11 */ 12 String strategy(); 13 /** 14 * Optional generator parameters 15 */ 16 Parameter[] parameters() default {}; 17 } name属性指定生成器名称。strategy属性指定具体生成器的类名。parameters得到strategy指定的具体生成器所用到的参数。 对于这些hibernate主键生成策略和各自的具体生成器之间的关系,在org.hibernate.id.IdentifierGeneratorFactory中指定了, 1 static { 2 GENERATORS.put(&quot;uuid&quot;, UUIDHexGenerator.class); 3 GENERATORS.put(&quot;hilo&quot;, TableHiLoGenerator.class); 4 GENERATORS.put(&quot;assigned&quot;, Assigned.class); 5 GENERATORS.put(&quot;identity&quot;, IdentityGenerator.class); 6 GENERATORS.put(&quot;select&quot;, SelectGenerator.class); 7 GENERATORS.put(&quot;sequence&quot;, SequenceGenerator.class); 8 GENERATORS.put(&quot;seqhilo&quot;, SequenceHiLoGenerator.class); 9 GENERATORS.put(&quot;increment&quot;, IncrementGenerator.class); 10 GENERATORS.put(&quot;foreign&quot;, ForeignGenerator.class); 11 GENERATORS.put(&quot;guid&quot;, GUIDGenerator.class); 12 GENERATORS.put(&quot;uuid.hex&quot;, UUIDHexGenerator.class); //uuid.hex is deprecated 13 GENERATORS.put(&quot;sequence-identity&quot;, SequenceIdentityGenerator.class); 14 } 上面十二种策略，加上native，hibernate一共默认支持十三种生成策略。 1、native 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;native&quot;) 2、uuid 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;uuid&quot;) 3、hilo 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;hilo&quot;) 4、assigned 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;assigned&quot;) 5、identity 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;identity&quot;) 6、select 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name=&quot;select&quot;, strategy=&quot;select&quot;, 3 parameters = { @Parameter(name = &quot;key&quot;, value = &quot;idstoerung&quot;) }) 7、sequence 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;sequence&quot;, 3 parameters = { @Parameter(name = &quot;sequence&quot;, value = &quot;seq_payablemoney&quot;) }) 8、seqhilo 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;seqhilo&quot;, 3 parameters = { @Parameter(name = &quot;max_lo&quot;, value = &quot;5&quot;) }) 9、increment 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;increment&quot;) 10、foreign 1 @GeneratedValue(generator = &quot;idGenerator&quot;) 2 @GenericGenerator(name = &quot;idGenerator&quot;, strategy = &quot;foreign&quot;, 3 parameters = { @Parameter(name = &quot;property&quot;, value = &quot;employee&quot;) }) 注意：直接使用@PrimaryKeyJoinColumn 报错 1 @OneToOne(cascade = CascadeType.ALL) 2 @PrimaryKeyJoinColumn 例如 1 @Entity 2 public class Employee { 3 @Id Integer id; 4 5 @OneToOne @PrimaryKeyJoinColumn 6 EmployeeInfo info; 7 ... 8 } 应该为 1 @Entity 2 public class Employee { 3 @Id 4 @GeneratedValue(generator = &quot;idGenerator&quot;) 5 @GenericGenerator(name = &quot;idGenerator&quot;, strategy = &quot;foreign&quot;, 6 parameters = { @Parameter(name = &quot;property&quot;, value = &quot;info&quot;) }) 7 Integer id; 8 9 @OneToOne 10 EmployeeInfo info; 11 ... 12 } 11、guid 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;guid&quot;) 12、uuid.hex 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;uuid.hex&quot;) 13、sequence-identity 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;sequence-identity&quot;, 3 parameters = { @Parameter(name = &quot;sequence&quot;, value = &quot;seq_payablemoney&quot;) }) 四、通过@GenericGenerator自定义主键生成策略如果实际应用中，主键策略为程序指定了就用程序指定的主键（assigned），没有指定就从sequence中取。明显上面所讨论的策略都不满足，只好自己扩展了，集成assigned和sequence两种策略。 1 public class AssignedSequenceGenerator extends SequenceGenerator implements 2 PersistentIdentifierGenerator, Configurable { 3 private String entityName; 4 5 public void configure(Type type, Properties params, Dialect dialect) throws MappingException { 6 entityName = params.getProperty(ENTITY_NAME); 7 if (entityName==null) { 8 throw new MappingException(&quot;no entity name&quot;); 9 } 10 11 super.configure(type, params, dialect); 12 } 13 14 public Serializable generate(SessionImplementor session, Object obj) 15 throws HibernateException { 16 17 Serializable id = session.getEntityPersister( entityName, obj ) 18 .getIdentifier( obj, session.getEntityMode() ); 19 20 if (id==null) { 21 id = super.generate(session, obj); 22 } 23 24 return id; 25 } 26 } 实际应用中，定义同sequence。 1 @GeneratedValue(generator = &quot;paymentableGenerator&quot;) 2 @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;AssignedSequenceGenerator&quot;, 3 parameters = { @Parameter(name = &quot;sequence&quot;, value = &quot;seq_payablemoney&quot;) }) 四种数据库的支持情况如下： 数据库名称 支持的ID生成策略 MySql GenerationType. _ TABLE _ GenerationType. _ AUTO _ GenerationType. _ IDENTITY _ _ 不支持 _ GenerationType. _ SEQUENCE _ oracle strategy= GenerationType . _ AUTO _ GenerationType. _ SEQUENCE _ GenerationType. _ TABLE _ _ 不支持 _ GenerationType. _ IDENTITY _ postgreSQL GenerationType. _ TABLE _ GenerationType. _ AUTO _ GenerationType. _ IDENTITY _ GenerationType. _ SEQUENCE _ _ 都支持 _ __ kingbase GenerationType. _ TABLE _ GenerationType. _ SEQUENCE _ GenerationType. _ IDENTITY _ GenerationType. _ AUTO _ _ 都支持 _","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.itchina.top/categories/Spring/"}],"tags":[]},{"title":"PyCharm 服务器激活","slug":"PyCharm-服务器激活","date":"2018-04-06T04:57:55.000Z","updated":"2018-04-06T04:58:54.476Z","comments":true,"path":"2018/04/06/PyCharm-服务器激活/","link":"","permalink":"https://www.itchina.top/2018/04/06/PyCharm-服务器激活/","excerpt":"PyCharm 服务器激活地址","text":"PyCharm 服务器激活地址http://xidea.online 激活步骤： 1、选择License server（不同的版本可能License server选项的位置不同） 2.在下面的框内输入上面提供的服务器激活地址即可。","categories":[],"tags":[{"name":"ide","slug":"ide","permalink":"https://www.itchina.top/tags/ide/"}]},{"title":"idea服务器激活","slug":"idea服务器激活","date":"2018-04-02T15:33:17.000Z","updated":"2018-04-02T15:56:52.767Z","comments":true,"path":"2018/04/02/idea服务器激活/","link":"","permalink":"https://www.itchina.top/2018/04/02/idea服务器激活/","excerpt":"idea服务器激活地址","text":"idea服务器激活地址http://btsha.com:41017","categories":[],"tags":[{"name":"ide","slug":"ide","permalink":"https://www.itchina.top/tags/ide/"}]}]}